{
  "url": "https://docs.nestjs.com/exception-filters",
  "title": "",
  "content": "Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.\n\nOut of the box, this action is performed by a built-in global exception filter, which handles exceptions of type HttpException (and subclasses of it). When an exception is unrecognized (is neither HttpException nor a class that inherits from HttpException), the built-in exception filter generates the following default JSON response:\n\nNest provides a built-in HttpException class, exposed from the @nestjs/common package. For typical HTTP REST/GraphQL API based applications, it's best practice to send standard HTTP response objects when certain error conditions occur.\n\nFor example, in the CatsController, we have a findAll() method (a GET route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows:\n\nWhen the client calls this endpoint, the response looks like this:\n\nThe HttpException constructor takes two required arguments which determine the response:\n\nBy default, the JSON response body contains two properties:\n\nTo override just the message portion of the JSON response body, supply a string in the response argument. To override the entire JSON response body, pass an object in the response argument. Nest will serialize the object and return it as the JSON response body.\n\nThe second constructor argument - status - should be a valid HTTP status code. Best practice is to use the HttpStatus enum imported from @nestjs/common.\n\nThere is a third constructor argument (optional) - options - that can be used to provide an error cause. This cause object is not serialized into the response object, but it can be useful for logging purposes, providing valuable information about the inner error that caused the HttpException to be thrown.\n\nHere's an example overriding the entire response body and providing an error cause:\n\nUsing the above, this is how the response would look:\n\nBy default, the exception filter does not log built-in exceptions like HttpException (and any exceptions that inherit from it). When these exceptions are thrown, they won't appear in the console, as they are treated as part of the normal application flow. The same behavior applies to other built-in exceptions such as WsException and RpcException.\n\nThese exceptions all inherit from the base IntrinsicException class, which is exported from the @nestjs/common package. This class helps differentiate between exceptions that are part of normal application operation and those that are not.\n\nIf you want to log these exceptions, you can create a custom exception filter. We'll explain how to do this in the next section.\n\nIn many cases, you will not need to write custom exceptions, and can use the built-in Nest HTTP exception, as described in the next section. If you do need to create customized exceptions, it's good practice to create your own exceptions hierarchy, where your custom exceptions inherit from the base HttpException class. With this approach, Nest will recognize your exceptions, and automatically take care of the error responses. Let's implement such a custom exception:\n\nSince ForbiddenException extends the base HttpException, it will work seamlessly with the built-in exception handler, and therefore we can use it inside the findAll() method.\n\nNest provides a set of standard exceptions that inherit from the base HttpException. These are exposed from the @nestjs/common package, and represent many of the most common HTTP exceptions:\n\nAll the built-in exceptions can also provide both an error cause and an error description using the options parameter:\n\nUsing the above, this is how the response would look:\n\nWhile the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client.\n\nLet's create an exception filter that is responsible for catching exceptions which are an instance of the HttpException class, and implementing custom response logic for them. To do this, we'll need to access the underlying platform Request and Response objects. We'll access the Request object so we can pull out the original url and include that in the logging information. We'll use the Response object to take direct control of the response that is sent, using the response.json() method.\n\nThe @Catch(HttpException) decorator binds the required metadata to the exception filter, telling Nest that this particular filter is looking for exceptions of type HttpException and nothing else. The @Catch() decorator may take a single parameter, or a comma-separated list. This lets you set up the filter for several types of exceptions at once.\n\nLet's look at the parameters of the catch() method. The exception parameter is the exception object currently being processed. The host parameter is an ArgumentsHost object. ArgumentsHost is a powerful utility object that we'll examine further in the execution context chapter*. In this code sample, we use it to obtain a reference to the Request and Response objects that are being passed to the original request handler (in the controller where the exception originates). In this code sample, we've used some helper methods on ArgumentsHost to get the desired Request and Response objects. Learn more about ArgumentsHosthere.\n\n*The reason for this level of abstraction is that ArgumentsHost functions in all contexts (e.g., the HTTP server context we're working with now, but also Microservices and WebSockets). In the execution context chapter we'll see how we can access the appropriate underlying arguments for any execution context with the power of ArgumentsHost and its helper functions. This will allow us to write generic exception filters that operate across all contexts.\n\nLearn the right way! 80+ chapters 5+ hours of videos Official certificate Deep-dive sessions Explore official courses\n\nLet's tie our new HttpExceptionFilter to the CatsController's create() method.\n\nWe have used the @UseFilters() decorator here. Similar to the @Catch() decorator, it can take a single filter instance, or a comma-separated list of filter instances. Here, we created the instance of HttpExceptionFilter in place. Alternatively, you may pass the class (instead of an instance), leaving responsibility for instantiation to the framework, and enabling dependency injection.\n\nIn the example above, the HttpExceptionFilter is applied only to the single create() route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped of the controller/resolver/gateway, controller-scoped, or global-scoped. For example, to set up a filter as controller-scoped, you would do the following:\n\nThis construction sets up the HttpExceptionFilter for every route handler defined inside the CatsController.\n\nTo create a global-scoped filter, you would do the following:\n\nGlobal-scoped filters are used across the whole application, for every controller and every route handler. In terms of dependency injection, global filters registered from outside of any module (with useGlobalFilters() as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can register a global-scoped filter directly from any module using the following construction:\n\nYou can add as many filters with this technique as needed; simply add each to the providers array.\n\nIn order to catch every unhandled exception (regardless of the exception type), leave the @Catch() decorator's parameter list empty, e.g., @Catch().\n\nIn the example below we have a code that is platform-agnostic because it uses the HTTP adapter to deliver the response, and doesn't use any of the platform-specific objects (Request and Response) directly:\n\nTypically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the built-in default global exception filter, and override the behavior based on certain factors.\n\nIn order to delegate exception processing to the base filter, you need to extend BaseExceptionFilter and call the inherited catch() method.\n\nGlobal filters can extend the base filter. This can be done in either of two ways.\n\nThe first method is to inject the HttpAdapter reference when instantiating the custom global filter:\n\nThe second method is to use the APP_FILTER token as shown here.",
  "headings": [
    {
      "level": "h3",
      "text": "Exception filters",
      "id": "exception-filters"
    },
    {
      "level": "h4",
      "text": "Throwing standard exceptions#",
      "id": "throwing-standard-exceptions"
    },
    {
      "level": "h4",
      "text": "Exceptions logging#",
      "id": "exceptions-logging"
    },
    {
      "level": "h4",
      "text": "Custom exceptions#",
      "id": "custom-exceptions"
    },
    {
      "level": "h4",
      "text": "Built-in HTTP exceptions#",
      "id": "built-in-http-exceptions"
    },
    {
      "level": "h4",
      "text": "Exception filters#",
      "id": "exception-filters-1"
    },
    {
      "level": "h4",
      "text": "Arguments host#",
      "id": "arguments-host"
    },
    {
      "level": "h2",
      "text": "Learn the right way!",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Binding filters#",
      "id": "binding-filters"
    },
    {
      "level": "h4",
      "text": "Catch everything#",
      "id": "catch-everything"
    },
    {
      "level": "h4",
      "text": "Inheritance#",
      "id": "inheritance"
    }
  ],
  "code_samples": [
    {
      "code": "{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}",
      "language": "json"
    },
    {
      "code": "@Get()\nasync findAll() {\n  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);\n}",
      "language": "typescript"
    },
    {
      "code": "{\n  \"statusCode\": 403,\n  \"message\": \"Forbidden\"\n}",
      "language": "json"
    },
    {
      "code": "@Get()\nasync findAll() {\n  try {\n    await this.service.findAll()\n  } catch (error) {\n    throw new HttpException({\n      status: HttpStatus.FORBIDDEN,\n      error: 'This is a custom message',\n    }, HttpStatus.FORBIDDEN, {\n      cause: error\n    });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "{\n  \"status\": 403,\n  \"error\": \"This is a custom message\"\n}",
      "language": "json"
    },
    {
      "code": "export class ForbiddenException extends HttpException {\n  constructor() {\n    super('Forbidden', HttpStatus.FORBIDDEN);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findAll() {\n  throw new ForbiddenException();\n}",
      "language": "typescript"
    },
    {
      "code": "throw new BadRequestException('Something bad happened', {\n  cause: new Error(),\n  description: 'Some error description',\n});",
      "language": "typescript"
    },
    {
      "code": "{\n  \"message\": \"Something bad happened\",\n  \"error\": \"Some error description\",\n  \"statusCode\": 400\n}",
      "language": "json"
    },
    {
      "code": "import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n\n    response\n      .status(status)\n      .json({\n        statusCode: status,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n      });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Catch, HttpException } from '@nestjs/common';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter {\n  catch(exception, host) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n    const status = exception.getStatus();\n\n    response\n      .status(status)\n      .json({\n        statusCode: status,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n      });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@UseFilters(new HttpExceptionFilter())\nasync create(@Body() createCatDto: CreateCatDto) {\n  throw new ForbiddenException();\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@UseFilters(new HttpExceptionFilter())\n@Bind(Body())\nasync create(createCatDto) {\n  throw new ForbiddenException();\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@UseFilters(HttpExceptionFilter)\nasync create(@Body() createCatDto: CreateCatDto) {\n  throw new ForbiddenException();\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@UseFilters(HttpExceptionFilter)\n@Bind(Body())\nasync create(createCatDto) {\n  throw new ForbiddenException();\n}",
      "language": "typescript"
    },
    {
      "code": "@Controller()\n@UseFilters(new HttpExceptionFilter())\nexport class CatsController {}",
      "language": "typescript"
    },
    {
      "code": "async function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalFilters(new HttpExceptionFilter());\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { APP_FILTER } from '@nestjs/core';\n\n@Module({\n  providers: [\n    {\n      provide: APP_FILTER,\n      useClass: HttpExceptionFilter,\n    },\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\n@Catch()\nexport class CatchEverythingFilter implements ExceptionFilter {\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  catch(exception: unknown, host: ArgumentsHost): void {\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n\n    const httpStatus =\n      exception instanceof HttpException\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    const responseBody = {\n      statusCode: httpStatus,\n      timestamp: new Date().toISOString(),\n      path: httpAdapter.getRequestUrl(ctx.getRequest()),\n    };\n\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Catch, ArgumentsHost } from '@nestjs/common';\nimport { BaseExceptionFilter } from '@nestjs/core';\n\n@Catch()\nexport class AllExceptionsFilter extends BaseExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    super.catch(exception, host);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Catch } from '@nestjs/common';\nimport { BaseExceptionFilter } from '@nestjs/core';\n\n@Catch()\nexport class AllExceptionsFilter extends BaseExceptionFilter {\n  catch(exception, host) {\n    super.catch(exception, host);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "async function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const { httpAdapter } = app.get(HttpAdapterHost);\n  app.useGlobalFilters(new AllExceptionsFilter(httpAdapter));\n\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();",
      "language": "typescript"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}