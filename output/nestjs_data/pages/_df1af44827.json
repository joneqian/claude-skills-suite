{
  "url": "https://docs.nestjs.com/microservices/basics",
  "title": "",
  "content": "In addition to traditional (sometimes called monolithic) application architectures, Nest natively supports the microservice architectural style of development. Most of the concepts discussed elsewhere in this documentation, such as dependency injection, decorators, exception filters, pipes, guards and interceptors, apply equally to microservices. Wherever possible, Nest abstracts implementation details so that the same components can run across HTTP-based platforms, WebSockets, and Microservices. This section covers the aspects of Nest that are specific to microservices.\n\nIn Nest, a microservice is fundamentally an application that uses a different transport layer than HTTP.\n\nNest supports several built-in transport layer implementations, called transporters, which are responsible for transmitting messages between different microservice instances. Most transporters natively support both request-response and event-based message styles. Nest abstracts the implementation details of each transporter behind a canonical interface for both request-response and event-based messaging. This makes it easy to switch from one transport layer to another -- for example to leverage the specific reliability or performance features of a particular transport layer -- without impacting your application code.\n\nTo start building microservices, first install the required package:\n\nTo instantiate a microservice, use the createMicroservice() method of the NestFactory class:\n\nThe second argument of the createMicroservice() method is an options object. This object may consist of two members:\n\nThe options object is specific to the chosen transporter. The TCP transporter exposes the properties described below. For other transporters (e.g, Redis, MQTT, etc.), see the relevant chapter for a description of the available options.\n\nMicroservices recognize both messages and events by patterns. A pattern is a plain value, for example, a literal object or a string. Patterns are automatically serialized and sent over the network along with the data portion of a message. In this way, message senders and consumers can coordinate which requests are consumed by which handlers.\n\nThe request-response message style is useful when you need to exchange messages between various external services. This paradigm ensures that the service has actually received the message (without requiring you to manually implement an acknowledgment protocol). However, the request-response approach may not always be the best fit. For example, streaming transporters, such as Kafka or NATS streaming, which use log-based persistence, are optimized for addressing a different set of challenges, more aligned with the event messaging paradigm (see event-based messaging for more details).\n\nTo enable the request-response message type, Nest creates two logical channels: one for transferring data and another for waiting for incoming responses. For some underlying transports, like NATS, this dual-channel support is provided out-of-the-box. For others, Nest compensates by manually creating separate channels. While this is effective, it can introduce some overhead. Therefore, if you don’t require a request-response message style, you may want to consider using the event-based method.\n\nTo create a message handler based on the request-response paradigm, use the @MessagePattern() decorator, which is imported from the @nestjs/microservices package. This decorator should only be used within controller classes, as they serve as the entry points for your application. Using it in providers will have no effect, as they will be ignored by the Nest runtime.\n\nIn the above code, the accumulate()message handler listens for messages that match the { cmd: 'sum' } message pattern. The message handler takes a single argument, the data passed from the client. In this case, the data is an array of numbers that need to be accumulated.\n\nMessage handlers can respond either synchronously or asynchronously, meaning that async methods are supported.\n\nA message handler can also return an Observable, in which case the result values will be emitted until the stream completes.\n\nIn the example above, the message handler will respond three times, once for each item in the array.\n\nWhile the request-response method is perfect for exchanging messages between services, it is less suited for event-based messaging—when you simply want to publish events without waiting for a response. In such cases, the overhead of maintaining two channels for request-response is unnecessary.\n\nFor example, if you want to notify another service that a specific condition has occurred in this part of the system, the event-based message style is ideal.\n\nTo create an event handler, you can use the @EventPattern() decorator, which is imported from the @nestjs/microservices package.\n\nThe handleUserCreated()event handler listens for the 'user_created' event. The event handler takes a single argument, the data passed from the client (in this case, an event payload which has been sent over the network).\n\nOfficial enterprise support Providing technical guidance Performing in-depth code reviews Mentoring team members Advising best practices Explore more\n\nIn more advanced scenarios, you might need to access additional details about the incoming request. For instance, when using NATS with wildcard subscriptions, you may want to retrieve the original subject that the producer sent the message to. Similarly, with Kafka, you may need to access the message headers. To achieve this, you can leverage built-in decorators as shown below:\n\nA client Nest application can exchange messages or publish events to a Nest microservice using the ClientProxy class. This class provides several methods, such as send() (for request-response messaging) and emit() (for event-driven messaging), enabling communication with a remote microservice. You can obtain an instance of this class in the following ways:\n\nOne approach is to import the ClientsModule, which exposes the static register() method. This method takes an array of objects representing microservice transporters. Each object must include a name property, and optionally a transport property (defaulting to Transport.TCP), as well as an optional options property.\n\nThe name property acts as an injection token, which you can use to inject an instance of ClientProxy wherever needed. The value of this name property can be any arbitrary string or JavaScript symbol, as described here.\n\nThe options property is an object that includes the same properties we saw in the createMicroservice() method earlier.\n\nAlternatively, you can use the registerAsync() method if you need to provide configuration or perform any other asynchronous processes during the setup.\n\nOnce the module has been imported, you can inject an instance of the ClientProxy configured with the specified options for the 'MATH_SERVICE' transporter using the @Inject() decorator.\n\nAt times, you may need to fetch the transporter configuration from another service (such as a ConfigService), rather than hard-coding it in your client application. To achieve this, you can register a custom provider using the ClientProxyFactory class. This class provides a static create() method that accepts a transporter options object and returns a customized ClientProxy instance.\n\nAnother option is to use the @Client() property decorator.\n\nUsing the @Client() decorator is not the preferred technique, as it is harder to test and harder to share a client instance.\n\nThe ClientProxy is lazy. It doesn't initiate a connection immediately. Instead, it will be established before the first microservice call, and then reused across each subsequent call. However, if you want to delay the application bootstrapping process until a connection is established, you can manually initiate a connection using the ClientProxy object's connect() method inside the OnApplicationBootstrap lifecycle hook.\n\nIf the connection cannot be created, the connect() method will reject with the corresponding error object.\n\nThe ClientProxy exposes a send() method. This method is intended to call the microservice and returns an Observable with its response. Thus, we can subscribe to the emitted values easily.\n\nThe send() method takes two arguments, pattern and payload. The pattern should match one defined in a @MessagePattern() decorator. The payload is a message that we want to transmit to the remote microservice. This method returns a cold Observable, which means that you have to explicitly subscribe to it before the message will be sent.\n\nTo send an event, use the ClientProxy object's emit() method. This method publishes an event to the message broker.\n\nThe emit() method takes two arguments: pattern and payload. The pattern should match one defined in an @EventPattern() decorator, while the payload represents the event data that you want to transmit to the remote microservice. This method returns a hot Observable (in contrast to the cold Observable returned by send()), meaning that regardless of whether you explicitly subscribe to the observable, the proxy will immediately attempt to deliver the event.\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nFor those coming from different programming language backgrounds, it may be surprising to learn that in Nest, most things are shared across incoming requests. This includes a connection pool to the database, singleton services with global state, and more. Keep in mind that Node.js does not follow the request/response multi-threaded stateless model, where each request is processed by a separate thread. As a result, using singleton instances is safe for our applications.\n\nHowever, there are edge cases where a request-based lifetime for the handler might be desirable. This could include scenarios like per-request caching in GraphQL applications, request tracking, or multi-tenancy. You can learn more about how to control scopes here.\n\nRequest-scoped handlers and providers can inject RequestContext using the @Inject() decorator in combination with the CONTEXT token:\n\nThis provides access to the RequestContext object, which has two properties:\n\nThe data property is the message payload sent by the message producer. The pattern property is the pattern used to identify an appropriate handler to handle the incoming message.\n\nTo get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the status stream. This stream provides status updates specific to the chosen driver. For instance, if you’re using the TCP transporter (the default), the status stream emits connected and disconnected events.\n\nSimilarly, you can subscribe to the server's status stream to receive notifications about the server's status.\n\nIn some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the error event to trigger additional operations when an error occurs. To do this, use the on() method, as shown below:\n\nSimilarly, you can listen to the server's internal events:\n\nFor more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you shouldn't need to access the driver directly.\n\nTo do so, you can use the unwrap() method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.\n\nHere, Server is a type imported from the net module.\n\nSimilarly, you can access the server's underlying driver instance:\n\nIn distributed systems, microservices might sometimes be down or unavailable. To prevent indefinitely long waiting, you can use timeouts. A timeout is a highly useful pattern when communicating with other services. To apply timeouts to your microservice calls, you can use the RxJStimeout operator. If the microservice does not respond within the specified time, an exception is thrown, which you can catch and handle appropriately.\n\nTo implement this, you'll need to use the rxjs package. Simply use the timeout operator within the pipe:\n\nAfter 5 seconds, if the microservice isn't responding, it will throw an error.\n\nWhen communicating outside of a private network, it’s important to encrypt traffic to ensure security. In NestJS, this can be achieved with TLS over TCP using Node's built-in TLS module. Nest provides built-in support for TLS in its TCP transport, allowing us to encrypt communication between microservices or clients.\n\nTo enable TLS for a TCP server, you'll need both a private key and a certificate in PEM format. These are added to the server's options by setting the tlsOptions and specifying the key and cert files, as shown below:\n\nFor a client to communicate securely over TLS, we also define the tlsOptions object but this time with the CA certificate. This is the certificate of the authority that signed the server's certificate. This ensures that the client trusts the server's certificate and can establish a secure connection.\n\nYou can also pass an array of CAs if your setup involves multiple trusted authorities.\n\nOnce everything is set up, you can inject the ClientProxy as usual using the @Inject() decorator to use the client in your services. This ensures encrypted communication across your NestJS microservices, with Node's TLS module handling the encryption details.\n\nFor more information, refer to Node’s TLS documentation.\n\nWhen a microservice needs to be configured using the ConfigService (from the @nestjs/config package), but the injection context is only available after the microservice instance is created, AsyncMicroserviceOptions offers a solution. This approach allows for dynamic configuration, ensuring smooth integration with the ConfigService.",
  "headings": [
    {
      "level": "h3",
      "text": "Overview",
      "id": "overview"
    },
    {
      "level": "h4",
      "text": "Installation#",
      "id": "installation"
    },
    {
      "level": "h4",
      "text": "Getting started#",
      "id": "getting-started"
    },
    {
      "level": "h4",
      "text": "Message and Event Patterns#",
      "id": "message-and-event-patterns"
    },
    {
      "level": "h4",
      "text": "Request-response#",
      "id": "request-response"
    },
    {
      "level": "h4",
      "text": "Asynchronous responses#",
      "id": "asynchronous-responses"
    },
    {
      "level": "h4",
      "text": "Event-based#",
      "id": "event-based"
    },
    {
      "level": "h2",
      "text": "Official enterprise support",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Additional request details#",
      "id": "additional-request-details"
    },
    {
      "level": "h4",
      "text": "Client (producer class)#",
      "id": "client-producer-class"
    },
    {
      "level": "h4",
      "text": "Sending messages#",
      "id": "sending-messages"
    },
    {
      "level": "h4",
      "text": "Publishing events#",
      "id": "publishing-events"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Request-scoping#",
      "id": "request-scoping"
    },
    {
      "level": "h4",
      "text": "Instance status updates#",
      "id": "instance-status-updates"
    },
    {
      "level": "h4",
      "text": "Listening to internal events#",
      "id": "listening-to-internal-events"
    },
    {
      "level": "h4",
      "text": "Underlying driver access#",
      "id": "underlying-driver-access"
    },
    {
      "level": "h4",
      "text": "Handling timeouts#",
      "id": "handling-timeouts"
    },
    {
      "level": "h4",
      "text": "TLS support#",
      "id": "tls-support"
    },
    {
      "level": "h4",
      "text": "Dynamic configuration#",
      "id": "dynamic-configuration"
    }
  ],
  "code_samples": [
    {
      "code": "$ npm i --save @nestjs/microservices",
      "language": "bash"
    },
    {
      "code": "import { NestFactory } from '@nestjs/core';\nimport { Transport, MicroserviceOptions } from '@nestjs/microservices';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n    AppModule,\n    {\n      transport: Transport.TCP,\n    },\n  );\n  await app.listen();\n}\nbootstrap();",
      "language": "typescript"
    },
    {
      "code": "import { NestFactory } from '@nestjs/core';\nimport { Transport } from '@nestjs/microservices';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice(AppModule, {\n    transport: Transport.TCP,\n  });\n  await app.listen();\n}\nbootstrap();",
      "language": "typescript"
    },
    {
      "code": "import { Controller } from '@nestjs/common';\nimport { MessagePattern } from '@nestjs/microservices';\n\n@Controller()\nexport class MathController {\n  @MessagePattern({ cmd: 'sum' })\n  accumulate(data: number[]): number {\n    return (data || []).reduce((a, b) => a + b);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller } from '@nestjs/common';\nimport { MessagePattern } from '@nestjs/microservices';\n\n@Controller()\nexport class MathController {\n  @MessagePattern({ cmd: 'sum' })\n  accumulate(data) {\n    return (data || []).reduce((a, b) => a + b);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern({ cmd: 'sum' })\nasync accumulate(data: number[]): Promise<number> {\n  return (data || []).reduce((a, b) => a + b);\n}",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern({ cmd: 'sum' })\nasync accumulate(data) {\n  return (data || []).reduce((a, b) => a + b);\n}",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern({ cmd: 'sum' })\naccumulate(data: number[]): Observable<number> {\n  return from([1, 2, 3]);\n}",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern({ cmd: 'sum' })\naccumulate(data: number[]): Observable<number> {\n  return from([1, 2, 3]);\n}",
      "language": "typescript"
    },
    {
      "code": "@EventPattern('user_created')\nasync handleUserCreated(data: Record<string, unknown>) {\n  // business logic\n}",
      "language": "typescript"
    },
    {
      "code": "@EventPattern('user_created')\nasync handleUserCreated(data) {\n  // business logic\n}",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern('time.us.*')\ngetDate(@Payload() data: number[], @Ctx() context: NatsContext) {\n  console.log(`Subject: ${context.getSubject()}`); // e.g. \"time.us.east\"\n  return new Date().toLocaleTimeString(...);\n}",
      "language": "typescript"
    },
    {
      "code": "@Bind(Payload(), Ctx())\n@MessagePattern('time.us.*')\ngetDate(data, context) {\n  console.log(`Subject: ${context.getSubject()}`); // e.g. \"time.us.east\"\n  return new Date().toLocaleTimeString(...);\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ClientsModule.register([\n      { name: 'MATH_SERVICE', transport: Transport.TCP },\n    ]),\n  ],\n})",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ClientsModule.registerAsync([\n      {\n        imports: [ConfigModule],\n        name: 'MATH_SERVICE',\n        useFactory: async (configService: ConfigService) => ({\n          transport: Transport.TCP,\n          options: {\n            url: configService.get('URL'),\n          },\n        }),\n        inject: [ConfigService],\n      },\n    ]),\n  ],\n})",
      "language": "typescript"
    },
    {
      "code": "constructor(\n  @Inject('MATH_SERVICE') private client: ClientProxy,\n) {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  providers: [\n    {\n      provide: 'MATH_SERVICE',\n      useFactory: (configService: ConfigService) => {\n        const mathSvcOptions = configService.getMathSvcOptions();\n        return ClientProxyFactory.create(mathSvcOptions);\n      },\n      inject: [ConfigService],\n    }\n  ]\n  ...\n})",
      "language": "typescript"
    },
    {
      "code": "@Client({ transport: Transport.TCP })\nclient: ClientProxy;",
      "language": "typescript"
    },
    {
      "code": "async onApplicationBootstrap() {\n  await this.client.connect();\n}",
      "language": "typescript"
    },
    {
      "code": "accumulate(): Observable<number> {\n  const pattern = { cmd: 'sum' };\n  const payload = [1, 2, 3];\n  return this.client.send<number>(pattern, payload);\n}",
      "language": "typescript"
    },
    {
      "code": "accumulate() {\n  const pattern = { cmd: 'sum' };\n  const payload = [1, 2, 3];\n  return this.client.send(pattern, payload);\n}",
      "language": "typescript"
    },
    {
      "code": "async publish() {\n  this.client.emit<number>('user_created', new UserCreatedEvent());\n}",
      "language": "typescript"
    },
    {
      "code": "async publish() {\n  this.client.emit('user_created', new UserCreatedEvent());\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, Scope, Inject } from '@nestjs/common';\nimport { CONTEXT, RequestContext } from '@nestjs/microservices';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class CatsService {\n  constructor(@Inject(CONTEXT) private ctx: RequestContext) {}\n}",
      "language": "typescript"
    },
    {
      "code": "export interface RequestContext<T = any> {\n  pattern: string | Record<string, any>;\n  data: T;\n}",
      "language": "typescript"
    },
    {
      "code": "this.client.status.subscribe((status: TcpStatus) => {\n  console.log(status);\n});",
      "language": "typescript"
    },
    {
      "code": "const server = app.connectMicroservice<MicroserviceOptions>(...);\nserver.status.subscribe((status: TcpStatus) => {\n  console.log(status);\n});",
      "language": "typescript"
    },
    {
      "code": "this.client.on('error', (err) => {\n  console.error(err);\n});",
      "language": "typescript"
    },
    {
      "code": "server.on<TcpEvents>('error', (err) => {\n  console.error(err);\n});",
      "language": "typescript"
    },
    {
      "code": "const netServer = this.client.unwrap<Server>();",
      "language": "typescript"
    },
    {
      "code": "const netServer = server.unwrap<Server>();",
      "language": "typescript"
    },
    {
      "code": "this.client\n  .send<TResult, TInput>(pattern, data)\n  .pipe(timeout(5000));",
      "language": "typescript"
    },
    {
      "code": "this.client\n  .send(pattern, data)\n  .pipe(timeout(5000));",
      "language": "typescript"
    },
    {
      "code": "import * as fs from 'fs';\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { MicroserviceOptions, Transport } from '@nestjs/microservices';\n\nasync function bootstrap() {\n  const key = fs.readFileSync('<pathToKeyFile>', 'utf8').toString();\n  const cert = fs.readFileSync('<pathToCertFile>', 'utf8').toString();\n\n  const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n    AppModule,\n    {\n      transport: Transport.TCP,\n      options: {\n        tlsOptions: {\n          key,\n          cert,\n        },\n      },\n    },\n  );\n\n  await app.listen();\n}\nbootstrap();",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { ClientsModule, Transport } from '@nestjs/microservices';\n\n@Module({\n  imports: [\n    ClientsModule.register([\n      {\n        name: 'MATH_SERVICE',\n        transport: Transport.TCP,\n        options: {\n          tlsOptions: {\n            ca: [fs.readFileSync('<pathToCaFile>', 'utf-8').toString()],\n          },\n        },\n      },\n    ]),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { ConfigService } from '@nestjs/config';\nimport { AsyncMicroserviceOptions, Transport } from '@nestjs/microservices';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice<AsyncMicroserviceOptions>(\n    AppModule,\n    {\n      useFactory: (configService: ConfigService) => ({\n        transport: Transport.TCP,\n        options: {\n          host: configService.get<string>('HOST'),\n          port: configService.get<number>('PORT'),\n        },\n      }),\n      inject: [ConfigService],\n    },\n  );\n\n  await app.listen();\n}\nbootstrap();",
      "language": "typescript"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}