{
  "url": "https://docs.nestjs.com/fundamentals/dynamic-modules",
  "title": "",
  "content": "The Modules chapter covers the basics of Nest modules, and includes a brief introduction to dynamic modules. This chapter expands on the subject of dynamic modules. Upon completion, you should have a good grasp of what they are and how and when to use them.\n\nMost application code examples in the Overview section of the documentation make use of regular, or static, modules. Modules define groups of components like providers and controllers that fit together as a modular part of an overall application. They provide an execution context, or scope, for these components. For example, providers defined in a module are visible to other members of the module without the need to export them. When a provider needs to be visible outside of a module, it is first exported from its host module, and then imported into its consuming module.\n\nLet's walk through a familiar example.\n\nFirst, we'll define a UsersModule to provide and export a UsersService. UsersModule is the host module for UsersService.\n\nNext, we'll define an AuthModule, which imports UsersModule, making UsersModule's exported providers available inside AuthModule:\n\nThese constructs allow us to inject UsersService in, for example, the AuthService that is hosted in AuthModule:\n\nWe'll refer to this as static module binding. All the information Nest needs to wire together the modules has already been declared in the host and consuming modules. Let's unpack what's happening during this process. Nest makes UsersService available inside AuthModule by:\n\nWith static module binding, there's no opportunity for the consuming module to influence how providers from the host module are configured. Why does this matter? Consider the case where we have a general purpose module that needs to behave differently in different use cases. This is analogous to the concept of a \"plugin\" in many systems, where a generic facility requires some configuration before it can be used by a consumer.\n\nA good example with Nest is a configuration module. Many applications find it useful to externalize configuration details by using a configuration module. This makes it easy to dynamically change the application settings in different deployments: e.g., a development database for developers, a staging database for the staging/testing environment, etc. By delegating the management of configuration parameters to a configuration module, the application source code remains independent of configuration parameters.\n\nThe challenge is that the configuration module itself, since it's generic (similar to a \"plugin\"), needs to be customized by its consuming module. This is where dynamic modules come into play. Using dynamic module features, we can make our configuration module dynamic so that the consuming module can use an API to control how the configuration module is customized at the time it is imported.\n\nIn other words, dynamic modules provide an API for importing one module into another, and customizing the properties and behavior of that module when it is imported, as opposed to using the static bindings we've seen so far.\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nWe'll be using the basic version of the example code from the configuration chapter for this section. The completed version as of the end of this chapter is available as a working example here.\n\nOur requirement is to make ConfigModule accept an options object to customize it. Here's the feature we want to support. The basic sample hard-codes the location of the .env file to be in the project root folder. Let's suppose we want to make that configurable, such that you can manage your .env files in any folder of your choosing. For example, imagine you want to store your various .env files in a folder under the project root called config (i.e., a sibling folder to src). You'd like to be able to choose different folders when using the ConfigModule in different projects.\n\nDynamic modules give us the ability to pass parameters into the module being imported so we can change its behavior. Let's see how this works. It's helpful if we start from the end-goal of how this might look from the consuming module's perspective, and then work backwards. First, let's quickly review the example of statically importing the ConfigModule (i.e., an approach which has no ability to influence the behavior of the imported module). Pay close attention to the imports array in the @Module() decorator:\n\nLet's consider what a dynamic module import, where we're passing in a configuration object, might look like. Compare the difference in the imports array between these two examples:\n\nLet's see what's happening in the dynamic example above. What are the moving parts?\n\nIn fact, what our register() method will return is a DynamicModule. A dynamic module is nothing more than a module created at run-time, with the same exact properties as a static module, plus one additional property called module. Let's quickly review a sample static module declaration, paying close attention to the module options passed in to the decorator:\n\nDynamic modules must return an object with the exact same interface, plus one additional property called module. The module property serves as the name of the module, and should be the same as the class name of the module, as shown in the example below.\n\nWhat about the static register() method? We can now see that its job is to return an object that has the DynamicModule interface. When we call it, we are effectively providing a module to the imports list, similar to the way we would do so in the static case by listing a module class name. In other words, the dynamic module API simply returns a module, but rather than fix the properties in the @Module decorator, we specify them programmatically.\n\nThere are still a couple of details to cover to help make the picture complete:\n\nArmed with this understanding, we can now look at what our dynamic ConfigModule declaration must look like. Let's take a crack at it.\n\nIt should now be clear how the pieces tie together. Calling ConfigModule.register(...) returns a DynamicModule object with properties which are essentially the same as those that, until now, we've provided as metadata via the @Module() decorator.\n\nOur dynamic module isn't very interesting yet, however, as we haven't introduced any capability to configure it as we said we would like to do. Let's address that next.\n\nThe obvious solution for customizing the behavior of the ConfigModule is to pass it an options object in the static register() method, as we guessed above. Let's look once again at our consuming module's imports property:\n\nThat nicely handles passing an options object to our dynamic module. How do we then use that options object in the ConfigModule? Let's consider that for a minute. We know that our ConfigModule is basically a host for providing and exporting an injectable service - the ConfigService - for use by other providers. It's actually our ConfigService that needs to read the options object to customize its behavior. Let's assume for the moment that we know how to somehow get the options from the register() method into the ConfigService. With that assumption, we can make a few changes to the service to customize its behavior based on the properties from the options object. (Note: for the time being, since we haven't actually determined how to pass it in, we'll just hard-code options. We'll fix this in a minute).\n\nNow our ConfigService knows how to find the .env file in the folder we've specified in options.\n\nOur remaining task is to somehow inject the options object from the register() step into our ConfigService. And of course, we'll use dependency injection to do it. This is a key point, so make sure you understand it. Our ConfigModule is providing ConfigService. ConfigService in turn depends on the options object that is only supplied at run-time. So, at run-time, we'll need to first bind the options object to the Nest IoC container, and then have Nest inject it into our ConfigService. Remember from the Custom providers chapter that providers can include any value not just services, so we're fine using dependency injection to handle a simple options object.\n\nLet's tackle binding the options object to the IoC container first. We do this in our static register() method. Remember that we are dynamically constructing a module, and one of the properties of a module is its list of providers. So what we need to do is define our options object as a provider. This will make it injectable into the ConfigService, which we'll take advantage of in the next step. In the code below, pay attention to the providers array:\n\nNow we can complete the process by injecting the 'CONFIG_OPTIONS' provider into the ConfigService. Recall that when we define a provider using a non-class token we need to use the @Inject() decorator as described here.\n\nOne final note: for simplicity we used a string-based injection token ('CONFIG_OPTIONS') above, but best practice is to define it as a constant (or Symbol) in a separate file, and import that file. For example:\n\nA full example of the code in this chapter can be found here.\n\nYou may have seen the use for methods like forRoot, register, and forFeature around some of the @nestjs/ packages and may be wondering what the difference for all of these methods are. There is no hard rule about this, but the @nestjs/ packages try to follow these guidelines:\n\nWhen creating a module with:\n\nregister, you are expecting to configure a dynamic module with a specific configuration for use only by the calling module. For example, with Nest's @nestjs/axios: HttpModule.register({ baseUrl: 'someUrl' }). If, in another module you use HttpModule.register({ baseUrl: 'somewhere else' }), it will have the different configuration. You can do this for as many modules as you want.\n\nforRoot, you are expecting to configure a dynamic module once and reuse that configuration in multiple places (though possibly unknowingly as it's abstracted away). This is why you have one GraphQLModule.forRoot(), one TypeOrmModule.forRoot(), etc.\n\nforFeature, you are expecting to use the configuration of a dynamic module's forRoot but need to modify some configuration specific to the calling module's needs (i.e. which repository this module should have access to, or the context that a logger should use.)\n\nAll of these, usually, have their async counterparts as well, registerAsync, forRootAsync, and forFeatureAsync, that mean the same thing, but use Nest's Dependency Injection for the configuration as well.\n\nAs manually creating highly configurable, dynamic modules that expose async methods (registerAsync, forRootAsync, etc.) is quite complicated, especially for newcomers, Nest exposes the ConfigurableModuleBuilder class that facilitates this process and lets you construct a module \"blueprint\" in just a few lines of code.\n\nFor example, let's take the example we used above (ConfigModule) and convert it to use the ConfigurableModuleBuilder. Before we start, let's make sure we create a dedicated interface that represents what options our ConfigModule takes in.\n\nWith this in place, create a new dedicated file (alongside the existing config.module.ts file) and name it config.module-definition.ts. In this file, let's utilize the ConfigurableModuleBuilder to construct ConfigModule definition.\n\nNow let's open up the config.module.ts file and modify its implementation to leverage the auto-generated ConfigurableModuleClass:\n\nExtending the ConfigurableModuleClass means that ConfigModule provides now not only the register method (as previously with the custom implementation), but also the registerAsync method which allows consumers asynchronously configure that module, for example, by supplying async factories:\n\nThe registerAsync method takes the following object as an argument:\n\nLet's go through the above properties one by one:\n\nAlways choose one of the above options (useFactory, useClass, or useExisting), as they are mutually exclusive.\n\nLastly, let's update the ConfigService class to inject the generated module options' provider instead of the 'CONFIG_OPTIONS' that we used so far.\n\nConfigurableModuleClass by default provides the register and its counterpart registerAsync methods. To use a different method name, use the ConfigurableModuleBuilder#setClassMethodName method, as follows:\n\nThis construction will instruct ConfigurableModuleBuilder to generate a class that exposes forRoot and forRootAsync instead. Example:\n\nSince the registerAsync method (or forRootAsync or any other name, depending on the configuration) lets consumer pass a provider definition that resolves to the module configuration, a library consumer could potentially supply a class to be used to construct the configuration object.\n\nThis class, by default, must provide the create() method that returns a module configuration object. However, if your library follows a different naming convention, you can change that behavior and instruct ConfigurableModuleBuilder to expect a different method, for example, createConfigOptions, using the ConfigurableModuleBuilder#setFactoryMethodName method:\n\nNow, ConfigModuleOptionsFactory class must expose the createConfigOptions method (instead of create):\n\nThere are edge-cases when your module may need to take extra options that determine how it is supposed to behave (a nice example of such an option is the isGlobal flag - or just global) that at the same time, shouldn't be included in the MODULE_OPTIONS_TOKEN provider (as they are irrelevant to services/providers registered within that module, for example, ConfigService does not need to know whether its host module is registered as a global module).\n\nIn such cases, the ConfigurableModuleBuilder#setExtras method can be used. See the following example:\n\nIn the example above, the first argument passed into the setExtras method is an object containing default values for the \"extra\" properties. The second argument is a function that takes an auto-generated module definitions (with provider, exports, etc.) and extras object which represents extra properties (either specified by the consumer or defaults). The returned value of this function is a modified module definition. In this specific example, we're taking the extras.isGlobal property and assigning it to the global property of the module definition (which in turn determines whether a module is global or not, read more here).\n\nNow when consuming this module, the additional isGlobal flag can be passed in, as follows:\n\nHowever, since isGlobal is declared as an \"extra\" property, it won't be available in the MODULE_OPTIONS_TOKEN provider:\n\nThe auto-generated static methods (register, registerAsync, etc.) can be extended if needed, as follows:\n\nNote the use of OPTIONS_TYPE and ASYNC_OPTIONS_TYPE types that must be exported from the module definition file:",
  "headings": [
    {
      "level": "h3",
      "text": "Dynamic modules",
      "id": "dynamic-modules"
    },
    {
      "level": "h4",
      "text": "Introduction#",
      "id": "introduction"
    },
    {
      "level": "h4",
      "text": "Dynamic module use case#",
      "id": "dynamic-module-use-case"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Config module example#",
      "id": "config-module-example"
    },
    {
      "level": "h4",
      "text": "Module configuration#",
      "id": "module-configuration"
    },
    {
      "level": "h4",
      "text": "Example#",
      "id": "example"
    },
    {
      "level": "h4",
      "text": "Community guidelines#",
      "id": "community-guidelines"
    },
    {
      "level": "h4",
      "text": "Configurable module builder#",
      "id": "configurable-module-builder"
    },
    {
      "level": "h4",
      "text": "Custom method key#",
      "id": "custom-method-key"
    },
    {
      "level": "h4",
      "text": "Custom options factory class#",
      "id": "custom-options-factory-class"
    },
    {
      "level": "h4",
      "text": "Extra options#",
      "id": "extra-options"
    },
    {
      "level": "h4",
      "text": "Extending auto-generated methods#",
      "id": "extending-auto-generated-methods"
    }
  ],
  "code_samples": [
    {
      "code": "import { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n  exports: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService) {}\n  /*\n    Implementation that makes use of this.usersService\n  */\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule.register({ folder: './config' })],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [DogsModule],\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService]\n})",
      "language": "typescript"
    },
    {
      "code": "import { DynamicModule, Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\n\n@Module({})\nexport class ConfigModule {\n  static register(): DynamicModule {\n    return {\n      module: ConfigModule,\n      providers: [ConfigService],\n      exports: [ConfigService],\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule.register({ folder: './config' })],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as dotenv from 'dotenv';\nimport { EnvConfig } from './interfaces';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: EnvConfig;\n\n  constructor() {\n    const options = { folder: './config' };\n\n    const filePath = `${process.env.NODE_ENV || 'development'}.env`;\n    const envFile = path.resolve(__dirname, '../../', options.folder, filePath);\n    this.envConfig = dotenv.parse(fs.readFileSync(envFile));\n  }\n\n  get(key: string): string {\n    return this.envConfig[key];\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { DynamicModule, Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\n\n@Module({})\nexport class ConfigModule {\n  static register(options: Record<string, any>): DynamicModule {\n    return {\n      module: ConfigModule,\n      providers: [\n        {\n          provide: 'CONFIG_OPTIONS',\n          useValue: options,\n        },\n        ConfigService,\n      ],\n      exports: [ConfigService],\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as dotenv from 'dotenv';\nimport { Injectable, Inject } from '@nestjs/common';\nimport { EnvConfig } from './interfaces';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: EnvConfig;\n\n  constructor(@Inject('CONFIG_OPTIONS') private options: Record<string, any>) {\n    const filePath = `${process.env.NODE_ENV || 'development'}.env`;\n    const envFile = path.resolve(__dirname, '../../', options.folder, filePath);\n    this.envConfig = dotenv.parse(fs.readFileSync(envFile));\n  }\n\n  get(key: string): string {\n    return this.envConfig[key];\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export const CONFIG_OPTIONS = 'CONFIG_OPTIONS';",
      "language": "typescript"
    },
    {
      "code": "export interface ConfigModuleOptions {\n  folder: string;\n}",
      "language": "typescript"
    },
    {
      "code": "import { ConfigurableModuleBuilder } from '@nestjs/common';\nimport { ConfigModuleOptions } from './interfaces/config-module-options.interface';\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().build();",
      "language": "typescript"
    },
    {
      "code": "import { ConfigurableModuleBuilder } from '@nestjs/common';\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().build();",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\nimport { ConfigurableModuleClass } from './config.module-definition';\n\n@Module({\n  providers: [ConfigService],\n  exports: [ConfigService],\n})\nexport class ConfigModule extends ConfigurableModuleClass {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.register({ folder: './config' }),\n    // or alternatively:\n    // ConfigModule.registerAsync({\n    //   useFactory: () => {\n    //     return {\n    //       folder: './config',\n    //     }\n    //   },\n    //   inject: [...any extra dependencies...]\n    // }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "{\n  /**\n   * Injection token resolving to a class that will be instantiated as a provider.\n   * The class must implement the corresponding interface.\n   */\n  useClass?: Type<\n    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>\n  >;\n  /**\n   * Function returning options (or a Promise resolving to options) to configure the\n   * module.\n   */\n  useFactory?: (...args: any[]) => Promise<ModuleOptions> | ModuleOptions;\n  /**\n   * Dependencies that a Factory may inject.\n   */\n  inject?: FactoryProvider['inject'];\n  /**\n   * Injection token resolving to an existing provider. The provider must implement\n   * the corresponding interface.\n   */\n  useExisting?: Type<\n    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>\n  >;\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class ConfigService {\n  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) { ... }\n}",
      "language": "typescript"
    },
    {
      "code": "export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().setClassMethodName('forRoot').build();",
      "language": "typescript"
    },
    {
      "code": "export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().setClassMethodName('forRoot').build();",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.forRoot({ folder: './config' }), // <-- note the use of \"forRoot\" instead of \"register\"\n    // or alternatively:\n    // ConfigModule.forRootAsync({\n    //   useFactory: () => {\n    //     return {\n    //       folder: './config',\n    //     }\n    //   },\n    //   inject: [...any extra dependencies...]\n    // }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.registerAsync({\n      useClass: ConfigModuleOptionsFactory,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().setFactoryMethodName('createConfigOptions').build();",
      "language": "typescript"
    },
    {
      "code": "export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().setFactoryMethodName('createConfigOptions').build();",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.registerAsync({\n      useClass: ConfigModuleOptionsFactory, // <-- this class must provide the \"createConfigOptions\" method\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>()\n    .setExtras(\n      {\n        isGlobal: true,\n      },\n      (definition, extras) => ({\n        ...definition,\n        global: extras.isGlobal,\n      }),\n    )\n    .build();",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.register({\n      isGlobal: true,\n      folder: './config',\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class ConfigService {\n  constructor(\n    @Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions,\n  ) {\n    // \"options\" object will not have the \"isGlobal\" property\n    // ...\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\nimport {\n  ConfigurableModuleClass,\n  ASYNC_OPTIONS_TYPE,\n  OPTIONS_TYPE,\n} from './config.module-definition';\n\n@Module({\n  providers: [ConfigService],\n  exports: [ConfigService],\n})\nexport class ConfigModule extends ConfigurableModuleClass {\n  static register(options: typeof OPTIONS_TYPE): DynamicModule {\n    return {\n      // your custom logic here\n      ...super.register(options),\n    };\n  }\n\n  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {\n    return {\n      // your custom logic here\n      ...super.registerAsync(options),\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export const {\n  ConfigurableModuleClass,\n  MODULE_OPTIONS_TOKEN,\n  OPTIONS_TYPE,\n  ASYNC_OPTIONS_TYPE,\n} = new ConfigurableModuleBuilder<ConfigModuleOptions>().build();",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "One final note: for simplicity we used a string-based injection token ('CONFIG_OPTIONS') above, but best practice is to define it as a constant (or Symbol) in a separate file, and import that file. For example:",
      "code": "'CONFIG_OPTIONS'"
    },
    {
      "description": "This construction will instruct ConfigurableModuleBuilder to generate a class that exposes forRoot and forRootAsync instead. Example:",
      "code": "ConfigurableModuleBuilder"
    },
    {
      "description": "In such cases, the ConfigurableModuleBuilder#setExtras method can be used. See the following example:",
      "code": "ConfigurableModuleBuilder#setExtras"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}