{
  "url": "https://fastapi.tiangolo.com/deployment/concepts/",
  "title": "Deployments Concepts¬∂",
  "content": "When deploying a FastAPI application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the most appropriate way to deploy your application.\n\nSome of the important concepts are:\n\nWe'll see how they would affect deployments.\n\nIn the end, the ultimate objective is to be able to serve your API clients in a way that is secure, to avoid disruptions, and to use the compute resources (for example remote servers/virtual machines) as efficiently as possible. üöÄ\n\nI'll tell you a bit more about these concepts here, and that would hopefully give you the intuition you would need to decide how to deploy your API in very different environments, possibly even in future ones that don't exist yet.\n\nBy considering these concepts, you will be able to evaluate and design the best way to deploy your own APIs.\n\nIn the next chapters, I'll give you more concrete recipes to deploy FastAPI applications.\n\nBut for now, let's check these important conceptual ideas. These concepts also apply to any other type of web API. üí°\n\nIn the previous chapter about HTTPS we learned about how HTTPS provides encryption for your API.\n\nWe also saw that HTTPS is normally provided by a component external to your application server, a TLS Termination Proxy.\n\nAnd there has to be something in charge of renewing the HTTPS certificates, it could be the same component or it could be something different.\n\nSome of the tools you could use as a TLS Termination Proxy are:\n\nAnother option is that you could use a cloud service that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.\n\nI'll show you some concrete examples in the next chapters.\n\nThen the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).\n\nWe will talk a lot about the running \"process\", so it's useful to have clarity about what it means, and what's the difference with the word \"program\".\n\nThe word program is commonly used to describe many things:\n\nThe word process is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):\n\nIf you check out the \"task manager\" or \"system monitor\" (or similar tools) in your operating system, you will be able to see many of those processes running.\n\nAnd, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.\n\nNow that we know the difference between the terms process and program, let's continue talking about deployments.\n\nIn most cases, when you create a web API, you want it to be always running, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and available.\n\nWhen you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is use fastapi run (which uses Uvicorn) or something similar, manually, the same way you do when developing locally.\n\nAnd it will work and will be useful during development.\n\nBut if your connection to the server is lost, the running process will probably die.\n\nAnd if the server is restarted (for example after updates, or migrations from the cloud provider) you probably won't notice it. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. üò±\n\nIn general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any human intervention, to have a process always running with your API (e.g. Uvicorn running your FastAPI app).\n\nTo achieve this, you will normally have a separate program that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.\n\nSome examples of the tools that can do this job are:\n\nI'll give you more concrete examples in the next chapters.\n\nSimilar to making sure your application is run on startup, you probably also want to make sure it is restarted after failures.\n\nWe, as humans, make mistakes, all the time. Software almost always has bugs hidden in different places. üêõ\n\nAnd we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too üòÖ).\n\nWhen building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. üõ°\n\nThe client will get a 500 Internal Server Error for that request, but the application will continue working for the next requests instead of just crashing completely.\n\nNevertheless, there might be cases where we write some code that crashes the entire application making Uvicorn and Python crash. üí•\n\nAnd still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to continue running at least for the path operations that are not broken.\n\nBut in those cases with really bad errors that crash the running process, you would want an external component that is in charge of restarting the process, at least a couple of times...\n\n...Although if the whole application is just crashing immediately it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.\n\nSo let's focus on the main cases, where it could crash entirely in some particular cases in the future, and it still makes sense to restart it.\n\nYou would probably want to have the thing in charge of restarting your application as an external component, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.\n\nIn most cases, the same tool that is used to run the program on startup is also used to handle automatic restarts.\n\nFor example, this could be handled by:\n\nWith a FastAPI application, using a server program like the fastapi command that runs Uvicorn, running it once in one process can serve multiple clients concurrently.\n\nBut in many cases, you will want to run several worker processes at the same time.\n\nIf you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have multiple cores in the server's CPU, then you could have multiple processes running with the same application at the same time, and distribute all the requests among them.\n\nWhen you run multiple processes of the same API program, they are commonly called workers.\n\nRemember from the docs About HTTPS that only one process can be listening on one combination of port and IP address in a server?\n\nSo, to be able to have multiple processes at the same time, there has to be a single process listening on a port that then transmits the communication to each worker process in some way.\n\nNow, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that consumes a bit of the memory (RAM) of the server.\n\nAnd multiple processes normally don't share any memory. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code, each process will consume an equivalent amount of memory.\n\nFor example, if your code loads a Machine Learning model with 1 GB in size, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start 4 processes (4 workers), each will consume 1 GB of RAM. So in total, your API will consume 4 GB of RAM.\n\nAnd if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. üö®\n\nIn this example, there's a Manager Process that starts and controls two Worker Processes.\n\nThis Manager Process would probably be the one listening on the port in the IP. And it would transmit all the communication to the worker processes.\n\nThose worker processes would be the ones running your application, they would perform the main computations to receive a request and return a response, and they would load anything you put in variables in RAM.\n\nAnd of course, the same machine would probably have other processes running as well, apart from your application.\n\nAn interesting detail is that the percentage of the CPU used by each process can vary a lot over time, but the memory (RAM) normally stays more or less stable.\n\nIf you have an API that does a comparable amount of computations every time and you have a lot of clients, then the CPU utilization will probably also be stable (instead of constantly going up and down quickly).\n\nThere can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.\n\nThe main constraint to consider is that there has to be a single component handling the port in the public IP. And then it has to have a way to transmit the communication to the replicated processes/workers.\n\nHere are some possible combinations and strategies:\n\nDon't worry if some of these items about containers, Docker, or Kubernetes don't make a lot of sense yet.\n\nI'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter: FastAPI in Containers - Docker.\n\nThere are many cases where you want to perform some steps before starting your application.\n\nFor example, you might want to run database migrations.\n\nBut in most cases, you will want to perform these steps only once.\n\nSo, you will want to have a single process to perform those previous steps, before starting the application.\n\nAnd you will have to make sure that it's a single process running those previous steps even if afterwards, you start multiple processes (multiple workers) for the application itself. If those steps were run by multiple processes, they would duplicate the work by running it in parallel, and if the steps were something delicate like a database migration, they could cause conflicts with each other.\n\nOf course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.\n\nAlso, keep in mind that depending on your setup, in some cases you might not even need any previous steps before starting your application.\n\nIn that case, you wouldn't have to worry about any of this. ü§∑\n\nThis will depend heavily on the way you deploy your system, and it would probably be connected to the way you start programs, handling restarts, etc.\n\nHere are some possible ideas:\n\nI'll give you more concrete examples for doing this with containers in a future chapter: FastAPI in Containers - Docker.\n\nYour server(s) is (are) a resource, you can consume or utilize, with your programs, the computation time on the CPUs, and the RAM memory available.\n\nHow much of the system resources do you want to be consuming/utilizing? It might be easy to think \"not much\", but in reality, you will probably want to consume as much as possible without crashing.\n\nIf you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably wasting money üí∏, and probably wasting server electric power üåé, etc.\n\nIn that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).\n\nOn the other hand, if you have 2 servers and you are using 100% of their CPU and RAM, at some point one process will ask for more memory, and the server will have to use the disk as \"memory\" (which can be thousands of times slower), or even crash. Or one process might need to do some computation and would have to wait until the CPU is free again.\n\nIn this case, it would be better to get one extra server and run some processes on it so that they all have enough RAM and CPU time.\n\nThere's also the chance that for some reason you have a spike of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.\n\nYou could put an arbitrary number to target, for example, something between 50% to 90% of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.\n\nYou can use simple tools like htop to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.\n\nYou have been reading here some of the main concepts that you would probably need to keep in mind when deciding how to deploy your application:\n\nUnderstanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. ü§ì\n\nIn the next sections, I'll give you more concrete examples of possible strategies you can follow. üöÄ",
  "headings": [
    {
      "level": "h1",
      "text": "Deployments Concepts¬∂",
      "id": "deployments-concepts"
    },
    {
      "level": "h2",
      "text": "Security - HTTPS¬∂",
      "id": "security-https"
    },
    {
      "level": "h3",
      "text": "Example Tools for HTTPS¬∂",
      "id": "example-tools-for-https"
    },
    {
      "level": "h2",
      "text": "Program and Process¬∂",
      "id": "program-and-process"
    },
    {
      "level": "h3",
      "text": "What is a Program¬∂",
      "id": "what-is-a-program"
    },
    {
      "level": "h3",
      "text": "What is a Process¬∂",
      "id": "what-is-a-process"
    },
    {
      "level": "h2",
      "text": "Running on Startup¬∂",
      "id": "running-on-startup"
    },
    {
      "level": "h3",
      "text": "In a Remote Server¬∂",
      "id": "in-a-remote-server"
    },
    {
      "level": "h3",
      "text": "Run Automatically on Startup¬∂",
      "id": "run-automatically-on-startup"
    },
    {
      "level": "h3",
      "text": "Separate Program¬∂",
      "id": "separate-program"
    },
    {
      "level": "h3",
      "text": "Example Tools to Run at Startup¬∂",
      "id": "example-tools-to-run-at-startup"
    },
    {
      "level": "h2",
      "text": "Restarts¬∂",
      "id": "restarts"
    },
    {
      "level": "h3",
      "text": "We Make Mistakes¬∂",
      "id": "we-make-mistakes"
    },
    {
      "level": "h3",
      "text": "Small Errors Automatically Handled¬∂",
      "id": "small-errors-automatically-handled"
    },
    {
      "level": "h3",
      "text": "Bigger Errors - Crashes¬∂",
      "id": "bigger-errors-crashes"
    },
    {
      "level": "h3",
      "text": "Restart After Crash¬∂",
      "id": "restart-after-crash"
    },
    {
      "level": "h3",
      "text": "Example Tools to Restart Automatically¬∂",
      "id": "example-tools-to-restart-automatically"
    },
    {
      "level": "h2",
      "text": "Replication - Processes and Memory¬∂",
      "id": "replication-processes-and-memory"
    },
    {
      "level": "h3",
      "text": "Multiple Processes - Workers¬∂",
      "id": "multiple-processes-workers"
    },
    {
      "level": "h3",
      "text": "Worker Processes and Ports¬∂",
      "id": "worker-processes-and-ports"
    },
    {
      "level": "h3",
      "text": "Memory per Process¬∂",
      "id": "memory-per-process"
    },
    {
      "level": "h3",
      "text": "Server Memory¬∂",
      "id": "server-memory"
    },
    {
      "level": "h3",
      "text": "Multiple Processes - An Example¬∂",
      "id": "multiple-processes-an-example"
    },
    {
      "level": "h3",
      "text": "Examples of Replication Tools and Strategies¬∂",
      "id": "examples-of-replication-tools-and-strategies"
    },
    {
      "level": "h2",
      "text": "Previous Steps Before Starting¬∂",
      "id": "previous-steps-before-starting"
    },
    {
      "level": "h3",
      "text": "Examples of Previous Steps Strategies¬∂",
      "id": "examples-of-previous-steps-strategies"
    },
    {
      "level": "h2",
      "text": "Resource Utilization¬∂",
      "id": "resource-utilization"
    },
    {
      "level": "h2",
      "text": "Recap¬∂",
      "id": "recap"
    }
  ],
  "code_samples": [],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/deployment/concepts/",
    "https://fastapi.tiangolo.com/deployment/concepts/?q=",
    "https://fastapi.tiangolo.com/features/",
    "https://fastapi.tiangolo.com/reference/",
    "https://fastapi.tiangolo.com/python-types/",
    "https://fastapi.tiangolo.com/async/",
    "https://fastapi.tiangolo.com/environment-variables/",
    "https://fastapi.tiangolo.com/virtual-environments/",
    "https://fastapi.tiangolo.com/tutorial/",
    "https://fastapi.tiangolo.com/tutorial/first-steps/",
    "https://fastapi.tiangolo.com/tutorial/path-params/",
    "https://fastapi.tiangolo.com/tutorial/query-params/",
    "https://fastapi.tiangolo.com/tutorial/body/",
    "https://fastapi.tiangolo.com/tutorial/query-params-str-validations/",
    "https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/",
    "https://fastapi.tiangolo.com/tutorial/query-param-models/",
    "https://fastapi.tiangolo.com/tutorial/body-multiple-params/",
    "https://fastapi.tiangolo.com/tutorial/body-fields/",
    "https://fastapi.tiangolo.com/tutorial/body-nested-models/",
    "https://fastapi.tiangolo.com/tutorial/schema-extra-example/",
    "https://fastapi.tiangolo.com/tutorial/extra-data-types/",
    "https://fastapi.tiangolo.com/tutorial/cookie-params/",
    "https://fastapi.tiangolo.com/tutorial/header-params/",
    "https://fastapi.tiangolo.com/tutorial/cookie-param-models/",
    "https://fastapi.tiangolo.com/tutorial/header-param-models/",
    "https://fastapi.tiangolo.com/tutorial/response-model/",
    "https://fastapi.tiangolo.com/tutorial/extra-models/",
    "https://fastapi.tiangolo.com/tutorial/response-status-code/",
    "https://fastapi.tiangolo.com/tutorial/request-forms/",
    "https://fastapi.tiangolo.com/tutorial/request-form-models/",
    "https://fastapi.tiangolo.com/tutorial/request-files/",
    "https://fastapi.tiangolo.com/tutorial/request-forms-and-files/",
    "https://fastapi.tiangolo.com/tutorial/handling-errors/",
    "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/",
    "https://fastapi.tiangolo.com/tutorial/encoder/",
    "https://fastapi.tiangolo.com/tutorial/body-updates/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/",
    "https://fastapi.tiangolo.com/tutorial/security/",
    "https://fastapi.tiangolo.com/tutorial/security/first-steps/",
    "https://fastapi.tiangolo.com/tutorial/security/get-current-user/",
    "https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/",
    "https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/",
    "https://fastapi.tiangolo.com/tutorial/middleware/",
    "https://fastapi.tiangolo.com/tutorial/cors/",
    "https://fastapi.tiangolo.com/tutorial/sql-databases/",
    "https://fastapi.tiangolo.com/tutorial/bigger-applications/",
    "https://fastapi.tiangolo.com/tutorial/background-tasks/",
    "https://fastapi.tiangolo.com/tutorial/metadata/",
    "https://fastapi.tiangolo.com/tutorial/static-files/",
    "https://fastapi.tiangolo.com/tutorial/testing/",
    "https://fastapi.tiangolo.com/tutorial/debugging/",
    "https://fastapi.tiangolo.com/advanced/",
    "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
    "https://fastapi.tiangolo.com/advanced/additional-status-codes/",
    "https://fastapi.tiangolo.com/advanced/response-directly/",
    "https://fastapi.tiangolo.com/advanced/custom-response/",
    "https://fastapi.tiangolo.com/advanced/additional-responses/",
    "https://fastapi.tiangolo.com/advanced/response-cookies/",
    "https://fastapi.tiangolo.com/advanced/response-headers/",
    "https://fastapi.tiangolo.com/advanced/response-change-status-code/",
    "https://fastapi.tiangolo.com/advanced/advanced-dependencies/",
    "https://fastapi.tiangolo.com/advanced/security/",
    "https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/",
    "https://fastapi.tiangolo.com/advanced/security/http-basic-auth/",
    "https://fastapi.tiangolo.com/advanced/using-request-directly/",
    "https://fastapi.tiangolo.com/advanced/dataclasses/",
    "https://fastapi.tiangolo.com/advanced/middleware/",
    "https://fastapi.tiangolo.com/advanced/sub-applications/",
    "https://fastapi.tiangolo.com/advanced/behind-a-proxy/",
    "https://fastapi.tiangolo.com/advanced/templates/",
    "https://fastapi.tiangolo.com/advanced/websockets/",
    "https://fastapi.tiangolo.com/advanced/events/",
    "https://fastapi.tiangolo.com/advanced/testing-websockets/",
    "https://fastapi.tiangolo.com/advanced/testing-events/",
    "https://fastapi.tiangolo.com/advanced/testing-dependencies/",
    "https://fastapi.tiangolo.com/advanced/async-tests/",
    "https://fastapi.tiangolo.com/advanced/settings/",
    "https://fastapi.tiangolo.com/advanced/openapi-callbacks/",
    "https://fastapi.tiangolo.com/advanced/openapi-webhooks/",
    "https://fastapi.tiangolo.com/advanced/wsgi/",
    "https://fastapi.tiangolo.com/advanced/generate-clients/",
    "https://fastapi.tiangolo.com/fastapi-cli/",
    "https://fastapi.tiangolo.com/deployment/",
    "https://fastapi.tiangolo.com/deployment/versions/",
    "https://fastapi.tiangolo.com/deployment/fastapicloud/",
    "https://fastapi.tiangolo.com/deployment/https/",
    "https://fastapi.tiangolo.com/deployment/manually/",
    "https://fastapi.tiangolo.com/deployment/cloud/",
    "https://fastapi.tiangolo.com/deployment/server-workers/",
    "https://fastapi.tiangolo.com/deployment/docker/",
    "https://fastapi.tiangolo.com/how-to/",
    "https://fastapi.tiangolo.com/how-to/general/",
    "https://fastapi.tiangolo.com/how-to/migrate-from-pydantic-v1-to-pydantic-v2/",
    "https://fastapi.tiangolo.com/how-to/graphql/",
    "https://fastapi.tiangolo.com/how-to/custom-request-and-route/",
    "https://fastapi.tiangolo.com/how-to/conditional-openapi/",
    "https://fastapi.tiangolo.com/how-to/extending-openapi/",
    "https://fastapi.tiangolo.com/how-to/separate-openapi-schemas/",
    "https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/",
    "https://fastapi.tiangolo.com/how-to/configure-swagger-ui/",
    "https://fastapi.tiangolo.com/how-to/testing-database/",
    "https://fastapi.tiangolo.com/how-to/authentication-error-status-code/",
    "https://fastapi.tiangolo.com/reference/fastapi/",
    "https://fastapi.tiangolo.com/reference/parameters/",
    "https://fastapi.tiangolo.com/reference/status/",
    "https://fastapi.tiangolo.com/reference/uploadfile/",
    "https://fastapi.tiangolo.com/reference/exceptions/",
    "https://fastapi.tiangolo.com/reference/dependencies/",
    "https://fastapi.tiangolo.com/reference/apirouter/",
    "https://fastapi.tiangolo.com/reference/background/",
    "https://fastapi.tiangolo.com/reference/request/",
    "https://fastapi.tiangolo.com/reference/websockets/",
    "https://fastapi.tiangolo.com/reference/httpconnection/",
    "https://fastapi.tiangolo.com/reference/response/",
    "https://fastapi.tiangolo.com/reference/responses/",
    "https://fastapi.tiangolo.com/reference/middleware/",
    "https://fastapi.tiangolo.com/reference/openapi/",
    "https://fastapi.tiangolo.com/reference/openapi/docs/",
    "https://fastapi.tiangolo.com/reference/openapi/models/",
    "https://fastapi.tiangolo.com/reference/security/",
    "https://fastapi.tiangolo.com/reference/encoders/",
    "https://fastapi.tiangolo.com/reference/staticfiles/",
    "https://fastapi.tiangolo.com/reference/templating/",
    "https://fastapi.tiangolo.com/reference/testclient/"
  ]
}