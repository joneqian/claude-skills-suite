{
  "url": "https://docs.nestjs.com/graphql/resolvers",
  "title": "",
  "content": "Resolvers provide the instructions for turning a GraphQL operation (a query, mutation, or subscription) into data. They return the same shape of data we specify in our schema -- either synchronously or as a promise that resolves to a result of that shape. Typically, you create a resolver map manually. The @nestjs/graphql package, on the other hand, generates a resolver map automatically using the metadata provided by decorators you use to annotate classes. To demonstrate the process of using the package features to create a GraphQL API, we'll create a simple authors API.\n\nIn the code first approach, we don't follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The @nestjs/graphql package reads the metadata defined through the decorators and automatically generates the schema for you.\n\nMost of the definitions in a GraphQL schema are object types. Each object type you define should represent a domain object that an application client might need to interact with. For example, our sample API needs to be able to fetch a list of authors and their posts, so we should define the Author type and Post type to support this functionality.\n\nIf we were using the schema first approach, we'd define such a schema with SDL like this:\n\nIn this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:\n\nThe Author object type, like any class, is made of a collection of fields, with each field declaring a type. A field's type corresponds to a GraphQL type. A field's GraphQL type can be either another object type or a scalar type. A GraphQL scalar type is a primitive (like ID, String, Boolean, or Int) that resolves to a single value.\n\nThe above Author object type definition will cause Nest to generate the SDL we showed above:\n\nThe @Field() decorator accepts an optional type function (e.g., type => Int), and optionally an options object.\n\nThe type function is required when there's the potential for ambiguity between the TypeScript type system and the GraphQL type system. Specifically: it is not required for string and boolean types; it is required for number (which must be mapped to either a GraphQL Int or Float). The type function should simply return the desired GraphQL type (as shown in various examples in these chapters).\n\nThe options object can have any of the following key/value pairs:\n\nWhen the field is an array, we must manually indicate the array type in the Field() decorator's type function, as shown below:\n\nTo declare that an array's items (not the array itself) are nullable, set the nullable property to 'items' as shown below:\n\nNow that the Author object type is created, let's define the Post object type.\n\nThe Post object type will result in generating the following part of the GraphQL schema in SDL:\n\nAt this point, we've defined the objects (type definitions) that can exist in our data graph, but clients don't yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, a resolver class both defines resolver functions and generates the Query type. This will be clear as we work through the example below:\n\nYou can define multiple resolver classes. Nest will combine these at run time. See the module section below for more on code organization.\n\nIn the example above, we created the AuthorsResolver which defines one query resolver function and one field resolver function. To create a resolver, we create a class with resolver functions as methods, and annotate the class with the @Resolver() decorator.\n\nIn this example, we defined a query handler to get the author object based on the id sent in the request. To specify that the method is a query handler, use the @Query() decorator.\n\nThe argument passed to the @Resolver() decorator is optional, but comes into play when our graph becomes non-trivial. It's used to supply a parent object used by field resolver functions as they traverse down through an object graph.\n\nIn our example, since the class includes a field resolver function (for the posts property of the Author object type), we must supply the @Resolver() decorator with a value to indicate which class is the parent type (i.e., the corresponding ObjectType class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it's necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author's posts array with a field resolver that calls a service which takes the author's id as an argument. Hence the need to identify the parent object in the @Resolver() decorator. Note the corresponding use of the @Parent() method parameter decorator to then extract a reference to that parent object in the field resolver.\n\nWe can define multiple @Query() resolver functions (both within this class, and in any other resolver class), and they will be aggregated into a single Query type definition in the generated SDL along with the appropriate entries in the resolver map. This allows you to define queries close to the models and services that they use, and to keep them well organized in modules.\n\nIn the above examples, the @Query() decorator generates a GraphQL schema query type name based on the method name. For example, consider the following construction from the example above:\n\nThis generates the following entry for the author query in our schema (the query type uses the same name as the method name):\n\nConventionally, we prefer to decouple these names; for example, we prefer to use a name like getAuthor() for our query handler method, but still use author for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the @Query() and @ResolveField() decorators, as shown below:\n\nThe getAuthor handler method above will result in generating the following part of the GraphQL schema in SDL:\n\nThe @Query() decorator's options object (where we pass {name: 'author'} above) accepts a number of key/value pairs:\n\nUse the @Args() decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to REST route parameter argument extraction.\n\nUsually your @Args() decorator will be simple, and not require an object argument as seen with the getAuthor() method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument.\n\nIn the getAuthor() case, the number type is used, which presents a challenge. The number TypeScript type doesn't give us enough information about the expected GraphQL representation (e.g., Int vs. Float). Thus we have to explicitly pass the type reference. We do that by passing a second argument to the Args() decorator, containing argument options, as shown below:\n\nThe options object allows us to specify the following optional key value pairs:\n\nQuery handler methods can take multiple arguments. Let's imagine that we want to fetch an author based on its firstName and lastName. In this case, we can call @Args twice:\n\nWith inline @Args() calls, code like the example above becomes bloated. Instead, you can create a dedicated GetAuthorArgs arguments class and access it in the handler method as follows:\n\nCreate the GetAuthorArgs class using @ArgsType() as shown below:\n\nThis will result in generating the following part of the GraphQL schema in SDL:\n\nYou can use standard TypeScript class inheritance to create base classes with generic utility type features (fields and field properties, validations, etc.) that can be extended. For example, you may have a set of pagination related arguments that always include the standard offset and limit fields, but also other index fields that are type-specific. You can set up a class hierarchy as shown below.\n\nBase @ArgsType() class:\n\nType specific sub-class of the base @ArgsType() class:\n\nThe same approach can be taken with @ObjectType() objects. Define generic properties on the base class:\n\nAdd type-specific properties on sub-classes:\n\nYou can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic findAll query, use a construction like this:\n\nHere's how you could generate a concrete sub-class of the BaseResolver:\n\nThis construct would generated the following SDL:\n\nWe saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here's a sample cursor-based pagination implementation based on this documentation:\n\nWith the above base class defined, we can now easily create specialized types that inherit this behavior. For example:\n\nAs mentioned in the previous chapter, in the schema first approach we start by manually defining schema types in SDL (read more). Consider the following SDL type definitions.\n\nThe schema above exposes a single query - author(id: Int!): Author.\n\nLet's now create an AuthorsResolver class that resolves author queries:\n\nThe @Resolver() decorator is required. It takes an optional string argument with the name of a class. This class name is required whenever the class includes @ResolveField() decorators to inform Nest that the decorated method is associated with a parent type (the Author type in our current example). Alternatively, instead of setting @Resolver() at the top of the class, this can be done for each method:\n\nIn this case (@Resolver() decorator at the method level), if you have multiple @ResolveField() decorators inside a class, you must add @Resolver() to all of them. This is not considered the best practice (as it creates extra overhead).\n\nIn the above examples, the @Query() and @ResolveField() decorators are associated with GraphQL schema types based on the method name. For example, consider the following construction from the example above:\n\nThis generates the following entry for the author query in our schema (the query type uses the same name as the method name):\n\nConventionally, we would prefer to decouple these, using names like getAuthor() or getPosts() for our resolver methods. We can easily do this by passing the mapping name as an argument to the decorator, as shown below:\n\nAssuming that we use the schema first approach and have enabled the typings generation feature (with outputAs: 'class' as shown in the previous chapter), once you run the application it will generate the following file (in the location you specified in the GraphQLModule.forRoot() method). For example, in src/graphql.ts:\n\nBy generating classes (instead of the default technique of generating interfaces), you can use declarative validation decorators in combination with the schema first approach, which is an extremely useful technique (read more). For example, you could add class-validator decorators to the generated CreatePostInput class as shown below to enforce minimum and maximum string lengths on the title field:\n\nHowever, if you add decorators directly to the automatically generated file, they will be overwritten each time the file is generated. Instead, create a separate file and simply extend the generated class.\n\nWe can access the standard GraphQL resolver arguments using dedicated decorators. Below is a comparison of the Nest decorators and the plain Apollo parameters they represent.\n\nThese arguments have the following meanings:\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nOnce we're done with the above steps, we have declaratively specified all the information needed by the GraphQLModule to generate a resolver map. The GraphQLModule uses reflection to introspect the meta data provided via the decorators, and transforms classes into the correct resolver map automatically.\n\nThe only other thing you need to take care of is to provide (i.e., list as a provider in some module) the resolver class(es) (AuthorsResolver), and importing the module (AuthorsModule) somewhere, so Nest will be able to utilize it.\n\nFor example, we can do this in an AuthorsModule, which can also provide other services needed in this context. Be sure to import AuthorsModule somewhere (e.g., in the root module, or some other module imported by the root module).",
  "headings": [
    {
      "level": "h3",
      "text": "Resolvers",
      "id": "resolvers"
    },
    {
      "level": "h4",
      "text": "Code first#",
      "id": "code-first"
    },
    {
      "level": "h4",
      "text": "Object types#",
      "id": "object-types"
    },
    {
      "level": "h4",
      "text": "Code first resolver#",
      "id": "code-first-resolver"
    },
    {
      "level": "h4",
      "text": "Query type names#",
      "id": "query-type-names"
    },
    {
      "level": "h4",
      "text": "Query decorator options#",
      "id": "query-decorator-options"
    },
    {
      "level": "h4",
      "text": "Args decorator options#",
      "id": "args-decorator-options"
    },
    {
      "level": "h4",
      "text": "Dedicated arguments class#",
      "id": "dedicated-arguments-class"
    },
    {
      "level": "h4",
      "text": "Class inheritance#",
      "id": "class-inheritance"
    },
    {
      "level": "h4",
      "text": "Generics#",
      "id": "generics"
    },
    {
      "level": "h4",
      "text": "Schema first#",
      "id": "schema-first"
    },
    {
      "level": "h4",
      "text": "Schema first resolver#",
      "id": "schema-first-resolver"
    },
    {
      "level": "h4",
      "text": "Generating types#",
      "id": "generating-types"
    },
    {
      "level": "h4",
      "text": "GraphQL argument decorators#",
      "id": "graphql-argument-decorators"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Module#",
      "id": "module"
    }
  ],
  "code_samples": [
    {
      "code": "type Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post!]!\n}",
      "language": "css"
    },
    {
      "code": "import { Field, Int, ObjectType } from '@nestjs/graphql';\nimport { Post } from './post';\n\n@ObjectType()\nexport class Author {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ nullable: true })\n  lastName?: string;\n\n  @Field(type => [Post])\n  posts: Post[];\n}",
      "language": "typescript"
    },
    {
      "code": "type Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post!]!\n}",
      "language": "css"
    },
    {
      "code": "@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })\ntitle: string;",
      "language": "typescript"
    },
    {
      "code": "@Field(type => [Post])\nposts: Post[];",
      "language": "typescript"
    },
    {
      "code": "@Field(type => [Post], { nullable: 'items' })\nposts: Post[];",
      "language": "typescript"
    },
    {
      "code": "import { Field, Int, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Post {\n  @Field(type => Int)\n  id: number;\n\n  @Field()\n  title: string;\n\n  @Field(type => Int, { nullable: true })\n  votes?: number;\n}",
      "language": "typescript"
    },
    {
      "code": "type Post {\n  id: Int!\n  title: String!\n  votes: Int\n}",
      "language": "css"
    },
    {
      "code": "@Resolver(() => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(() => Author)\n  async author(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Query(() => Author)\nasync author(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}",
      "language": "typescript"
    },
    {
      "code": "type Query {\n  author(id: Int!): Author\n}",
      "language": "unknown"
    },
    {
      "code": "@Resolver(() => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(() => Author, { name: 'author' })\n  async getAuthor(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts', () => [Post])\n  async getPosts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "type Query {\n  author(id: Int!): Author\n}",
      "language": "unknown"
    },
    {
      "code": "@Args('id') id: string",
      "language": "typescript"
    },
    {
      "code": "@Query(() => Author, { name: 'author' })\nasync getAuthor(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}",
      "language": "typescript"
    },
    {
      "code": "getAuthor(\n  @Args('firstName', { nullable: true }) firstName?: string,\n  @Args('lastName', { defaultValue: '' }) lastName?: string,\n) {}",
      "language": "typescript"
    },
    {
      "code": "@Args() args: GetAuthorArgs",
      "language": "typescript"
    },
    {
      "code": "import { MinLength } from 'class-validator';\nimport { Field, ArgsType } from '@nestjs/graphql';\n\n@ArgsType()\nclass GetAuthorArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}",
      "language": "typescript"
    },
    {
      "code": "type Query {\n  author(firstName: String, lastName: String = ''): Author\n}",
      "language": "typescript"
    },
    {
      "code": "@ArgsType()\nclass PaginationArgs {\n  @Field(() => Int)\n  offset: number = 0;\n\n  @Field(() => Int)\n  limit: number = 10;\n}",
      "language": "typescript"
    },
    {
      "code": "@ArgsType()\nclass GetAuthorArgs extends PaginationArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}",
      "language": "typescript"
    },
    {
      "code": "@ObjectType()\nclass Character {\n  @Field(() => Int)\n  id: number;\n\n  @Field()\n  name: string;\n}",
      "language": "typescript"
    },
    {
      "code": "@ObjectType()\nclass Warrior extends Character {\n  @Field()\n  level: number;\n}",
      "language": "typescript"
    },
    {
      "code": "function BaseResolver<T extends Type<unknown>>(classRef: T): any {\n  @Resolver({ isAbstract: true })\n  abstract class BaseResolverHost {\n    @Query(() => [classRef], { name: `findAll${classRef.name}` })\n    async findAll(): Promise<T[]> {\n      return [];\n    }\n  }\n  return BaseResolverHost;\n}",
      "language": "typescript"
    },
    {
      "code": "@Resolver(() => Recipe)\nexport class RecipesResolver extends BaseResolver(Recipe) {\n  constructor(private recipesService: RecipesService) {\n    super();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "type Query {\n  findAllRecipe: [Recipe!]!\n}",
      "language": "css"
    },
    {
      "code": "import { Field, ObjectType, Int } from '@nestjs/graphql';\nimport { Type } from '@nestjs/common';\n\ninterface IEdgeType<T> {\n  cursor: string;\n  node: T;\n}\n\nexport interface IPaginatedType<T> {\n  edges: IEdgeType<T>[];\n  nodes: T[];\n  totalCount: number;\n  hasNextPage: boolean;\n}\n\nexport function Paginated<T>(classRef: Type<T>): Type<IPaginatedType<T>> {\n  @ObjectType(`${classRef.name}Edge`)\n  abstract class EdgeType {\n    @Field(() => String)\n    cursor: string;\n\n    @Field(() => classRef)\n    node: T;\n  }\n\n  @ObjectType({ isAbstract: true })\n  abstract class PaginatedType implements IPaginatedType<T> {\n    @Field(() => [EdgeType], { nullable: true })\n    edges: EdgeType[];\n\n    @Field(() => [classRef], { nullable: true })\n    nodes: T[];\n\n    @Field(() => Int)\n    totalCount: number;\n\n    @Field()\n    hasNextPage: boolean;\n  }\n  return PaginatedType as Type<IPaginatedType<T>>;\n}",
      "language": "typescript"
    },
    {
      "code": "@ObjectType()\nclass PaginatedAuthor extends Paginated(Author) {}",
      "language": "typescript"
    },
    {
      "code": "type Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String!\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}",
      "language": "css"
    },
    {
      "code": "@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query()\n  async author(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Resolver('Author')\n@ResolveField()\nasync posts(@Parent() author) {\n  const { id } = author;\n  return this.postsService.findAll({ authorId: id });\n}",
      "language": "typescript"
    },
    {
      "code": "@Query()\nasync author(@Args('id') id: number) {\n  return this.authorsService.findOneById(id);\n}",
      "language": "typescript"
    },
    {
      "code": "type Query {\n  author(id: Int!): Author\n}",
      "language": "unknown"
    },
    {
      "code": "@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query('author')\n  async getAuthor(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts')\n  async getPosts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export class Author {\n  id: number;\n  firstName?: string;\n  lastName?: string;\n  posts?: Post[];\n}\nexport class Post {\n  id: number;\n  title: string;\n  votes?: number;\n}\n\nexport abstract class IQuery {\n  abstract author(id: number): Author | Promise<Author>;\n}",
      "language": "typescript"
    },
    {
      "code": "import { MinLength, MaxLength } from 'class-validator';\n\nexport class CreatePostInput {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}",
      "language": "typescript"
    },
    {
      "code": "import { MinLength, MaxLength } from 'class-validator';\nimport { Post } from '../../graphql.ts';\n\nexport class CreatePostInput extends Post {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [PostsModule],\n  providers: [AuthorsService, AuthorsResolver],\n})\nexport class AuthorsModule {}",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "For example:",
      "code": "@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })\ntitle: string;"
    },
    {
      "description": "With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:",
      "code": "@ObjectType()\nclass PaginatedAuthor extends Paginated(Author) {}"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}