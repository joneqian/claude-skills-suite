{
  "url": "https://fastapi.tiangolo.com/reference/security/",
  "title": "Security Tools¶",
  "content": "When you need to declare dependencies with OAuth2 scopes you use Security().\n\nBut you still need to define what is the dependable, the callable that you pass as a parameter to Depends() or Security().\n\nThere are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc.\n\nYou can import them from fastapi.security:\n\nAPI key authentication using a cookie.\n\nThis defines the name of the cookie that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the cookie automatically and provides it as the dependency result. But it doesn't define how to set that cookie.\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be a string containing the key value.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the cookie is not provided, APIKeyCookie will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the cookie is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a cookie or in an HTTP Bearer token).\n\nTYPE: bool DEFAULT: True\n\nThe WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 \"Unauthorized\" must include a WWW-Authenticate header.\n\nRef: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\nFor this, this method sends a custom challenge APIKey.\n\nAPI key authentication using a header.\n\nThis defines the name of the header that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the header automatically and provides it as the dependency result. But it doesn't define how to send that key to the client.\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be a string containing the key value.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the header is not provided, APIKeyHeader will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the header is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a header or in an HTTP Bearer token).\n\nTYPE: bool DEFAULT: True\n\nThe WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 \"Unauthorized\" must include a WWW-Authenticate header.\n\nRef: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\nFor this, this method sends a custom challenge APIKey.\n\nAPI key authentication using a query parameter.\n\nThis defines the name of the query parameter that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the query parameter automatically and provides it as the dependency result. But it doesn't define how to send that API key to the client.\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be a string containing the key value.\n\nQuery parameter name.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the query parameter is not provided, APIKeyQuery will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the query parameter is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a query parameter or in an HTTP Bearer token).\n\nTYPE: bool DEFAULT: True\n\nThe WWW-Authenticate header is not standardized for API Key authentication but the HTTP specification requires that an error of 401 \"Unauthorized\" must include a WWW-Authenticate header.\n\nRef: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\nFor this, this method sends a custom challenge APIKey.\n\nHTTP Basic authentication.\n\nRef: https://datatracker.ietf.org/doc/html/rfc7617\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be an HTTPBasicCredentials object containing the username and the password.\n\nRead more about it in the FastAPI docs for HTTP Basic Auth.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nHTTP Basic authentication realm.\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the HTTP Basic authentication is not provided (a header), HTTPBasic will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Basic authentication is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Basic authentication or in an HTTP Bearer token).\n\nTYPE: bool DEFAULT: True\n\nHTTP Bearer token authentication.\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials.\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the HTTP Bearer token is not provided (in an Authorization header), HTTPBearer will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Bearer token is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in an HTTP Bearer token or in a cookie).\n\nTYPE: bool DEFAULT: True\n\nHTTP Digest authentication.\n\nWarning: this is only a stub to connect the components with OpenAPI in FastAPI, but it doesn't implement the full Digest scheme, you would need to to subclass it and implement it in your code.\n\nRef: https://datatracker.ietf.org/doc/html/rfc7616\n\nCreate an instance object and use that object as the dependency in Depends().\n\nThe dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if the HTTP Digest is not provided, HTTPDigest will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Digest is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Digest or in a cookie).\n\nTYPE: bool DEFAULT: True\n\nThe HTTP authorization credentials in the result of using HTTPBearer or HTTPDigest in a dependency.\n\nThe HTTP authorization header value is split by the first space.\n\nThe first part is the scheme, the second part is the credentials.\n\nFor example, in an HTTP Bearer token scheme, the client will send a header like:\n\nThe HTTP authorization scheme extracted from the header value.\n\nThe HTTP authorization credentials extracted from the header value.\n\nThe HTTP Basic credentials given as the result of using HTTPBasic in a dependency.\n\nRead more about it in the FastAPI docs for HTTP Basic Auth.\n\nThe HTTP Basic username.\n\nThe HTTP Basic password.\n\nThis is the base class for OAuth2 authentication, an instance of it would be used as a dependency. All other OAuth2 classes inherit from it and customize it for each OAuth2 flow.\n\nYou normally would not create a new class inheriting from it but use one of the existing subclasses, and maybe compose them if you want to support multiple flows.\n\nRead more about it in the FastAPI docs for Security.\n\nThe dictionary of OAuth2 flows.\n\nTYPE: Union[OAuthFlows, dict[str, dict[str, Any]]] DEFAULT: OAuthFlows()\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).\n\nTYPE: bool DEFAULT: True\n\nThe OAuth 2 specification doesn't define the challenge that should be used, because a Bearer token is not really the only option to authenticate.\n\nBut declaring any other authentication challenge would be application-specific as it's not defined in the specification.\n\nFor practical reasons, this method uses the Bearer challenge by default, as it's probably the most common one.\n\nIf you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.\n\nRef: https://datatracker.ietf.org/doc/html/rfc6749\n\nOAuth2 flow for authentication using a bearer token obtained with an OAuth2 code flow. An instance of it would be used as a dependency.\n\nThe URL to obtain the OAuth2 token.\n\nThe URL to refresh the token and obtain a new one.\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nThe OAuth2 scopes that would be required by the path operations that use this dependency.\n\nTYPE: Optional[dict[str, str]] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).\n\nTYPE: bool DEFAULT: True\n\nThe OAuth 2 specification doesn't define the challenge that should be used, because a Bearer token is not really the only option to authenticate.\n\nBut declaring any other authentication challenge would be application-specific as it's not defined in the specification.\n\nFor practical reasons, this method uses the Bearer challenge by default, as it's probably the most common one.\n\nIf you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.\n\nRef: https://datatracker.ietf.org/doc/html/rfc6749\n\nOAuth2 flow for authentication using a bearer token obtained with a password. An instance of it would be used as a dependency.\n\nRead more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.\n\nThe URL to obtain the OAuth2 token. This would be the path operation that has OAuth2PasswordRequestForm as a dependency.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nThe OAuth2 scopes that would be required by the path operations that use this dependency.\n\nTYPE: Optional[dict[str, str]] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).\n\nTYPE: bool DEFAULT: True\n\nThe URL to refresh the token and obtain a new one.\n\nTYPE: Optional[str] DEFAULT: None\n\nThe OAuth 2 specification doesn't define the challenge that should be used, because a Bearer token is not really the only option to authenticate.\n\nBut declaring any other authentication challenge would be application-specific as it's not defined in the specification.\n\nFor practical reasons, this method uses the Bearer challenge by default, as it's probably the most common one.\n\nIf you are implementing an OAuth2 authentication scheme other than the provided ones in FastAPI (based on bearer tokens), you might want to override this.\n\nRef: https://datatracker.ietf.org/doc/html/rfc6749\n\nThis is a dependency class to collect the username and password as form data for an OAuth2 password flow.\n\nThe OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password.\n\nAll the initialization parameters are extracted from the request.\n\nRead more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.\n\nNote that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.\n\nThe OAuth2 spec says it is required and MUST be the fixed string \"password\". Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it, use instead the OAuth2PasswordRequestFormStrict dependency.\n\nTYPE: Union[str, None] DEFAULT: None\n\nusername string. The OAuth2 spec requires the exact field name username.\n\npassword string. The OAuth2 spec requires the exact field name password.\n\nA single string with actually several scopes separated by spaces. Each scope is also a string.\n\nFor example, a single string with:\n\n```python \"items:read items:write users:read profile openid\" ````\n\nwould represent the scopes:\n\nTYPE: str DEFAULT: ''\n\nIf there's a client_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.\n\nTYPE: Union[str, None] DEFAULT: None\n\nIf there's a client_password (and a client_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.\n\nTYPE: Union[str, None] DEFAULT: None\n\nBases: OAuth2PasswordRequestForm\n\nThis is a dependency class to collect the username and password as form data for an OAuth2 password flow.\n\nThe OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password.\n\nAll the initialization parameters are extracted from the request.\n\nThe only difference between OAuth2PasswordRequestFormStrict and OAuth2PasswordRequestForm is that OAuth2PasswordRequestFormStrict requires the client to send the form field grant_type with the value \"password\", which is required in the OAuth2 specification (it seems that for no particular reason), while for OAuth2PasswordRequestForm grant_type is optional.\n\nRead more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.\n\nNote that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.\n\nThis dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class.\n\nusername: username string. The OAuth2 spec requires the exact field name \"username\". password: password string. The OAuth2 spec requires the exact field name \"password\". scope: Optional string. Several scopes (each one a string) separated by spaces. E.g. \"items:read items:write users:read profile openid\" client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret\n\nThe OAuth2 spec says it is required and MUST be the fixed string \"password\". This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class.\n\nusername string. The OAuth2 spec requires the exact field name username.\n\npassword string. The OAuth2 spec requires the exact field name password.\n\nA single string with actually several scopes separated by spaces. Each scope is also a string.\n\nFor example, a single string with:\n\n```python \"items:read items:write users:read profile openid\" ````\n\nwould represent the scopes:\n\nTYPE: str DEFAULT: ''\n\nIf there's a client_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.\n\nTYPE: Union[str, None] DEFAULT: None\n\nIf there's a client_password (and a client_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.\n\nTYPE: Union[str, None] DEFAULT: None\n\nThis is a special class that you can define in a parameter in a dependency to obtain the OAuth2 scopes required by all the dependencies in the same chain.\n\nThis way, multiple dependencies can have different scopes, even when used in the same path operation. And with this, you can access all the scopes required in all those dependencies in a single place.\n\nRead more about it in the FastAPI docs for OAuth2 scopes.\n\nThis will be filled by FastAPI.\n\nTYPE: Optional[list[str]] DEFAULT: None\n\nThe list of all the scopes required by dependencies.\n\nAll the scopes required by all the dependencies in a single string separated by spaces, as defined in the OAuth2 specification.\n\nOpenID Connect authentication class. An instance of it would be used as a dependency.\n\nWarning: this is only a stub to connect the components with OpenAPI in FastAPI, but it doesn't implement the full OpenIdConnect scheme, for example, it doesn't use the OpenIDConnect URL. You would need to to subclass it and implement it in your code.\n\nThe OpenID Connect URL.\n\nSecurity scheme name.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nSecurity scheme description.\n\nIt will be included in the generated OpenAPI (e.g. visible at /docs).\n\nTYPE: Optional[str] DEFAULT: None\n\nBy default, if no HTTP Authorization header is provided, required for OpenID Connect authentication, it will automatically cancel the request and send the client an error.\n\nIf auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.\n\nThis is useful when you want to have optional authentication.\n\nIt is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OpenID Connect or in a cookie).\n\nTYPE: bool DEFAULT: True",
  "headings": [
    {
      "level": "h1",
      "text": "Security Tools¶",
      "id": "security-tools"
    },
    {
      "level": "h2",
      "text": "API Key Security Schemes¶",
      "id": "api-key-security-schemes"
    },
    {
      "level": "h2",
      "text": "fastapi.security.APIKeyCookie ¶",
      "id": "fastapi.security.APIKeyCookie"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.APIKeyCookie--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.APIKeyCookie--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.APIKeyCookie.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.APIKeyCookie.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.APIKeyCookie.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.APIKeyCookie.make_not_authenticated_error"
    },
    {
      "level": "h3",
      "text": "check_api_key ¶",
      "id": "fastapi.security.APIKeyCookie.check_api_key"
    },
    {
      "level": "h2",
      "text": "fastapi.security.APIKeyHeader ¶",
      "id": "fastapi.security.APIKeyHeader"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.APIKeyHeader--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.APIKeyHeader--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.APIKeyHeader.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.APIKeyHeader.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.APIKeyHeader.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.APIKeyHeader.make_not_authenticated_error"
    },
    {
      "level": "h3",
      "text": "check_api_key ¶",
      "id": "fastapi.security.APIKeyHeader.check_api_key"
    },
    {
      "level": "h2",
      "text": "fastapi.security.APIKeyQuery ¶",
      "id": "fastapi.security.APIKeyQuery"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.APIKeyQuery--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.APIKeyQuery--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.APIKeyQuery.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.APIKeyQuery.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.APIKeyQuery.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.APIKeyQuery.make_not_authenticated_error"
    },
    {
      "level": "h3",
      "text": "check_api_key ¶",
      "id": "fastapi.security.APIKeyQuery.check_api_key"
    },
    {
      "level": "h2",
      "text": "HTTP Authentication Schemes¶",
      "id": "http-authentication-schemes"
    },
    {
      "level": "h2",
      "text": "fastapi.security.HTTPBasic ¶",
      "id": "fastapi.security.HTTPBasic"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.HTTPBasic--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.HTTPBasic--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.HTTPBasic.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.HTTPBasic.scheme_name"
    },
    {
      "level": "h3",
      "text": "realm instance-attribute ¶",
      "id": "fastapi.security.HTTPBasic.realm"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.HTTPBasic.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.HTTPBasic.make_not_authenticated_error"
    },
    {
      "level": "h3",
      "text": "make_authenticate_headers ¶",
      "id": "fastapi.security.HTTPBasic.make_authenticate_headers"
    },
    {
      "level": "h2",
      "text": "fastapi.security.HTTPBearer ¶",
      "id": "fastapi.security.HTTPBearer"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.HTTPBearer--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.HTTPBearer--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.HTTPBearer.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.HTTPBearer.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.HTTPBearer.auto_error"
    },
    {
      "level": "h3",
      "text": "make_authenticate_headers ¶",
      "id": "fastapi.security.HTTPBearer.make_authenticate_headers"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.HTTPBearer.make_not_authenticated_error"
    },
    {
      "level": "h2",
      "text": "fastapi.security.HTTPDigest ¶",
      "id": "fastapi.security.HTTPDigest"
    },
    {
      "level": "h4",
      "text": "Usage¶",
      "id": "fastapi.security.HTTPDigest--usage"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.HTTPDigest--example"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.HTTPDigest.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.HTTPDigest.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.HTTPDigest.auto_error"
    },
    {
      "level": "h3",
      "text": "make_authenticate_headers ¶",
      "id": "fastapi.security.HTTPDigest.make_authenticate_headers"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.HTTPDigest.make_not_authenticated_error"
    },
    {
      "level": "h2",
      "text": "HTTP Credentials¶",
      "id": "http-credentials"
    },
    {
      "level": "h2",
      "text": "fastapi.security.HTTPAuthorizationCredentials ¶",
      "id": "fastapi.security.HTTPAuthorizationCredentials"
    },
    {
      "level": "h3",
      "text": "scheme instance-attribute ¶",
      "id": "fastapi.security.HTTPAuthorizationCredentials.scheme"
    },
    {
      "level": "h3",
      "text": "credentials instance-attribute ¶",
      "id": "fastapi.security.HTTPAuthorizationCredentials.credentials"
    },
    {
      "level": "h2",
      "text": "fastapi.security.HTTPBasicCredentials ¶",
      "id": "fastapi.security.HTTPBasicCredentials"
    },
    {
      "level": "h3",
      "text": "username instance-attribute ¶",
      "id": "fastapi.security.HTTPBasicCredentials.username"
    },
    {
      "level": "h3",
      "text": "password instance-attribute ¶",
      "id": "fastapi.security.HTTPBasicCredentials.password"
    },
    {
      "level": "h2",
      "text": "OAuth2 Authentication¶",
      "id": "oauth2-authentication"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OAuth2 ¶",
      "id": "fastapi.security.OAuth2"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.OAuth2.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.OAuth2.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.OAuth2.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.OAuth2.make_not_authenticated_error"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OAuth2AuthorizationCodeBearer ¶",
      "id": "fastapi.security.OAuth2AuthorizationCodeBearer"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.OAuth2AuthorizationCodeBearer.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.OAuth2AuthorizationCodeBearer.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.OAuth2AuthorizationCodeBearer.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.OAuth2AuthorizationCodeBearer.make_not_authenticated_error"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OAuth2PasswordBearer ¶",
      "id": "fastapi.security.OAuth2PasswordBearer"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordBearer.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordBearer.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordBearer.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.OAuth2PasswordBearer.make_not_authenticated_error"
    },
    {
      "level": "h2",
      "text": "OAuth2 Password Form¶",
      "id": "oauth2-password-form"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OAuth2PasswordRequestForm ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm--example"
    },
    {
      "level": "h3",
      "text": "grant_type instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.grant_type"
    },
    {
      "level": "h3",
      "text": "username instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.username"
    },
    {
      "level": "h3",
      "text": "password instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.password"
    },
    {
      "level": "h3",
      "text": "scopes instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.scopes"
    },
    {
      "level": "h3",
      "text": "client_id instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.client_id"
    },
    {
      "level": "h3",
      "text": "client_secret instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestForm.client_secret"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OAuth2PasswordRequestFormStrict ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict"
    },
    {
      "level": "h4",
      "text": "Example¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict--example"
    },
    {
      "level": "h3",
      "text": "grant_type instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.grant_type"
    },
    {
      "level": "h3",
      "text": "username instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.username"
    },
    {
      "level": "h3",
      "text": "password instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.password"
    },
    {
      "level": "h3",
      "text": "scopes instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.scopes"
    },
    {
      "level": "h3",
      "text": "client_id instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.client_id"
    },
    {
      "level": "h3",
      "text": "client_secret instance-attribute ¶",
      "id": "fastapi.security.OAuth2PasswordRequestFormStrict.client_secret"
    },
    {
      "level": "h2",
      "text": "OAuth2 Security Scopes in Dependencies¶",
      "id": "oauth2-security-scopes-in-dependencies"
    },
    {
      "level": "h2",
      "text": "fastapi.security.SecurityScopes ¶",
      "id": "fastapi.security.SecurityScopes"
    },
    {
      "level": "h3",
      "text": "scopes instance-attribute ¶",
      "id": "fastapi.security.SecurityScopes.scopes"
    },
    {
      "level": "h3",
      "text": "scope_str instance-attribute ¶",
      "id": "fastapi.security.SecurityScopes.scope_str"
    },
    {
      "level": "h2",
      "text": "OpenID Connect¶",
      "id": "openid-connect"
    },
    {
      "level": "h2",
      "text": "fastapi.security.OpenIdConnect ¶",
      "id": "fastapi.security.OpenIdConnect"
    },
    {
      "level": "h3",
      "text": "model instance-attribute ¶",
      "id": "fastapi.security.OpenIdConnect.model"
    },
    {
      "level": "h3",
      "text": "scheme_name instance-attribute ¶",
      "id": "fastapi.security.OpenIdConnect.scheme_name"
    },
    {
      "level": "h3",
      "text": "auto_error instance-attribute ¶",
      "id": "fastapi.security.OpenIdConnect.auto_error"
    },
    {
      "level": "h3",
      "text": "make_not_authenticated_error ¶",
      "id": "fastapi.security.OpenIdConnect.make_not_authenticated_error"
    }
  ],
  "code_samples": [
    {
      "code": "from fastapi.security import (\n    APIKeyCookie,\n    APIKeyHeader,\n    APIKeyQuery,\n    HTTPAuthorizationCredentials,\n    HTTPBasic,\n    HTTPBasicCredentials,\n    HTTPBearer,\n    HTTPDigest,\n    OAuth2,\n    OAuth2AuthorizationCodeBearer,\n    OAuth2PasswordBearer,\n    OAuth2PasswordRequestForm,\n    OAuth2PasswordRequestFormStrict,\n    OpenIdConnect,\n    SecurityScopes,\n)",
      "language": "sql"
    },
    {
      "code": "APIKeyCookie(\n    *,\n    name,\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom fastapi.security import APIKeyCookie\n\napp = FastAPI()\n\ncookie_scheme = APIKeyCookie(name=\"session\")\n\n\n@app.get(\"/items/\")\nasync def read_items(session: str = Depends(cookie_scheme)):\n    return {\"session\": session}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    name: Annotated[str, Doc(\"Cookie name.\")],\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the cookie is not provided, `APIKeyCookie` will\n            automatically cancel the request and send the client an error.\n\n            If `auto_error` is set to `False`, when the cookie is not available,\n            instead of erroring out, the dependency result will be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in a cookie or\n            in an HTTP Bearer token).\n            \"\"\"\n        ),\n    ] = True,\n):\n    super().__init__(\n        location=APIKeyIn.cookie,\n        name=name,\n        scheme_name=scheme_name,\n        description=description,\n        auto_error=auto_error,\n    )",
      "language": "python"
    },
    {
      "code": "model = APIKey(\n    **{\"in\": location}, name=name, description=description\n)",
      "language": "json"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The WWW-Authenticate header is not standardized for API Key authentication but\n    the HTTP specification requires that an error of 401 \"Unauthorized\" must\n    include a WWW-Authenticate header.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\n    For this, this method sends a custom challenge `APIKey`.\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"APIKey\"},\n    )",
      "language": "python"
    },
    {
      "code": "check_api_key(api_key)",
      "language": "unknown"
    },
    {
      "code": "def check_api_key(self, api_key: Optional[str]) -> Optional[str]:\n    if not api_key:\n        if self.auto_error:\n            raise self.make_not_authenticated_error()\n        return None\n    return api_key",
      "language": "python"
    },
    {
      "code": "APIKeyHeader(\n    *,\n    name,\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom fastapi.security import APIKeyHeader\n\napp = FastAPI()\n\nheader_scheme = APIKeyHeader(name=\"x-key\")\n\n\n@app.get(\"/items/\")\nasync def read_items(key: str = Depends(header_scheme)):\n    return {\"key\": key}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    name: Annotated[str, Doc(\"Header name.\")],\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the header is not provided, `APIKeyHeader` will\n            automatically cancel the request and send the client an error.\n\n            If `auto_error` is set to `False`, when the header is not available,\n            instead of erroring out, the dependency result will be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in a header or\n            in an HTTP Bearer token).\n            \"\"\"\n        ),\n    ] = True,\n):\n    super().__init__(\n        location=APIKeyIn.header,\n        name=name,\n        scheme_name=scheme_name,\n        description=description,\n        auto_error=auto_error,\n    )",
      "language": "python"
    },
    {
      "code": "model = APIKey(\n    **{\"in\": location}, name=name, description=description\n)",
      "language": "json"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The WWW-Authenticate header is not standardized for API Key authentication but\n    the HTTP specification requires that an error of 401 \"Unauthorized\" must\n    include a WWW-Authenticate header.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\n    For this, this method sends a custom challenge `APIKey`.\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"APIKey\"},\n    )",
      "language": "python"
    },
    {
      "code": "check_api_key(api_key)",
      "language": "unknown"
    },
    {
      "code": "def check_api_key(self, api_key: Optional[str]) -> Optional[str]:\n    if not api_key:\n        if self.auto_error:\n            raise self.make_not_authenticated_error()\n        return None\n    return api_key",
      "language": "python"
    },
    {
      "code": "APIKeyQuery(\n    *,\n    name,\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from fastapi import Depends, FastAPI\nfrom fastapi.security import APIKeyQuery\n\napp = FastAPI()\n\nquery_scheme = APIKeyQuery(name=\"api_key\")\n\n\n@app.get(\"/items/\")\nasync def read_items(api_key: str = Depends(query_scheme)):\n    return {\"api_key\": api_key}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    name: Annotated[\n        str,\n        Doc(\"Query parameter name.\"),\n    ],\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the query parameter is not provided, `APIKeyQuery` will\n            automatically cancel the request and send the client an error.\n\n            If `auto_error` is set to `False`, when the query parameter is not\n            available, instead of erroring out, the dependency result will be\n            `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in a query\n            parameter or in an HTTP Bearer token).\n            \"\"\"\n        ),\n    ] = True,\n):\n    super().__init__(\n        location=APIKeyIn.query,\n        name=name,\n        scheme_name=scheme_name,\n        description=description,\n        auto_error=auto_error,\n    )",
      "language": "python"
    },
    {
      "code": "model = APIKey(\n    **{\"in\": location}, name=name, description=description\n)",
      "language": "json"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The WWW-Authenticate header is not standardized for API Key authentication but\n    the HTTP specification requires that an error of 401 \"Unauthorized\" must\n    include a WWW-Authenticate header.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\n\n    For this, this method sends a custom challenge `APIKey`.\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"APIKey\"},\n    )",
      "language": "python"
    },
    {
      "code": "check_api_key(api_key)",
      "language": "unknown"
    },
    {
      "code": "def check_api_key(self, api_key: Optional[str]) -> Optional[str]:\n    if not api_key:\n        if self.auto_error:\n            raise self.make_not_authenticated_error()\n        return None\n    return api_key",
      "language": "python"
    },
    {
      "code": "HTTPBasic(\n    *,\n    scheme_name=None,\n    realm=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\n\napp = FastAPI()\n\nsecurity = HTTPBasic()\n\n\n@app.get(\"/users/me\")\ndef read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):\n    return {\"username\": credentials.username, \"password\": credentials.password}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    realm: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            HTTP Basic authentication realm.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the HTTP Basic authentication is not provided (a\n            header), `HTTPBasic` will automatically cancel the request and send the\n            client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Basic authentication\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in HTTP Basic\n            authentication or in an HTTP Bearer token).\n            \"\"\"\n        ),\n    ] = True,\n):\n    self.model = HTTPBaseModel(scheme=\"basic\", description=description)\n    self.scheme_name = scheme_name or self.__class__.__name__\n    self.realm = realm\n    self.auto_error = auto_error",
      "language": "python"
    },
    {
      "code": "model = HTTPBase(scheme='basic', description=description)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "realm = realm",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers=self.make_authenticate_headers(),\n    )",
      "language": "python"
    },
    {
      "code": "make_authenticate_headers()",
      "language": "unknown"
    },
    {
      "code": "def make_authenticate_headers(self) -> dict[str, str]:\n    if self.realm:\n        return {\"WWW-Authenticate\": f'Basic realm=\"{self.realm}\"'}\n    return {\"WWW-Authenticate\": \"Basic\"}",
      "language": "python"
    },
    {
      "code": "HTTPBearer(\n    *,\n    bearerFormat=None,\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\n\napp = FastAPI()\n\nsecurity = HTTPBearer()\n\n\n@app.get(\"/users/me\")\ndef read_current_user(\n    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]\n):\n    return {\"scheme\": credentials.scheme, \"credentials\": credentials.credentials}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    bearerFormat: Annotated[Optional[str], Doc(\"Bearer token format.\")] = None,\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the HTTP Bearer token is not provided (in an\n            `Authorization` header), `HTTPBearer` will automatically cancel the\n            request and send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Bearer token\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in an HTTP\n            Bearer token or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n):\n    self.model = HTTPBearerModel(bearerFormat=bearerFormat, description=description)\n    self.scheme_name = scheme_name or self.__class__.__name__\n    self.auto_error = auto_error",
      "language": "python"
    },
    {
      "code": "model = HTTPBearer(\n    bearerFormat=bearerFormat, description=description\n)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_authenticate_headers()",
      "language": "unknown"
    },
    {
      "code": "def make_authenticate_headers(self) -> dict[str, str]:\n    return {\"WWW-Authenticate\": f\"{self.model.scheme.title()}\"}",
      "language": "python"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers=self.make_authenticate_headers(),\n    )",
      "language": "python"
    },
    {
      "code": "HTTPDigest(\n    *, scheme_name=None, description=None, auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPDigest\n\napp = FastAPI()\n\nsecurity = HTTPDigest()\n\n\n@app.get(\"/users/me\")\ndef read_current_user(\n    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]\n):\n    return {\"scheme\": credentials.scheme, \"credentials\": credentials.credentials}",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if the HTTP Digest is not provided, `HTTPDigest` will\n            automatically cancel the request and send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Digest is not\n            available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, in HTTP\n            Digest or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n):\n    self.model = HTTPBaseModel(scheme=\"digest\", description=description)\n    self.scheme_name = scheme_name or self.__class__.__name__\n    self.auto_error = auto_error",
      "language": "python"
    },
    {
      "code": "model = HTTPBase(scheme='digest', description=description)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_authenticate_headers()",
      "language": "unknown"
    },
    {
      "code": "def make_authenticate_headers(self) -> dict[str, str]:\n    return {\"WWW-Authenticate\": f\"{self.model.scheme.title()}\"}",
      "language": "python"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers=self.make_authenticate_headers(),\n    )",
      "language": "python"
    },
    {
      "code": "Authorization: Bearer deadbeef12346",
      "language": "yaml"
    },
    {
      "code": "credentials",
      "language": "unknown"
    },
    {
      "code": "OAuth2(\n    *,\n    flows=OAuthFlows(),\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    flows: Annotated[\n        Union[OAuthFlowsModel, dict[str, dict[str, Any]]],\n        Doc(\n            \"\"\"\n            The dictionary of OAuth2 flows.\n            \"\"\"\n        ),\n    ] = OAuthFlowsModel(),\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if no HTTP Authorization header is provided, required for\n            OAuth2 authentication, it will automatically cancel the request and\n            send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Authorization header\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, with OAuth2\n            or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n):\n    self.model = OAuth2Model(\n        flows=cast(OAuthFlowsModel, flows), description=description\n    )\n    self.scheme_name = scheme_name or self.__class__.__name__\n    self.auto_error = auto_error",
      "language": "python"
    },
    {
      "code": "model = OAuth2(\n    flows=cast(OAuthFlows, flows), description=description\n)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The OAuth 2 specification doesn't define the challenge that should be used,\n    because a `Bearer` token is not really the only option to authenticate.\n\n    But declaring any other authentication challenge would be application-specific\n    as it's not defined in the specification.\n\n    For practical reasons, this method uses the `Bearer` challenge by default, as\n    it's probably the most common one.\n\n    If you are implementing an OAuth2 authentication scheme other than the provided\n    ones in FastAPI (based on bearer tokens), you might want to override this.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc6749\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )",
      "language": "python"
    },
    {
      "code": "OAuth2AuthorizationCodeBearer(\n    authorizationUrl,\n    tokenUrl,\n    refreshUrl=None,\n    scheme_name=None,\n    scopes=None,\n    description=None,\n    auto_error=True,\n)",
      "language": "rust"
    },
    {
      "code": "def __init__(\n    self,\n    authorizationUrl: str,\n    tokenUrl: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL to obtain the OAuth2 token.\n            \"\"\"\n        ),\n    ],\n    refreshUrl: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            The URL to refresh the token and obtain a new one.\n            \"\"\"\n        ),\n    ] = None,\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    scopes: Annotated[\n        Optional[dict[str, str]],\n        Doc(\n            \"\"\"\n            The OAuth2 scopes that would be required by the *path operations* that\n            use this dependency.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if no HTTP Authorization header is provided, required for\n            OAuth2 authentication, it will automatically cancel the request and\n            send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Authorization header\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, with OAuth2\n            or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n):\n    if not scopes:\n        scopes = {}\n    flows = OAuthFlowsModel(\n        authorizationCode=cast(\n            Any,\n            {\n                \"authorizationUrl\": authorizationUrl,\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            },\n        )\n    )\n    super().__init__(\n        flows=flows,\n        scheme_name=scheme_name,\n        description=description,\n        auto_error=auto_error,\n    )",
      "language": "python"
    },
    {
      "code": "model = OAuth2(\n    flows=cast(OAuthFlows, flows), description=description\n)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The OAuth 2 specification doesn't define the challenge that should be used,\n    because a `Bearer` token is not really the only option to authenticate.\n\n    But declaring any other authentication challenge would be application-specific\n    as it's not defined in the specification.\n\n    For practical reasons, this method uses the `Bearer` challenge by default, as\n    it's probably the most common one.\n\n    If you are implementing an OAuth2 authentication scheme other than the provided\n    ones in FastAPI (based on bearer tokens), you might want to override this.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc6749\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )",
      "language": "python"
    },
    {
      "code": "OAuth2PasswordBearer(\n    tokenUrl,\n    scheme_name=None,\n    scopes=None,\n    description=None,\n    auto_error=True,\n    refreshUrl=None,\n)",
      "language": "rust"
    },
    {
      "code": "def __init__(\n    self,\n    tokenUrl: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL to obtain the OAuth2 token. This would be the *path operation*\n            that has `OAuth2PasswordRequestForm` as a dependency.\n            \"\"\"\n        ),\n    ],\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    scopes: Annotated[\n        Optional[dict[str, str]],\n        Doc(\n            \"\"\"\n            The OAuth2 scopes that would be required by the *path operations* that\n            use this dependency.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if no HTTP Authorization header is provided, required for\n            OAuth2 authentication, it will automatically cancel the request and\n            send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Authorization header\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, with OAuth2\n            or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n    refreshUrl: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            The URL to refresh the token and obtain a new one.\n            \"\"\"\n        ),\n    ] = None,\n):\n    if not scopes:\n        scopes = {}\n    flows = OAuthFlowsModel(\n        password=cast(\n            Any,\n            {\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            },\n        )\n    )\n    super().__init__(\n        flows=flows,\n        scheme_name=scheme_name,\n        description=description,\n        auto_error=auto_error,\n    )",
      "language": "python"
    },
    {
      "code": "model = OAuth2(\n    flows=cast(OAuthFlows, flows), description=description\n)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    \"\"\"\n    The OAuth 2 specification doesn't define the challenge that should be used,\n    because a `Bearer` token is not really the only option to authenticate.\n\n    But declaring any other authentication challenge would be application-specific\n    as it's not defined in the specification.\n\n    For practical reasons, this method uses the `Bearer` challenge by default, as\n    it's probably the most common one.\n\n    If you are implementing an OAuth2 authentication scheme other than the provided\n    ones in FastAPI (based on bearer tokens), you might want to override this.\n\n    Ref: https://datatracker.ietf.org/doc/html/rfc6749\n    \"\"\"\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )",
      "language": "python"
    },
    {
      "code": "OAuth2PasswordRequestForm(\n    *,\n    grant_type=None,\n    username,\n    password,\n    scope=\"\",\n    client_id=None,\n    client_secret=None\n)",
      "language": "rust"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordRequestForm\n\napp = FastAPI()\n\n\n@app.post(\"/login\")\ndef login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):\n    data = {}\n    data[\"scopes\"] = []\n    for scope in form_data.scopes:\n        data[\"scopes\"].append(scope)\n    if form_data.client_id:\n        data[\"client_id\"] = form_data.client_id\n    if form_data.client_secret:\n        data[\"client_secret\"] = form_data.client_secret\n    return data",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    grant_type: Annotated[\n        Union[str, None],\n        Form(pattern=\"^password$\"),\n        Doc(\n            \"\"\"\n            The OAuth2 spec says it is required and MUST be the fixed string\n            \"password\". Nevertheless, this dependency class is permissive and\n            allows not passing it. If you want to enforce it, use instead the\n            `OAuth2PasswordRequestFormStrict` dependency.\n            \"\"\"\n        ),\n    ] = None,\n    username: Annotated[\n        str,\n        Form(),\n        Doc(\n            \"\"\"\n            `username` string. The OAuth2 spec requires the exact field name\n            `username`.\n            \"\"\"\n        ),\n    ],\n    password: Annotated[\n        str,\n        Form(json_schema_extra={\"format\": \"password\"}),\n        Doc(\n            \"\"\"\n            `password` string. The OAuth2 spec requires the exact field name\n            `password`.\n            \"\"\"\n        ),\n    ],\n    scope: Annotated[\n        str,\n        Form(),\n        Doc(\n            \"\"\"\n            A single string with actually several scopes separated by spaces. Each\n            scope is also a string.\n\n            For example, a single string with:\n\n            ```python\n            \"items:read items:write users:read profile openid\"\n            ````\n\n            would represent the scopes:\n\n            * `items:read`\n            * `items:write`\n            * `users:read`\n            * `profile`\n            * `openid`\n            \"\"\"\n        ),\n    ] = \"\",\n    client_id: Annotated[\n        Union[str, None],\n        Form(),\n        Doc(\n            \"\"\"\n            If there's a `client_id`, it can be sent as part of the form fields.\n            But the OAuth2 specification recommends sending the `client_id` and\n            `client_secret` (if any) using HTTP Basic auth.\n            \"\"\"\n        ),\n    ] = None,\n    client_secret: Annotated[\n        Union[str, None],\n        Form(json_schema_extra={\"format\": \"password\"}),\n        Doc(\n            \"\"\"\n            If there's a `client_password` (and a `client_id`), they can be sent\n            as part of the form fields. But the OAuth2 specification recommends\n            sending the `client_id` and `client_secret` (if any) using HTTP Basic\n            auth.\n            \"\"\"\n        ),\n    ] = None,\n):\n    self.grant_type = grant_type\n    self.username = username\n    self.password = password\n    self.scopes = scope.split()\n    self.client_id = client_id\n    self.client_secret = client_secret",
      "language": "python"
    },
    {
      "code": "grant_type = grant_type",
      "language": "unknown"
    },
    {
      "code": "username = username",
      "language": "unknown"
    },
    {
      "code": "password = password",
      "language": "unknown"
    },
    {
      "code": "scopes = split()",
      "language": "unknown"
    },
    {
      "code": "client_id = client_id",
      "language": "unknown"
    },
    {
      "code": "client_secret = client_secret",
      "language": "unknown"
    },
    {
      "code": "OAuth2PasswordRequestFormStrict(\n    grant_type,\n    username,\n    password,\n    scope=\"\",\n    client_id=None,\n    client_secret=None,\n)",
      "language": "rust"
    },
    {
      "code": "from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordRequestForm\n\napp = FastAPI()\n\n\n@app.post(\"/login\")\ndef login(form_data: Annotated[OAuth2PasswordRequestFormStrict, Depends()]):\n    data = {}\n    data[\"scopes\"] = []\n    for scope in form_data.scopes:\n        data[\"scopes\"].append(scope)\n    if form_data.client_id:\n        data[\"client_id\"] = form_data.client_id\n    if form_data.client_secret:\n        data[\"client_secret\"] = form_data.client_secret\n    return data",
      "language": "python"
    },
    {
      "code": "def __init__(\n    self,\n    grant_type: Annotated[\n        str,\n        Form(pattern=\"^password$\"),\n        Doc(\n            \"\"\"\n            The OAuth2 spec says it is required and MUST be the fixed string\n            \"password\". This dependency is strict about it. If you want to be\n            permissive, use instead the `OAuth2PasswordRequestForm` dependency\n            class.\n            \"\"\"\n        ),\n    ],\n    username: Annotated[\n        str,\n        Form(),\n        Doc(\n            \"\"\"\n            `username` string. The OAuth2 spec requires the exact field name\n            `username`.\n            \"\"\"\n        ),\n    ],\n    password: Annotated[\n        str,\n        Form(),\n        Doc(\n            \"\"\"\n            `password` string. The OAuth2 spec requires the exact field name\n            `password`.\n            \"\"\"\n        ),\n    ],\n    scope: Annotated[\n        str,\n        Form(),\n        Doc(\n            \"\"\"\n            A single string with actually several scopes separated by spaces. Each\n            scope is also a string.\n\n            For example, a single string with:\n\n            ```python\n            \"items:read items:write users:read profile openid\"\n            ````\n\n            would represent the scopes:\n\n            * `items:read`\n            * `items:write`\n            * `users:read`\n            * `profile`\n            * `openid`\n            \"\"\"\n        ),\n    ] = \"\",\n    client_id: Annotated[\n        Union[str, None],\n        Form(),\n        Doc(\n            \"\"\"\n            If there's a `client_id`, it can be sent as part of the form fields.\n            But the OAuth2 specification recommends sending the `client_id` and\n            `client_secret` (if any) using HTTP Basic auth.\n            \"\"\"\n        ),\n    ] = None,\n    client_secret: Annotated[\n        Union[str, None],\n        Form(),\n        Doc(\n            \"\"\"\n            If there's a `client_password` (and a `client_id`), they can be sent\n            as part of the form fields. But the OAuth2 specification recommends\n            sending the `client_id` and `client_secret` (if any) using HTTP Basic\n            auth.\n            \"\"\"\n        ),\n    ] = None,\n):\n    super().__init__(\n        grant_type=grant_type,\n        username=username,\n        password=password,\n        scope=scope,\n        client_id=client_id,\n        client_secret=client_secret,\n    )",
      "language": "python"
    },
    {
      "code": "grant_type = grant_type",
      "language": "unknown"
    },
    {
      "code": "username = username",
      "language": "unknown"
    },
    {
      "code": "password = password",
      "language": "unknown"
    },
    {
      "code": "scopes = split()",
      "language": "unknown"
    },
    {
      "code": "client_id = client_id",
      "language": "unknown"
    },
    {
      "code": "client_secret = client_secret",
      "language": "unknown"
    },
    {
      "code": "SecurityScopes(scopes=None)",
      "language": "rust"
    },
    {
      "code": "def __init__(\n    self,\n    scopes: Annotated[\n        Optional[list[str]],\n        Doc(\n            \"\"\"\n            This will be filled by FastAPI.\n            \"\"\"\n        ),\n    ] = None,\n):\n    self.scopes: Annotated[\n        list[str],\n        Doc(\n            \"\"\"\n            The list of all the scopes required by dependencies.\n            \"\"\"\n        ),\n    ] = scopes or []\n    self.scope_str: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            All the scopes required by all the dependencies in a single string\n            separated by spaces, as defined in the OAuth2 specification.\n            \"\"\"\n        ),\n    ] = \" \".join(self.scopes)",
      "language": "python"
    },
    {
      "code": "scopes = scopes or []",
      "language": "unknown"
    },
    {
      "code": "scope_str = join(scopes)",
      "language": "unknown"
    },
    {
      "code": "OpenIdConnect(\n    *,\n    openIdConnectUrl,\n    scheme_name=None,\n    description=None,\n    auto_error=True\n)",
      "language": "rust"
    },
    {
      "code": "def __init__(\n    self,\n    *,\n    openIdConnectUrl: Annotated[\n        str,\n        Doc(\n            \"\"\"\n        The OpenID Connect URL.\n        \"\"\"\n        ),\n    ],\n    scheme_name: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme name.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Security scheme description.\n\n            It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    auto_error: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, if no HTTP Authorization header is provided, required for\n            OpenID Connect authentication, it will automatically cancel the request\n            and send the client an error.\n\n            If `auto_error` is set to `False`, when the HTTP Authorization header\n            is not available, instead of erroring out, the dependency result will\n            be `None`.\n\n            This is useful when you want to have optional authentication.\n\n            It is also useful when you want to have authentication that can be\n            provided in one of multiple optional ways (for example, with OpenID\n            Connect or in a cookie).\n            \"\"\"\n        ),\n    ] = True,\n):\n    self.model = OpenIdConnectModel(\n        openIdConnectUrl=openIdConnectUrl, description=description\n    )\n    self.scheme_name = scheme_name or self.__class__.__name__\n    self.auto_error = auto_error",
      "language": "python"
    },
    {
      "code": "model = OpenIdConnect(\n    openIdConnectUrl=openIdConnectUrl,\n    description=description,\n)",
      "language": "unknown"
    },
    {
      "code": "scheme_name = scheme_name or __name__",
      "language": "unknown"
    },
    {
      "code": "auto_error = auto_error",
      "language": "unknown"
    },
    {
      "code": "make_not_authenticated_error()",
      "language": "unknown"
    },
    {
      "code": "def make_not_authenticated_error(self) -> HTTPException:\n    return HTTPException(\n        status_code=HTTP_401_UNAUTHORIZED,\n        detail=\"Not authenticated\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://fastapi.tiangolo.com/reference/security/",
    "https://fastapi.tiangolo.com/reference/security/?q=",
    "https://fastapi.tiangolo.com/features/",
    "https://fastapi.tiangolo.com/reference/",
    "https://fastapi.tiangolo.com/python-types/",
    "https://fastapi.tiangolo.com/async/",
    "https://fastapi.tiangolo.com/environment-variables/",
    "https://fastapi.tiangolo.com/virtual-environments/",
    "https://fastapi.tiangolo.com/tutorial/",
    "https://fastapi.tiangolo.com/tutorial/first-steps/",
    "https://fastapi.tiangolo.com/tutorial/path-params/",
    "https://fastapi.tiangolo.com/tutorial/query-params/",
    "https://fastapi.tiangolo.com/tutorial/body/",
    "https://fastapi.tiangolo.com/tutorial/query-params-str-validations/",
    "https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/",
    "https://fastapi.tiangolo.com/tutorial/query-param-models/",
    "https://fastapi.tiangolo.com/tutorial/body-multiple-params/",
    "https://fastapi.tiangolo.com/tutorial/body-fields/",
    "https://fastapi.tiangolo.com/tutorial/body-nested-models/",
    "https://fastapi.tiangolo.com/tutorial/schema-extra-example/",
    "https://fastapi.tiangolo.com/tutorial/extra-data-types/",
    "https://fastapi.tiangolo.com/tutorial/cookie-params/",
    "https://fastapi.tiangolo.com/tutorial/header-params/",
    "https://fastapi.tiangolo.com/tutorial/cookie-param-models/",
    "https://fastapi.tiangolo.com/tutorial/header-param-models/",
    "https://fastapi.tiangolo.com/tutorial/response-model/",
    "https://fastapi.tiangolo.com/tutorial/extra-models/",
    "https://fastapi.tiangolo.com/tutorial/response-status-code/",
    "https://fastapi.tiangolo.com/tutorial/request-forms/",
    "https://fastapi.tiangolo.com/tutorial/request-form-models/",
    "https://fastapi.tiangolo.com/tutorial/request-files/",
    "https://fastapi.tiangolo.com/tutorial/request-forms-and-files/",
    "https://fastapi.tiangolo.com/tutorial/handling-errors/",
    "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/",
    "https://fastapi.tiangolo.com/tutorial/encoder/",
    "https://fastapi.tiangolo.com/tutorial/body-updates/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/",
    "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/",
    "https://fastapi.tiangolo.com/tutorial/security/",
    "https://fastapi.tiangolo.com/tutorial/security/first-steps/",
    "https://fastapi.tiangolo.com/tutorial/security/get-current-user/",
    "https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/",
    "https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/",
    "https://fastapi.tiangolo.com/tutorial/middleware/",
    "https://fastapi.tiangolo.com/tutorial/cors/",
    "https://fastapi.tiangolo.com/tutorial/sql-databases/",
    "https://fastapi.tiangolo.com/tutorial/bigger-applications/",
    "https://fastapi.tiangolo.com/tutorial/background-tasks/",
    "https://fastapi.tiangolo.com/tutorial/metadata/",
    "https://fastapi.tiangolo.com/tutorial/static-files/",
    "https://fastapi.tiangolo.com/tutorial/testing/",
    "https://fastapi.tiangolo.com/tutorial/debugging/",
    "https://fastapi.tiangolo.com/advanced/",
    "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
    "https://fastapi.tiangolo.com/advanced/additional-status-codes/",
    "https://fastapi.tiangolo.com/advanced/response-directly/",
    "https://fastapi.tiangolo.com/advanced/custom-response/",
    "https://fastapi.tiangolo.com/advanced/additional-responses/",
    "https://fastapi.tiangolo.com/advanced/response-cookies/",
    "https://fastapi.tiangolo.com/advanced/response-headers/",
    "https://fastapi.tiangolo.com/advanced/response-change-status-code/",
    "https://fastapi.tiangolo.com/advanced/advanced-dependencies/",
    "https://fastapi.tiangolo.com/advanced/security/",
    "https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/",
    "https://fastapi.tiangolo.com/advanced/security/http-basic-auth/",
    "https://fastapi.tiangolo.com/advanced/using-request-directly/",
    "https://fastapi.tiangolo.com/advanced/dataclasses/",
    "https://fastapi.tiangolo.com/advanced/middleware/",
    "https://fastapi.tiangolo.com/advanced/sub-applications/",
    "https://fastapi.tiangolo.com/advanced/behind-a-proxy/",
    "https://fastapi.tiangolo.com/advanced/templates/",
    "https://fastapi.tiangolo.com/advanced/websockets/",
    "https://fastapi.tiangolo.com/advanced/events/",
    "https://fastapi.tiangolo.com/advanced/testing-websockets/",
    "https://fastapi.tiangolo.com/advanced/testing-events/",
    "https://fastapi.tiangolo.com/advanced/testing-dependencies/",
    "https://fastapi.tiangolo.com/advanced/async-tests/",
    "https://fastapi.tiangolo.com/advanced/settings/",
    "https://fastapi.tiangolo.com/advanced/openapi-callbacks/",
    "https://fastapi.tiangolo.com/advanced/openapi-webhooks/",
    "https://fastapi.tiangolo.com/advanced/wsgi/",
    "https://fastapi.tiangolo.com/advanced/generate-clients/",
    "https://fastapi.tiangolo.com/fastapi-cli/",
    "https://fastapi.tiangolo.com/deployment/",
    "https://fastapi.tiangolo.com/deployment/versions/",
    "https://fastapi.tiangolo.com/deployment/fastapicloud/",
    "https://fastapi.tiangolo.com/deployment/https/",
    "https://fastapi.tiangolo.com/deployment/manually/",
    "https://fastapi.tiangolo.com/deployment/concepts/",
    "https://fastapi.tiangolo.com/deployment/cloud/",
    "https://fastapi.tiangolo.com/deployment/server-workers/",
    "https://fastapi.tiangolo.com/deployment/docker/",
    "https://fastapi.tiangolo.com/how-to/",
    "https://fastapi.tiangolo.com/how-to/general/",
    "https://fastapi.tiangolo.com/how-to/migrate-from-pydantic-v1-to-pydantic-v2/",
    "https://fastapi.tiangolo.com/how-to/graphql/",
    "https://fastapi.tiangolo.com/how-to/custom-request-and-route/",
    "https://fastapi.tiangolo.com/how-to/conditional-openapi/",
    "https://fastapi.tiangolo.com/how-to/extending-openapi/",
    "https://fastapi.tiangolo.com/how-to/separate-openapi-schemas/",
    "https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/",
    "https://fastapi.tiangolo.com/how-to/configure-swagger-ui/",
    "https://fastapi.tiangolo.com/how-to/testing-database/",
    "https://fastapi.tiangolo.com/how-to/authentication-error-status-code/",
    "https://fastapi.tiangolo.com/reference/fastapi/",
    "https://fastapi.tiangolo.com/reference/parameters/",
    "https://fastapi.tiangolo.com/reference/status/",
    "https://fastapi.tiangolo.com/reference/uploadfile/",
    "https://fastapi.tiangolo.com/reference/exceptions/",
    "https://fastapi.tiangolo.com/reference/dependencies/",
    "https://fastapi.tiangolo.com/reference/apirouter/",
    "https://fastapi.tiangolo.com/reference/background/",
    "https://fastapi.tiangolo.com/reference/request/",
    "https://fastapi.tiangolo.com/reference/websockets/",
    "https://fastapi.tiangolo.com/reference/httpconnection/",
    "https://fastapi.tiangolo.com/reference/response/",
    "https://fastapi.tiangolo.com/reference/responses/",
    "https://fastapi.tiangolo.com/reference/middleware/",
    "https://fastapi.tiangolo.com/reference/openapi/",
    "https://fastapi.tiangolo.com/reference/openapi/docs/",
    "https://fastapi.tiangolo.com/reference/openapi/models/",
    "https://fastapi.tiangolo.com/reference/encoders/",
    "https://fastapi.tiangolo.com/reference/staticfiles/",
    "https://fastapi.tiangolo.com/reference/templating/",
    "https://fastapi.tiangolo.com/reference/testclient/"
  ]
}