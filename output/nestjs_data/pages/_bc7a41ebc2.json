{
  "url": "https://docs.nestjs.com/pipes",
  "title": "",
  "content": "A pipe is a class annotated with the @Injectable() decorator, which implements the PipeTransform interface.\n\nPipes have two typical use cases:\n\nIn both cases, pipes operate on the arguments being processed by a controller route handler. Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments.\n\nNest comes with a number of built-in pipes that you can use out-of-the-box. You can also build your own custom pipes. In this chapter, we'll introduce the built-in pipes and show how to bind them to route handlers. We'll then examine several custom-built pipes to show how you can build one from scratch.\n\nNest comes with several pipes available out-of-the-box:\n\nThey're exported from the @nestjs/common package.\n\nLet's take a quick look at using ParseIntPipe. This is an example of the transformation use case, where the pipe ensures that a method handler parameter is converted to a JavaScript integer (or throws an exception if the conversion fails). Later in this chapter, we'll show a simple custom implementation for a ParseIntPipe. The example techniques below also apply to the other built-in transformation pipes (ParseBoolPipe, ParseFloatPipe, ParseEnumPipe, ParseArrayPipe, ParseDatePipe, and ParseUUIDPipe, which we'll refer to as the Parse* pipes in this chapter).\n\nTo use a pipe, we need to bind an instance of the pipe class to the appropriate context. In our ParseIntPipe example, we want to associate the pipe with a particular route handler method, and make sure it runs before the method is called. We do so with the following construct, which we'll refer to as binding the pipe at the method parameter level:\n\nThis ensures that one of the following two conditions is true: either the parameter we receive in the findOne() method is a number (as expected in our call to this.catsService.findOne()), or an exception is thrown before the route handler is called.\n\nFor example, assume the route is called like:\n\nNest will throw an exception like this:\n\nThe exception will prevent the body of the findOne() method from executing.\n\nIn the example above, we pass a class (ParseIntPipe), not an instance, leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and guards, we can instead pass an in-place instance. Passing an in-place instance is useful if we want to customize the built-in pipe's behavior by passing options:\n\nBinding the other transformation pipes (all of the Parse* pipes) works similarly. These pipes all work in the context of validating route parameters, query string parameters and request body values.\n\nFor example with a query string parameter:\n\nHere's an example of using the ParseUUIDPipe to parse a string parameter and validate if it is a UUID.\n\nAbove we've seen examples of binding the various Parse* family of built-in pipes. Binding validation pipes is a little bit different; we'll discuss that in the following section.\n\nAs mentioned, you can build your own custom pipes. While Nest provides a robust built-in ParseIntPipe and ValidationPipe, let's build simple custom versions of each from scratch to see how custom pipes are constructed.\n\nWe start with a simple ValidationPipe. Initially, we'll have it simply take an input value and immediately return the same value, behaving like an identity function.\n\nEvery pipe must implement the transform() method to fulfill the PipeTransform interface contract. This method has two parameters:\n\nThe value parameter is the currently processed method argument (before it is received by the route handling method), and metadata is the currently processed method argument's metadata. The metadata object has these properties:\n\nThese properties describe the currently processed argument.\n\nLet's make our validation pipe a little more useful. Take a closer look at the create() method of the CatsController, where we probably would like to ensure that the post body object is valid before attempting to run our service method.\n\nLet's focus in on the createCatDto body parameter. Its type is CreateCatDto:\n\nWe want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the createCatDto object. We could do this inside the route handler method, but doing so is not ideal as it would break the single responsibility principle (SRP).\n\nAnother approach could be to create a validator class and delegate the task there. This has the disadvantage that we would have to remember to call this validator at the beginning of each method.\n\nHow about creating validation middleware? This could work, but unfortunately, it's not possible to create generic middleware which can be used across all contexts across the whole application. This is because middleware is unaware of the execution context, including the handler that will be called and any of its parameters.\n\nThis is, of course, exactly the use case for which pipes are designed. So let's go ahead and refine our validation pipe.\n\nLearn the right way! 80+ chapters 5+ hours of videos Official certificate Deep-dive sessions Explore official courses\n\nThere are several approaches available for doing object validation in a clean, DRY way. One common approach is to use schema-based validation. Let's go ahead and try that approach.\n\nThe Zod library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Zod-based schemas.\n\nStart by installing the required package:\n\nIn the code sample below, we create a simple class that takes a schema as a constructor argument. We then apply the schema.parse() method, which validates our incoming argument against the provided schema.\n\nAs noted earlier, a validation pipe either returns the value unchanged or throws an exception.\n\nIn the next section, you'll see how we supply the appropriate schema for a given controller method using the @UsePipes() decorator. Doing so makes our validation pipe reusable across contexts, just as we set out to do.\n\nEarlier, we saw how to bind transformation pipes (like ParseIntPipe and the rest of the Parse* pipes).\n\nBinding validation pipes is also very straightforward.\n\nIn this case, we want to bind the pipe at the method call level. In our current example, we need to do the following to use the ZodValidationPipe:\n\nWe do that using the @UsePipes() decorator as shown below:\n\nLet's look at an alternate implementation for our validation technique.\n\nNest works well with the class-validator library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's Pipe capabilities since we have access to the metatype of the processed property. Before we start, we need to install the required packages:\n\nOnce these are installed, we can add a few decorators to the CreateCatDto class. Here we see a significant advantage of this technique: the CreateCatDto class remains the single source of truth for our Post body object (rather than having to create a separate validation class).\n\nNow we can create a ValidationPipe class that uses these annotations.\n\nLet's go through this code. First, note that the transform() method is marked as async. This is possible because Nest supports both synchronous and asynchronous pipes. We make this method async because some of the class-validator validations can be async (utilize Promises).\n\nNext note that we are using destructuring to extract the metatype field (extracting just this member from an ArgumentMetadata) into our metatype parameter. This is just shorthand for getting the full ArgumentMetadata and then having an additional statement to assign the metatype variable.\n\nNext, note the helper function toValidate(). It's responsible for bypassing the validation step when the current argument being processed is a native JavaScript type (these can't have validation decorators attached, so there's no reason to run them through the validation step).\n\nNext, we use the class-transformer function plainToInstance() to transform our plain JavaScript argument object into a typed object so that we can apply validation. The reason we must do this is that the incoming post body object, when deserialized from the network request, does not have any type information (this is the way the underlying platform, such as Express, works). Class-validator needs to use the validation decorators we defined for our DTO earlier, so we need to perform this transformation to treat the incoming body as an appropriately decorated object, not just a plain vanilla object.\n\nFinally, as noted earlier, since this is a validation pipe it either returns the value unchanged, or throws an exception.\n\nThe last step is to bind the ValidationPipe. Pipes can be parameter-scoped, method-scoped, controller-scoped, or global-scoped. Earlier, with our Zod-based validation pipe, we saw an example of binding the pipe at the method level. In the example below, we'll bind the pipe instance to the route handler @Body() decorator so that our pipe is called to validate the post body.\n\nParameter-scoped pipes are useful when the validation logic concerns only one specified parameter.\n\nSince the ValidationPipe was created to be as generic as possible, we can realize its full utility by setting it up as a global-scoped pipe so that it is applied to every route handler across the entire application.\n\nGlobal pipes are used across the whole application, for every controller and every route handler.\n\nNote that in terms of dependency injection, global pipes registered from outside of any module (with useGlobalPipes() as in the example above) cannot inject dependencies since the binding has been done outside the context of any module. In order to solve this issue, you can set up a global pipe directly from any module using the following construction:\n\nAs a reminder, you don't have to build a generic validation pipe on your own since the ValidationPipe is provided by Nest out-of-the-box. The built-in ValidationPipe offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples here.\n\nValidation isn't the only use case for custom pipes. At the beginning of this chapter, we mentioned that a pipe can also transform the input data to the desired format. This is possible because the value returned from the transform function completely overrides the previous value of the argument.\n\nWhen is this useful? Consider that sometimes the data passed from the client needs to undergo some change - for example converting a string to an integer - before it can be properly handled by the route handler method. Furthermore, some required data fields may be missing, and we would like to apply default values. Transformation pipes can perform these functions by interposing a processing function between the client request and the request handler.\n\nHere's a simple ParseIntPipe which is responsible for parsing a string into an integer value. (As noted above, Nest has a built-in ParseIntPipe that is more sophisticated; we include this as a simple example of a custom transformation pipe).\n\nWe can then bind this pipe to the selected param as shown below:\n\nAnother useful transformation case would be to select an existing user entity from the database using an id supplied in the request:\n\nWe leave the implementation of this pipe to the reader, but note that like all other transformation pipes, it receives an input value (an id) and returns an output value (a UserEntity object). This can make your code more declarative and DRY by abstracting boilerplate code out of your handler and into a common pipe.\n\nParse* pipes expect a parameter's value to be defined. They throw an exception upon receiving null or undefined values. To allow an endpoint to handle missing querystring parameter values, we have to provide a default value to be injected before the Parse* pipes operate on these values. The DefaultValuePipe serves that purpose. Simply instantiate a DefaultValuePipe in the @Query() decorator before the relevant Parse* pipe, as shown below:",
  "headings": [
    {
      "level": "h3",
      "text": "Pipes",
      "id": "pipes"
    },
    {
      "level": "h4",
      "text": "Built-in pipes#",
      "id": "built-in-pipes"
    },
    {
      "level": "h4",
      "text": "Binding pipes#",
      "id": "binding-pipes"
    },
    {
      "level": "h4",
      "text": "Custom pipes#",
      "id": "custom-pipes"
    },
    {
      "level": "h4",
      "text": "Schema based validation#",
      "id": "schema-based-validation"
    },
    {
      "level": "h2",
      "text": "Learn the right way!",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Object schema validation#",
      "id": "object-schema-validation"
    },
    {
      "level": "h4",
      "text": "Binding validation pipes#",
      "id": "binding-validation-pipes"
    },
    {
      "level": "h4",
      "text": "Class validator#",
      "id": "class-validator"
    },
    {
      "level": "h4",
      "text": "Global scoped pipes#",
      "id": "global-scoped-pipes"
    },
    {
      "level": "h4",
      "text": "The built-in ValidationPipe#",
      "id": "the-built-in-validationpipe"
    },
    {
      "level": "h4",
      "text": "Transformation use case#",
      "id": "transformation-use-case"
    },
    {
      "level": "h4",
      "text": "Providing defaults#",
      "id": "providing-defaults"
    }
  ],
  "code_samples": [
    {
      "code": "@Get(':id')\nasync findOne(@Param('id', ParseIntPipe) id: number) {\n  return this.catsService.findOne(id);\n}",
      "language": "typescript"
    },
    {
      "code": "GET localhost:3000/abc",
      "language": "bash"
    },
    {
      "code": "{\n  \"statusCode\": 400,\n  \"message\": \"Validation failed (numeric string is expected)\",\n  \"error\": \"Bad Request\"\n}",
      "language": "json"
    },
    {
      "code": "@Get(':id')\nasync findOne(\n  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))\n  id: number,\n) {\n  return this.catsService.findOne(id);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findOne(@Query('id', ParseIntPipe) id: number) {\n  return this.catsService.findOne(id);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':uuid')\nasync findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {\n  return this.catsService.findOne(uuid);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':uuid')\n@Bind(Param('uuid', new ParseUUIDPipe()))\nasync findOne(uuid) {\n  return this.catsService.findOne(uuid);\n}",
      "language": "typescript"
    },
    {
      "code": "import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    return value;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ValidationPipe {\n  transform(value, metadata) {\n    return value;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export interface ArgumentMetadata {\n  type: 'body' | 'query' | 'param' | 'custom';\n  metatype?: Type<unknown>;\n  data?: string;\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\nasync create(@Body() createCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "export class CreateCatDto {\n  name: string;\n  age: number;\n  breed: string;\n}",
      "language": "typescript"
    },
    {
      "code": "$ npm install --save zod",
      "language": "bash"
    },
    {
      "code": "import { PipeTransform, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { ZodSchema  } from 'zod';\n\nexport class ZodValidationPipe implements PipeTransform {\n  constructor(private schema: ZodSchema) {}\n\n  transform(value: unknown, metadata: ArgumentMetadata) {\n    try {\n      const parsedValue = this.schema.parse(value);\n      return parsedValue;\n    } catch (error) {\n      throw new BadRequestException('Validation failed');\n    }\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { BadRequestException } from '@nestjs/common';\n\nexport class ZodValidationPipe {\n  constructor(private schema) {}\n\n  transform(value, metadata) {\n    try {\n      const parsedValue = this.schema.parse(value);\n      return parsedValue;\n    } catch (error) {\n      throw new BadRequestException('Validation failed');\n    }\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { z } from 'zod';\n\nexport const createCatSchema = z\n  .object({\n    name: z.string(),\n    age: z.number(),\n    breed: z.string(),\n  })\n  .required();\n\nexport type CreateCatDto = z.infer<typeof createCatSchema>;",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@UsePipes(new ZodValidationPipe(createCatSchema))\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Bind(Body())\n@UsePipes(new ZodValidationPipe(createCatSchema))\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "$ npm i --save class-validator class-transformer",
      "language": "bash"
    },
    {
      "code": "import { IsString, IsInt } from 'class-validator';\n\nexport class CreateCatDto {\n  @IsString()\n  name: string;\n\n  @IsInt()\n  age: number;\n\n  @IsString()\n  breed: string;\n}",
      "language": "typescript"
    },
    {
      "code": "import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\nasync create(\n  @Body(new ValidationPipe()) createCatDto: CreateCatDto,\n) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "async function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(new ValidationPipe());\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { APP_PIPE } from '@nestjs/core';\n\n@Module({\n  providers: [\n    {\n      provide: APP_PIPE,\n      useClass: ValidationPipe,\n    },\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\n\n@Injectable()\nexport class ParseIntPipe implements PipeTransform<string, number> {\n  transform(value: string, metadata: ArgumentMetadata): number {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      throw new BadRequestException('Validation failed');\n    }\n    return val;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, BadRequestException } from '@nestjs/common';\n\n@Injectable()\nexport class ParseIntPipe {\n  transform(value, metadata) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      throw new BadRequestException('Validation failed');\n    }\n    return val;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\nasync findOne(@Param('id', new ParseIntPipe()) id) {\n  return this.catsService.findOne(id);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\n@Bind(Param('id', new ParseIntPipe()))\nasync findOne(id) {\n  return this.catsService.findOne(id);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\nfindOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {\n  return userEntity;\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\n@Bind(Param('id', UserByIdPipe))\nfindOne(userEntity) {\n  return userEntity;\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findAll(\n  @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,\n  @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,\n) {\n  return this.catsService.findAll({ activeOnly, page });\n}",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Pipes have two typical use cases:",
      "code": "arguments"
    },
    {
      "description": "Zod schema example:",
      "code": "import { z } from 'zod';\n\nexport const createCatSchema = z\n  .object({\n    name: z.string(),\n    age: z.number(),\n    breed: z.string(),\n  })\n  .required();\n\nexport type CreateCatDto = z.infer<typeof createCatSchema>;"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}