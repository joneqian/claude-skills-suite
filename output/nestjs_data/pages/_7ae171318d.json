{
  "url": "https://docs.nestjs.com/controllers",
  "title": "",
  "content": "Controllers are responsible for handling incoming requests and sending responses back to the client.\n\nA controller's purpose is to handle specific requests for the application. The routing mechanism determines which controller will handle each request. Often, a controller has multiple routes, and each route can perform a different action.\n\nTo create a basic controller, we use classes and decorators. Decorators link classes with the necessary metadata, allowing Nest to create a routing map that connects requests to their corresponding controllers.\n\nIn the following example, we’ll use the @Controller() decorator, which is required to define a basic controller. We'll specify an optional route path prefix of cats. Using a path prefix in the @Controller() decorator helps us group related routes together and reduces repetitive code. For example, if we want to group routes that manage interactions with a cat entity under the /cats path, we can specify the cats path prefix in the @Controller() decorator. This way, we don't need to repeat that portion of the path for each route in the file.\n\nThe @Get() HTTP request method decorator placed before the findAll() method tells Nest to create a handler for a specific endpoint for HTTP requests. This endpoint is defined by the HTTP request method (GET in this case) and the route path. So, what is the route path? The route path for a handler is determined by combining the (optional) prefix declared for the controller with any path specified in the method's decorator. Since we've set a prefix (cats) for every route and haven't added any specific path in the method decorator, Nest will map GET /cats requests to this handler.\n\nAs mentioned, the route path includes both the optional controller path prefix and any path string specified in the method's decorator. For example, if the controller prefix is cats and the method decorator is @Get('breed'), the resulting route will be GET /cats/breed.\n\nIn our example above, when a GET request is made to this endpoint, Nest routes the request to the user-defined findAll() method. Note that the method name we choose here is entirely arbitrary. While we must declare a method to bind the route to, Nest doesn’t attach any specific significance to the method name.\n\nThis method will return a 200 status code along with the associated response, which in this case is just a string. Why does this happen? To explain, we first need to introduce the concept that Nest uses two different options for manipulating responses:\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nHandlers often need access to the client’s request details. Nest provides access to the request object from the underlying platform (Express by default). You can access the request object by instructing Nest to inject it using the @Req() decorator in the handler’s signature.\n\nThe request object represents the HTTP request and contains properties for the query string, parameters, HTTP headers, and body (read more here). In most cases, you don't need to manually access these properties. Instead, you can use dedicated decorators like @Body() or @Query(), which are available out of the box. Below is a list of the provided decorators and the corresponding platform-specific objects they represent.\n\n* For compatibility with typings across underlying HTTP platforms (e.g., Express and Fastify), Nest provides @Res() and @Response() decorators. @Res() is simply an alias for @Response(). Both directly expose the underlying native platform response object interface. When using them, you should also import the typings for the underlying library (e.g., @types/express) to take full advantage. Note that when you inject either @Res() or @Response() in a method handler, you put Nest into Library-specific mode for that handler, and you become responsible for managing the response. When doing so, you must issue some kind of response by making a call on the response object (e.g., res.json(...) or res.send(...)), or the HTTP server will hang.\n\nEarlier, we defined an endpoint to fetch the cats resource (GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:\n\nIt's that simple. Nest provides decorators for all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), and @Head(). In addition, @All() defines an endpoint that handles all of them.\n\nPattern-based routes are also supported in NestJS. For example, the asterisk (*) can be used as a wildcard to match any combination of characters in a route at the end of a path. In the following example, the findAll() method will be executed for any route that starts with abcd/, regardless of the number of characters that follow.\n\nThe 'abcd/*' route path will match abcd/, abcd/123, abcd/abc, and so on. The hyphen ( -) and the dot (.) are interpreted literally by string-based paths.\n\nThis approach works on both Express and Fastify. However, with the latest release of Express (v5), the routing system has become more strict. In pure Express, you must use a named wildcard to make the route work—for example, abcd/*splat, where splat is simply the name of the wildcard parameter and has no special meaning. You can name it anything you like. That said, since Nest provides a compatibility layer for Express, you can still use the asterisk (*) as a wildcard.\n\nWhen it comes to asterisks used in the middle of a route, Express requires named wildcards (e.g., ab{*splat}cd), while Fastify does not support them at all.\n\nAs mentioned, the default status code for responses is always 200, except for POST requests, which default to 201. You can easily change this behavior by using the @HttpCode(...) decorator at the handler level.\n\nOften, your status code isn't static but depends on various factors. In that case, you can use a library-specific response (inject using @Res()) object (or, in case of an error, throw an exception).\n\nTo specify a custom response header, you can either use a @Header() decorator or a library-specific response object (and call res.header() directly).\n\nTo redirect a response to a specific URL, you can either use a @Redirect() decorator or a library-specific response object (and call res.redirect() directly).\n\n@Redirect() takes two arguments, url and statusCode, both are optional. The default value of statusCode is 302 (Found) if omitted.\n\nReturned values will override any arguments passed to the @Redirect() decorator. For example:\n\nRoutes with static paths won’t work when you need to accept dynamic data as part of the request (e.g., GET /cats/1 to get the cat with id 1). To define routes with parameters, you can add route parameter tokens in the route path to capture the dynamic values from the URL. The route parameter token in the @Get() decorator example below illustrates this approach. These route parameters can then be accessed using the @Param() decorator, which should be added to the method signature.\n\nThe @Param() decorator is used to decorate a method parameter (in the example above, params), making the route parameters accessible as properties of that decorated method parameter inside the method. As shown in the code, you can access the id parameter by referencing params.id. Alternatively, you can pass a specific parameter token to the decorator and directly reference the route parameter by name within the method body.\n\nThe @Controller decorator can take a host option to require that the HTTP host of the incoming requests matches some specific value.\n\nSimilar to a route path, the host option can use tokens to capture the dynamic value at that position in the host name. The host parameter token in the @Controller() decorator example below demonstrates this usage. Host parameters declared in this way can be accessed using the @HostParam() decorator, which should be added to the method signature.\n\nFor developers coming from other programming languages, it might be surprising to learn that in Nest, nearly everything is shared across incoming requests. This includes resources like the database connection pool, singleton services with global state, and more. It's important to understand that Node.js doesn't use the request/response Multi-Threaded Stateless Model, where each request is handled by a separate thread. As a result, using singleton instances in Nest is completely safe for our applications.\n\nThat said, there are specific edge cases where having request-based lifetimes for controllers may be necessary. Examples include per-request caching in GraphQL applications, request tracking, or implementing multi-tenancy. You can learn more about controlling injection scopes here.\n\nWe love modern JavaScript, especially its emphasis on asynchronous data handling. That’s why Nest fully supports async functions. Every async function must return a Promise, which allows you to return a deferred value that Nest can resolve automatically. Here's an example:\n\nThis code is perfectly valid. But Nest takes it a step further by allowing route handlers to return RxJS observable streams as well. Nest will handle the subscription internally and resolve the final emitted value once the stream completes.\n\nBoth approaches are valid, and you can choose the one that best suits your needs.\n\nIn our previous example, the POST route handler didn’t accept any client parameters. Let's fix that by adding the @Body() decorator.\n\nBefore we proceed (if you're using TypeScript), we need to define the DTO (Data Transfer Object) schema. A DTO is an object that specifies how data should be sent over the network. We could define the DTO schema using TypeScript interfaces or simple classes. However, we recommend using classes here. Why? Classes are part of the JavaScript ES6 standard, so they remain intact as real entities in the compiled JavaScript. In contrast, TypeScript interfaces are removed during transpilation, meaning Nest can't reference them at runtime. This is important because features like Pipes rely on having access to the metatype of variables at runtime, which is only possible with classes.\n\nLet's create the CreateCatDto class:\n\nIt has only three basic properties. Thereafter we can use the newly created DTO inside the CatsController:\n\nWhen handling query parameters in your routes, you can use the @Query() decorator to extract them from incoming requests. Let's see how this works in practice.\n\nConsider a route where we want to filter a list of cats based on query parameters like age and breed. First, define the query parameters in the CatsController:\n\nIn this example, the @Query() decorator is used to extract the values of age and breed from the query string. For example, a request to:\n\nwould result in age being 2 and breed being Persian.\n\nIf your application requires handling more complex query parameters, such as nested objects or arrays:\n\nyou'll need to configure your HTTP adapter (Express or Fastify) to use an appropriate query parser. In Express, you can use the extended parser, which allows for rich query objects:\n\nIn Fastify, you can use the querystringParser option:\n\nThere's a separate chapter about handling errors (i.e., working with exceptions) here.\n\nBelow is an example that demonstrates the use of several available decorators to create a basic controller. This controller provides a few methods to access and manipulate internal data.\n\nEven with the CatsController fully defined, Nest doesn't yet know about it and won't automatically create an instance of the class.\n\nControllers must always be part of a module, which is why we include the controllers array within the @Module() decorator. Since we haven’t defined any other modules apart from the root AppModule, we’ll use it to register the CatsController:\n\nWe attached the metadata to the module class using the @Module() decorator, and now Nest can easily determine which controllers need to be mounted.\n\nSo far, we've covered the standard Nest way of manipulating responses. Another approach is to use a library-specific response object. To inject a specific response object, we can use the @Res() decorator. To highlight the differences, let’s rewrite the CatsController like this:\n\nWhile this approach works and offers more flexibility by giving full control over the response object (such as header manipulation and access to library-specific features), it should be used with caution. Generally, this method is less clear and comes with some downsides. The main disadvantage is that your code becomes platform-dependent, as different underlying libraries may have different APIs for the response object. Additionally, it can make testing more challenging, as you'll need to mock the response object, among other things.\n\nFurthermore, by using this approach, you lose compatibility with Nest features that rely on standard response handling, such as Interceptors and the @HttpCode() / @Header() decorators. To address this, you can enable the passthrough option like this:\n\nWith this approach, you can interact with the native response object (for example, setting cookies or headers based on specific conditions), while still allowing the framework to handle the rest.",
  "headings": [
    {
      "level": "h3",
      "text": "Controllers",
      "id": "controllers"
    },
    {
      "level": "h4",
      "text": "Routing#",
      "id": "routing"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Request object#",
      "id": "request-object"
    },
    {
      "level": "h4",
      "text": "Resources#",
      "id": "resources"
    },
    {
      "level": "h4",
      "text": "Route wildcards#",
      "id": "route-wildcards"
    },
    {
      "level": "h4",
      "text": "Status code#",
      "id": "status-code"
    },
    {
      "level": "h4",
      "text": "Response headers#",
      "id": "response-headers"
    },
    {
      "level": "h4",
      "text": "Redirection#",
      "id": "redirection"
    },
    {
      "level": "h4",
      "text": "Route parameters#",
      "id": "route-parameters"
    },
    {
      "level": "h4",
      "text": "Sub-domain routing#",
      "id": "sub-domain-routing"
    },
    {
      "level": "h4",
      "text": "State sharing#",
      "id": "state-sharing"
    },
    {
      "level": "h4",
      "text": "Asynchronicity#",
      "id": "asynchronicity"
    },
    {
      "level": "h4",
      "text": "Request payloads#",
      "id": "request-payloads"
    },
    {
      "level": "h4",
      "text": "Query parameters#",
      "id": "query-parameters"
    },
    {
      "level": "h4",
      "text": "Handling errors#",
      "id": "handling-errors"
    },
    {
      "level": "h4",
      "text": "Full resource sample#",
      "id": "full-resource-sample"
    },
    {
      "level": "h4",
      "text": "Getting up and running#",
      "id": "getting-up-and-running"
    },
    {
      "level": "h4",
      "text": "Library-specific approach#",
      "id": "library-specific-approach"
    }
  ],
  "code_samples": [
    {
      "code": "import { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll() {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Req } from '@nestjs/common';\nimport type { Request } from 'express';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(@Req() request: Request): string {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Bind, Get, Req } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  @Bind(Req())\n  findAll(request) {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Post } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(): string {\n    return 'This action adds a new cat';\n  }\n\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Post } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create() {\n    return 'This action adds a new cat';\n  }\n\n  @Get()\n  findAll() {\n    return 'This action returns all cats';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get('abcd/*')\nfindAll() {\n  return 'This route uses a wildcard';\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@HttpCode(204)\ncreate() {\n  return 'This action adds a new cat';\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Header('Cache-Control', 'no-store')\ncreate() {\n  return 'This action adds a new cat';\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\n@Redirect('https://nestjs.com', 301)",
      "language": "typescript"
    },
    {
      "code": "@Get('docs')\n@Redirect('https://docs.nestjs.com', 302)\ngetDocs(@Query('version') version) {\n  if (version && version === '5') {\n    return { url: 'https://docs.nestjs.com/v5/' };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\nfindOne(@Param() params: any): string {\n  console.log(params.id);\n  return `This action returns a #${params.id} cat`;\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\n@Bind(Param())\nfindOne(params) {\n  console.log(params.id);\n  return `This action returns a #${params.id} cat`;\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\nfindOne(@Param('id') id: string): string {\n  return `This action returns a #${id} cat`;\n}",
      "language": "typescript"
    },
    {
      "code": "@Get(':id')\n@Bind(Param('id'))\nfindOne(id) {\n  return `This action returns a #${id} cat`;\n}",
      "language": "typescript"
    },
    {
      "code": "@Controller({ host: 'admin.example.com' })\nexport class AdminController {\n  @Get()\n  index(): string {\n    return 'Admin page';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Controller({ host: ':account.example.com' })\nexport class AccountController {\n  @Get()\n  getInfo(@HostParam('account') account: string) {\n    return account;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findAll(): Promise<any[]> {\n  return [];\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findAll() {\n  return [];\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nfindAll(): Observable<any[]> {\n  return of([]);\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nfindAll() {\n  return of([]);\n}",
      "language": "typescript"
    },
    {
      "code": "export class CreateCatDto {\n  name: string;\n  age: number;\n  breed: string;\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\nasync create(@Body() createCatDto: CreateCatDto) {\n  return 'This action adds a new cat';\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Bind(Body())\nasync create(createCatDto) {\n  return 'This action adds a new cat';\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nasync findAll(@Query('age') age: number, @Query('breed') breed: string) {\n  return `This action returns all cats filtered by age: ${age} and breed: ${breed}`;\n}",
      "language": "typescript"
    },
    {
      "code": "GET /cats?age=2&breed=Persian",
      "language": "unknown"
    },
    {
      "code": "?filter[where][name]=John&filter[where][age]=30\n?item[]=1&item[]=2",
      "language": "unknown"
    },
    {
      "code": "const app = await NestFactory.create<NestExpressApplication>(AppModule);\napp.set('query parser', 'extended');",
      "language": "typescript"
    },
    {
      "code": "const app = await NestFactory.create<NestFastifyApplication>(\n  AppModule,\n  new FastifyAdapter({\n    querystringParser: (str) => qs.parse(str),\n  }),\n);",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common';\nimport { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(@Body() createCatDto: CreateCatDto) {\n    return 'This action adds a new cat';\n  }\n\n  @Get()\n  findAll(@Query() query: ListAllEntities) {\n    return `This action returns all cats (limit: ${query.limit} items)`;\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return `This action returns a #${id} cat`;\n  }\n\n  @Put(':id')\n  update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {\n    return `This action updates a #${id} cat`;\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return `This action removes a #${id} cat`;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Query, Post, Body, Put, Param, Delete, Bind } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  @Bind(Body())\n  create(createCatDto) {\n    return 'This action adds a new cat';\n  }\n\n  @Get()\n  @Bind(Query())\n  findAll(query) {\n    console.log(query);\n    return `This action returns all cats (limit: ${query.limit} items)`;\n  }\n\n  @Get(':id')\n  @Bind(Param('id'))\n  findOne(id) {\n    return `This action returns a #${id} cat`;\n  }\n\n  @Put(':id')\n  @Bind(Param('id'), Body())\n  update(id, updateCatDto) {\n    return `This action updates a #${id} cat`;\n  }\n\n  @Delete(':id')\n  @Bind(Param('id'))\n  remove(id) {\n    return `This action removes a #${id} cat`;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\n\n@Module({\n  controllers: [CatsController],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';\nimport { Response } from 'express';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(@Res() res: Response) {\n    res.status(HttpStatus.CREATED).send();\n  }\n\n  @Get()\n  findAll(@Res() res: Response) {\n     res.status(HttpStatus.OK).json([]);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Post, Bind, Res, Body, HttpStatus } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  @Bind(Res(), Body())\n  create(res, createCatDto) {\n    res.status(HttpStatus.CREATED).send();\n  }\n\n  @Get()\n  @Bind(Res())\n  findAll(res) {\n     res.status(HttpStatus.OK).json([]);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\nfindAll(@Res({ passthrough: true }) res: Response) {\n  res.status(HttpStatus.OK);\n  return [];\n}",
      "language": "typescript"
    },
    {
      "code": "@Get()\n@Bind(Res({ passthrough: true }))\nfindAll(res) {\n  res.status(HttpStatus.OK);\n  return [];\n}",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Returned values will override any arguments passed to the @Redirect() decorator. For example:",
      "code": "@Redirect()"
    },
    {
      "description": "We love modern JavaScript, especially its emphasis on asynchronous data handling. That’s why Nest fully supports async functions. Every async function must return a Promise, which allows you to return a deferred value that Nest can resolve automatically. Here's an example:",
      "code": "async"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}