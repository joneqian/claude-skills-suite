# Framework

*175 pages in this category*

## Table of Contents

1. [微信开放文档 / 开发](#1-微信开放文档-/-开发)
2. [性能与体验 / 概述](#2-性能与体验-/-概述)
3. [自定义组件 / 单元测试](#3-自定义组件-/-单元测试)
4. [自定义组件 / 查看自定义组件数据](#4-自定义组件-/-查看自定义组件数据)
5. [基础能力 / 网络 / 使用说明](#5-基础能力-/-网络-/-使用说明)
6. [开放能力 / 用户信息 / 开放数据校验与解密](#6-开放能力-/-用户信息-/-开放数据校验与解密)
7. [性能与体验 / 体验评分 / 评分方法与规则 / 评分方法](#7-性能与体验-/-体验评分-/-评分方法与规则-/-评分方法)
8. [连接硬件能力 / 需要帮助](#8-连接硬件能力-/-需要帮助)
9. [小程序基础库 / v3.x版本](#9-小程序基础库-/-v3.x版本)
10. [Skyline 渲染引擎 / 增强特性 / 滚动容器及其应用场景](#10-skyline-渲染引擎-/-增强特性-/-滚动容器及其应用)
11. [开放能力 / 附近的小程序](#11-开放能力-/-附近的小程序)
12. [开放能力 / 音视频通话 / 双人音视频对话](#12-开放能力-/-音视频通话-/-双人音视频对话)
13. [基础能力 / AI/AR / VisionKit 视觉能力 / Marker AR](#13-基础能力-/-ai/ar-/-visionkit-视觉能力-)
14. [开放能力 / 用户信息 / 获取头像昵称](#14-开放能力-/-用户信息-/-获取头像昵称)
15. [连接硬件能力 / 设备消息](#15-连接硬件能力-/-设备消息)
16. [自定义组件 / 纯数据字段](#16-自定义组件-/-纯数据字段)
17. [基础能力 / 网络 / 移动解析HttpDNS](#17-基础能力-/-网络-/-移动解析httpdns)
18. [小程序框架 / 视图层 / WXSS](#18-小程序框架-/-视图层-/-wxss)
19. [开放能力 / 广告 / 格子广告](#19-开放能力-/-广告-/-格子广告)
20. [开放能力 / 消息 / 客服消息 / 概述](#20-开放能力-/-消息-/-客服消息-/-概述)
21. [插件 / 插件功能页 / 支付功能页](#21-插件-/-插件功能页-/-支付功能页)
22. [Skyline 渲染引擎 / 从 WebView 迁移 / 迁移工具](#22-skyline-渲染引擎-/-从-webview-迁移-/-)
23. [自定义组件 / 数据监听器](#23-自定义组件-/-数据监听器)
24. [连接硬件能力 / 音视频通话+摄像头（for 硬件） / VoIP 通话插件 / 接口文档 / onVoipEvent](#24-连接硬件能力-/-音视频通话+摄像头（for-硬件）-/-v)
25. [开放能力 / 用户信息 / UnionID 机制说明](#25-开放能力-/-用户信息-/-unionid-机制说明)
26. [插件 / 插件调用 API 的限制](#26-插件-/-插件调用-api-的限制)
27. [小程序框架 / 逻辑层 / 注册小程序](#27-小程序框架-/-逻辑层-/-注册小程序)
28. [开放能力 / 数据分析](#28-开放能力-/-数据分析)
29. [开放能力 / 广告 / 原生模板广告](#29-开放能力-/-广告-/-原生模板广告)
30. [开放能力 / 用户信息 / 生物认证](#30-开放能力-/-用户信息-/-生物认证)
31. [开放能力 / 视频号 / 视频号主页](#31-开放能力-/-视频号-/-视频号主页)
32. [开放能力 / 获取小程序链接 / 获取 URL Link](#32-开放能力-/-获取小程序链接-/-获取-url-link)
33. [开放能力 / 打开 App](#33-开放能力-/-打开-app)
34. [小程序框架 / 视图层 / WXML](#34-小程序框架-/-视图层-/-wxml)
35. [Skyline 渲染引擎 / 支持与差异 / WXSS 样式](#35-skyline-渲染引擎-/-支持与差异-/-wxss-样式)
36. [自定义组件 / 自定义组件扩展](#36-自定义组件-/-自定义组件扩展)
37. [基础能力 / AI/AR / VisionKit 视觉能力 / 身份证检测](#37-基础能力-/-ai/ar-/-visionkit-视觉能力-)
38. [基础能力 / 分包加载 / 独立分包](#38-基础能力-/-分包加载-/-独立分包)
39. [调试 / Source Map](#39-调试-/-source-map)
40. [性能与体验 / 调试工具 / 性能面板](#40-性能与体验-/-调试工具-/-性能面板)
41. [小程序运行时 / 更新机制](#41-小程序运行时-/-更新机制)
42. [开放能力 / 获取小程序码](#42-开放能力-/-获取小程序码)
43. [开放能力 / 消息 / 订阅消息](#43-开放能力-/-消息-/-订阅消息)
44. [性能与体验 / 弱网体验优化](#44-性能与体验-/-弱网体验优化)
45. [小程序框架 / 视图层 / 基础组件](#45-小程序框架-/-视图层-/-基础组件)
46. [连接硬件能力 / 音视频通话+摄像头（for 硬件） / 用户授权设备](#46-连接硬件能力-/-音视频通话+摄像头（for-硬件）-/-用)
47. [glass-easel 组件框架 / 新增特性 / Chaining API](#47-glass-easel-组件框架-/-新增特性-/-chai)
48. [性能与体验 / 运行时性能 / 概述](#48-性能与体验-/-运行时性能-/-概述)
49. [小程序框架 / 视图层 / WXS](#49-小程序框架-/-视图层-/-wxs)
50. [开放能力 / 转发 / 小程序私密消息](#50-开放能力-/-转发-/-小程序私密消息)

---

## 1. 微信开放文档 / 开发

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/](https://developers.weixin.qq.com/miniprogram/dev/framework/)

微信开放文档 /开发
开发指南

小程序提供了一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者在微信中开发具有原生 APP 体验的服务。

本章分主题的介绍了小程序的开发语言、框架、能力、调试等内容，帮助开发者快速全面的了解小程序开发的方方面面。

想要更具体了解关于框架、组件、API的详细内容，请参考对应的参考文档：

小程序框架参考文档
小程序组件参考文档
小程序 API 参考文档
小程序服务端 API 参考文档
微信开发者工具参考文档
微信云托管参考文档
微信云开发参考文档
官方教程 · 小程序开发起步
学习 5 节课程，从 0 至 1 做第一个属于你的小程序，深入浅出了解小程序开发。本系列视频，由腾讯课堂 NEXT 学院、微信学堂联合出品。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 2. 性能与体验 / 概述

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/performance/](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/)

性能与体验 /概述
性能与体验

为什么要进行性能优化

小程序的性能和用户的体验之间的关系密不可分。在使用小程序的过程中，用户有时会遇到小程序打开慢、滑动卡顿、响应慢等问题，这些问题都与小程序的性能有关。性能问题归根到底就是用户体验的问题，如果不能得到很好的解决，会影响用户的正常使用，甚至退出小程序。

随着小程序的迭代，页面越来越多，功能越来越复杂，小程序的性能问题也越来越突出。在开发小程序的过程中，开发者不仅应该关注功能的实现，还应该将足够的精力投入到小程序性能的优化上，保障良好的用户体验。

如何进行性能优化

广义上讲，小程序的性能又可以分为「启动性能」和「运行时性能」两个主题。「启动性能」让用户能够更快的打开并看到小程序的内容，「运行时性能」保障用户能够流畅的使用小程序的功能。除了本身的功能之外，良好性能带来的良好用户体验，也是小程序能够留住用户的关键。

小程序的框架结合了 Web 开发和客户端开发的技术，并进行了进一步的创新。因此，一些 Web 开发中性能优化的方法同样适用于小程序，比如缓存的使用、网络请求的优化、代码压缩等等。此外，由于小程序技术框架的特点，小程序开发中也有一些特殊的性能优化方法。

在进行性能优化时，开发者可以参考本章节中的优化指引，并借助小程序提供的一些调试工具和性能数据。

官方教程 · 小程序性能优化实践
小程序性能优化课程基于实际开发场景，由资深开发者分享小程序性能优化的各项能力及应用实践，提升小程序性能表现，满足用户体验。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 3. 自定义组件 / 单元测试

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html)

自定义组件 /单元测试
单元测试

在编写高质量的自定义组件过程中，单元测试是永远避不开的一个话题。完善的测试用例是提高自定义组件可用性的保证，同时测试代码覆盖率也是必不可少的一个环节。小程序从基础库版本 2.2.1 开始拥抱开源，支持使用 npm 安装自定义组件，那针对自定义组件的单元测试也是必须支持的。

以下就来介绍如何对自定义组件进行单元测试。

测试框架

现在市面上流行的测试框架均可使用，只要它能兼顾 nodejs 端和 dom 环境。因为我们需要依赖到 nodejs 的一些库来完善测试环境，同时 dom 环境也是必须的，因为我们需要建成完整的 dom 树结构，才能更好的模拟自定义组件的运行。例如可以选用 mocha + jsdom 的组合，亦可选用 jest，下述例子选用 jest 作为测试框架来说明。

自定义组件测试工具集

小程序的运行环境比较特殊，不同于常见的浏览器环境，它采用的是双线程的架构。而在进行单元测试时，我们并不需要用到这样复杂的架构带来的利好，我们进行的是功能测试而无需苛求性能、安全等因素，因此我们提供了一个测试工具集以支持自定义组件在 nodejs 单线程中也能运行起来。

我们先安装一下测试工具集——miniprogram-simulate：

npm i --save-dev miniprogram-simulate

编写测试用例

假设我们有如下自定义组件：

<!-- /components/index.wmxl -->
<view class="index">{{prop}}</view>

// /components/index.js
Component({
  properties: {
    prop: {
      type: String,
      value: 'index.properties'
    },
  },
})

/* /components/index.wxss */
.index {
  color: green;
}


我们想要测试渲染的结果，可以按照如下方式编写测试用例：

// /test/components/index.test.js
const simulate = require('miniprogram-simulate')

test('components/index', () => {
    const id = simulate.load('/components/index') // 此处必须传入绝对路径
    const comp = simulate.render(id) // 渲染成自定义组件树实例

    const parent = document.createElement('parent-wrapper') // 创建父亲节点
    comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子

    const view = comp.querySelector('.index') // 获取子组件 view
    expect(view.dom.innerHTML).toBe('index.properties') // 测试渲染结果
    expect(window.getComputedStyle(view.dom).color).toBe('green') // 测试渲染结果
})


PS：测试工具集中的 wx 对象和内置组件都不会实现真正的功能，如果需要测试一些特殊场景的话，可以自行覆盖掉测试工具集中的 api 接口和内置组件。

PS：目前因为有部分自定义组件功能仍未支持（如抽象节点等），故测试工具暂无法全部覆盖自定义组件的特性，后续会继续完善。

测试工具集中提供了一些方便测试的接口，比如：

模拟 touch 事件、自定义事件触发
选取子节点
更新自定义组件数据
触发生命周期
...

更多详细的用法可以参阅 github 仓库上的文档。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```text
npm i --save-dev miniprogram-simulate

```

```html
<!-- /components/index.wmxl -->
<view class="index">{{prop}}</view>

```

```js
// /components/index.js
Component({
  properties: {
    prop: {
      type: String,
      value: 'index.properties'
    },
  },
})

```

---

## 4. 自定义组件 / 查看自定义组件数据

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/debug.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/debug.html)

自定义组件 /查看自定义组件数据
调试自定义组件

wxml 面板中可以查看自定义组件在渲染时的 Data 数据。 在 wxml 中先选中需要查看的自定义组件，然后切换到 Component Data 即可实时查看当前自定义组件的数据

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 5. 基础能力 / 网络 / 使用说明

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)

基础能力 /网络 /使用说明
网络

在小程序/小游戏中使用网络相关的 API 时，需要注意下列问题，请开发者提前了解。

1. 服务器域名配置

每个微信小程序需要事先设置通讯域名，小程序只可以跟指定的域名进行网络通信。包括普通 HTTPS 请求（wx.request）、上传文件（wx.uploadFile）、下载文件（wx.downloadFile) 和 WebSocket 通信（wx.connectSocket）。

从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意 不允许与本机 IP 通信。

从 2.7.0 开始，提供了 UDP 通信（wx.createUDPSocket)。

从 2.18.0 开始，提供了 TCP 连接（wx.createTCPSocket)，只允许与同个局域网内的非本机 IP 以及配置过的服务器域名通信。

如使用微信云托管作为后端服务，则可无需配置通讯域名（在小程序内通过callContainer和connectContainer通过微信私有协议向云托管服务发起 HTTPS 调用和 WebSocket 通信）。

配置流程

服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：

域名只支持 https (wx.request、wx.uploadFile、wx.downloadFile) 和 wss (wx.connectSocket) 协议；
域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；
对于 https 域名，可以配置端口，如 https://myserver.com:8080，但是配置后只能向 https://myserver.com:8080 发起请求。如果向 https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。如果不配置端口。如 https://myserver.com，那么请求的 URL 中也不能包含端口，甚至是默认的 443 端口也不可以。如果向 https://myserver.com:443 请求则会失败。
对于 wss 域名，无需配置端口，默认允许请求该域名下所有端口。
域名必须经过 ICP 备案；
出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，相关API也不能在小程序内调用。 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 getAccessToken 接口获取 access_token，并调用相关 API；
不支持配置父域名，使用子域名。
2. DNS预解析域名

微信客户端 iOS 8.0.24，Android 8.0.23）开始支持。

小程序一般会依赖一些网络请求（如逻辑层的wx.request、渲染层的图片等网络资源），优化请求速度将会提升用户体验，而网络请求耗时中就包括DNS解析。DNS预解析域名，是框架提供的一种在小程序启动时，提前解析业务域名的技术。

配置流程

DNS域名配置请求「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：

预解析域名无需填写协议头
预解析域名最多可添加 5 个
其他安全策略同服务器域名配置策略
3. 网络请求
超时时间
默认超时时间是 60s；
超时时间可以在 app.json 或 game.json 中通过 networktimeout 配置
也可以在接口调用时指定超时时间，如 wx.request({ timeout: 5000 })，单位为ms。接口调用的timeout配置优先级高于app.json中的配置
使用限制
网络请求的 referer header 不可设置。其格式固定为 https://servicewechat.com/{appid}/{version}/page-frame.html，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个；
wx.connectSocket 的最大并发限制是 5 个。
小程序进入后台运行后，如果 5s 内网络请求没有结束，会回调错误信息 fail interrupted；在回到前台之前，网络请求接口调用都会无法调用。
返回值编码
建议服务器返回值使用 UTF-8 编码。对于非 UTF-8 编码，小程序会尝试进行转换，但是会有转换失败的可能。
小程序会自动对 BOM 头进行过滤（只过滤一个BOM头）。
回调函数
只要成功接收到服务器返回，无论 statusCode 是多少，都会进入 success 回调。请开发者根据业务逻辑对返回值进行判断。
4. 常见问题
HTTPS 证书

小程序必须使用 HTTPS/WSS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

对证书要求如下：

HTTPS 证书必须有效；
证书必须被系统信任，即根证书已被系统内置
部署 SSL 证书的网站域名必须与证书颁发的域名一致
证书必须在有效期内
证书的信任链必需完整（需要服务器配置）
iOS 不支持自签名证书;
iOS 下证书必须满足苹果 App Transport Security (ATS) 的要求;
TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
部分 CA 可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。
Chrome 56/57 内核对 WoSign、StartCom 证书限制周知

证书有效性可以使用 openssl s_client -connect example.com:443 命令验证，也可以使用其他在线工具。

除了网络请求 API 外，小程序中其他 HTTPS 请求如果出现异常，也请按上述流程进行检查。如 https 的图片无法加载、音视频无法播放等。

跳过域名校验

在微信开发者工具中，可以临时开启 开发环境不校验请求域名、TLS版本及HTTPS证书 选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。

如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求” 的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。

海外用户请求加速

对于海外用户，可通过在海外也部署接入点来提速，可参考接入 腾讯云全球应用加速服务 或其他同类产品。

... (content truncated)

---

## 6. 开放能力 / 用户信息 / 开放数据校验与解密

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)

开放能力 /用户信息 /开放数据校验与解密
服务端获取开放数据

小程序可以通过各种前端接口获取微信提供的开放数据。考虑到开发者服务端也需要获取这些开放数据，微信提供了两种获取方式：

方式一：开发者后台校验与解密开放数据
方式二：云调用直接获取开放数据（云开发）

方式一：开发者后台校验与解密开放数据

微信会对这些开放数据做签名和加密处理。开发者后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。

签名校验以及数据加解密涉及用户的会话密钥 session_key。 开发者应该事先通过 wx.login 登录流程获取会话密钥 session_key 并保存在服务器。为了数据不被篡改，开发者不应该把 session_key 传到小程序客户端等服务器外的环境。

数据签名校验

为了确保开放接口返回用户数据的安全性，微信会对明文数据进行签名。开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。

通过调用接口（如 wx.getUserInfo）获取数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )
开发者将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。

如 wx.getUserInfo的数据校验：

接口返回的rawData：

{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}


用户的 session-key：

HyVFkGl5F5OQWJZZaNzBBg==


用于签名的字符串为：

{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==


使用sha1得到的结果为

75e81ceda165f4ffa64f4068af58c64b8f54b88c

加密数据解密算法

接口如果涉及敏感数据（如wx.getUserInfo当中的 openId 和 unionId），接口的明文内容将不包含这些敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据(encryptedData) 进行对称解密。 解密算法如下：

对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
对称解密的目标密文为 Base64_Decode(encryptedData)。
对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。

微信官方提供了多种编程语言的示例代码（（点击下载）。每种语言类型的接口名字均一致。调用方式可以参照示例。

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )

watermark参数说明：

参数	类型	说明
appid	String	敏感数据归属 appId，开发者可校验此参数与自身 appId 是否一致
timestamp	Int	敏感数据获取的时间戳, 开发者可以用于数据时效性校验

如接口 wx.getUserInfo 敏感数据当中的 watermark：

{
    "openId": "OPENID",
    "nickName": "NICKNAME",
    "gender": GENDER,
    "city": "CITY",
    "province": "PROVINCE",
    "country": "COUNTRY",
    "avatarUrl": "AVATARURL",
    "unionId": "UNIONID",
    "watermark":
    {
        "appid":"APPID",
        "timestamp":TIMESTAMP
    }
}


注：

解密后得到的json数据根据需求可能会增加新的字段，旧字段不会改变和删减，开发者需要预留足够的空间
会话密钥 session_key 有效性

开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。

wx.login 调用时，用户的 session_key 可能会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 wx.login，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 wx.login，及时通过 code2Session 接口更新服务器存储的 session_key。
微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。
开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 wx.checkSession可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。
当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。

方式二：云调用直接获取开放数据

接口如果涉及敏感数据（如wx.getWeRunData），接口的明文内容将不包含这些敏感数据，而是在返回的接口中包含对应敏感数据的 cloudID 字段，数据可以通过云函数获取。完整流程如下：

1. 获取 cloudID

使用 2.7.0 或以上版本的基础库，如果小程序已开通云开发，在开放数据接口的返回值中可以通过 cloudID 字段获取（与 encrypte

... (content truncated)

```json
{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}

```

```text
HyVFkGl5F5OQWJZZaNzBBg==

```

```text
{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==

```

---

## 7. 性能与体验 / 体验评分 / 评分方法与规则 / 评分方法

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/audits/scoring.html](https://developers.weixin.qq.com/miniprogram/dev/framework/audits/scoring.html)

性能与体验 /体验评分 /评分方法与规则 /评分方法
评分方法

目前体验评分共有27条规则，共分为三类：性能、体验、最佳实践，满足规则要求得分（100分），否则不得分（0分），最后根据各规则权重和公式计算出总得分。

权重为0的规则，表示该规则不参与评分，仅作为提示项。开发者可在开发者工具中可以点击“忽略”。

各规则的得分条件也可能会随小程序的版本更新有一定的调整。

权重如下表
分类	规则	权重
性能	脚本执行时间	7
	首屏时间	6
	渲染时间	6
	setData调用频率	6
	setData数据大小	6
	WXML节点数	6
	请求耗时	5
	网络请求数	5
	图片请求数	5
	图片缓存	4
	图片大小	4
	网络请求缓存	2
体验	开启惯性滚动	8
	避免使用:active伪类来实现点击态	8
	保持图片大小比例	4
	可点击元素的响应区域	3
	iPhone X兼容	3
	窗口变化适配	3
	合理的颜色搭配	0
最佳实践	避免JS异常	3
	避免网络请求异常	3
	废弃接口	2
	使用HTTPS	1
	避免setData数据冗余	1
	最低基础库版本	0
	移除不可访问到的页面	0
	WXSS使用率	0
	及时回收定时器	0
规则说明

详细的规则说明可参考下列文档：

性能
体验
最佳实践
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 8. 连接硬件能力 / 需要帮助

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/device/help.html](https://developers.weixin.qq.com/miniprogram/dev/framework/device/help.html)

连接硬件能力 /需要帮助
需要帮助

如果在使用过程中遇到任何问题，可以前往「硬件服务」专区查看说明。

如未能解答，请邮件 wx_iot@tencent.com 描述具体问题。

欢迎开发者扫码加入「硬件服务」沟通群一起交流。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 9. 小程序基础库 / v3.x版本

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/release/](https://developers.weixin.qq.com/miniprogram/dev/framework/release/)

小程序基础库 /v3.x版本
基础库更新日志

查看开发者工具更新日志

查看云开发更新日志

v3.13.0 (2025-12-03)
U 更新 框架 httpdns 支持插件发起 详情
U 更新 框架 小游戏福利组件折叠、礼包进度刷新优化
U 更新 框架 PC 小游戏键鼠模拟功能优化
U 更新 框架 glass-easel webview 支持初始渲染缓存
U 更新 API getSystemInfo / getDeviceInfo platform 平台新增 ohos_pc 详情
U 更新 API 小程序支持拉起直播预约半屏幕 详情
F 修复 框架 exparser 中自定义组件 property 的 optionalTypes 包含 Object 或 Array 时，传入 undefined 作为值会引起预期外的异常
F 修复 框架 PC 小程序 picker 组件样式修复 详情
F 修复 组件 Editor 组件 setEventInterceptor 方法
F 修复 API editor 拦截删除 block 失败
v3.12.1 (2025-11-21)

U 更新 框架 skyline 允许开发者指定 navigateTo 动画使用的 OpenContainer 详情

U 更新 API MapContext.openMapApp 允许指定优先地图 App 和 poiId 参数 详情

F 修复 框架 跳插件页出现非预期 tabbar

F 修复 框架 修复 ohos skyline video 无法全屏

F 修复 框架 root-portal 脱离页面时，需要屏蔽 portal 组件

v3.12.0 (2025-11-13)
A 新增 API 小程序接入截图/生成图自定义转发 wx.onGeneratePoster 详情
U 更新 框架 PC 小游戏最小窗口尺寸统一
U 更新 框架 分享朋友圈支持 Promise 获取，与分享给好友对齐 详情
U 更新 框架 优化手机号扣费
U 更新 框架 聊天工具开放能力 详情
F 修复 框架 skyline input 函数未定义报错
F 修复 框架 skyline video组件中 setLayoutCallback 找不到的问题 详情
v3.11.3 (2025-11-06)

修复了一些已知问题

v3.11.2 (2025-10-31)
A 新增 API 小游戏开放数据域支持给朋友送道具 详情
U 更新 框架 performance 支持 skyline 监听卡顿数据
U 更新 框架 插件支持调用 wx.openOfficialAccountProfile 详情
U 更新 框架 PC 小程序 showShareImageMenu
U 更新 框架 PC 小程序「设置」体验优化
v3.11.1 (2025-10-21)
U 更新 框架 ohos 支持 voip-room 详情
U 更新 框架 ohos 支持调用 nfc 相关接口 详情
U 更新 框架 提供 requestIdleCallback 注册空闲时机回调方法 详情
U 更新 框架 PC 小程序 request 接口及相关网络接口提供 timeout 参数支持 详情
U 更新 框架 PC 端推荐评分组件& cps 推荐组件兼容
U 更新 框架 优化异步分包下载机制
U 更新 框架 小程序非前台的状态下媒体内容播放与暂停逻辑优化
U 更新 框架 生成 codecache 策略优化
U 更新 组件 图文发表与展示组件跳转小程序 path 详情
U 更新 组件 scroll-view scroll-anchoring 支持选择自定义组件为锚点 详情
U 更新 组件 skyline rich-text webstatic 模式 优化渲染性能
F 修复 框架 performance 路由开始时间异常问题
F 修复 框架 聊天工具模式分享接口不触发失败回调函数
F 修复 组件 skyline 下 input type=nickname 不触发 input 事件
F 修复 API 小程序分享到图片接口添加保存到相册无授权 toast
v3.11.0 (2025-10-14)
U 更新 框架 PC 小程序 picker 组件样式优化
U 更新 框架 PC 小游戏横竖屏切换支持 详情
U 更新 框架 globalpay 全球收银新增跳端支付
U 更新 组件 小游戏擂台赛 详情
F 修复 框架 wx.setStorageSync(key undefined) 设置 data 值为 undefined 时会错误的转为空字符串
F 修复 框架 开发者工具 InnerAudioContext 连续多次调用 play ，再调用 stop 时音频还在播放
v3.10.3 (2025-09-23)
U 更新 框架 PC 小程序菜单新增静音入口
U 更新 框架 PC 小程序菜单新增设置入口
U 更新 组件 图文发表与展示组件 limit 属性 详情
F 修复 框架 小游戏推荐组件在游戏名超长情况下显示 bug
v3.10.2 (2025-09-11)
A 新增 组件 图文发表与展示组件 详情
U 更新 框架 skyline 模式下输入框先获得焦点再点击数据填充后 setData 和输入框内容不一致
U 更新 框架 PC 小程序/小游戏 Vconsole 体验优化
F 修复 框架 PC / 平板 frameset 分栏模式下遇到的多个问题
F 修复 组件 slider 无法滑动到上次的值 详情
v3.10.1 (2025-09-04)
U 更新 组件 picker-view-column 无障碍提示语优化
U 更新 API wx.getEnterOptionsSync 和 wx.getLaunchOptionsSync 每次调用时都返回一个新的对象
F 修复 框架 飞行模式下 wx.request timeout 不符预期的问题
F 修复 框架 没有 hoverClass 时，stopPropagation 不生效
F 修复 框架 PC 小程序 picker 组件设置 level 后不生效 详情
F 修复 框架 vConsole 按钮特定场景下消失
F 修复 组件 skyline map 内存泄露
v3.10.0 (2025-08-26)
A 新增 框架 小程序用工关系功能相关接口 详情
A 新增 API 小程序支持跳转公众号会话 详情
U 更新 API openEmbeddedMiniProgram 接口打开半屏小程序上限提升到100，allowFullScreen 参数强制为 true 详情
U 更新 组件 map 组件 show-location 新增用户定位授权检查 详情
F 修复 组件 channel-video skyline 下交互可能不生效
v3.9.3 (2025-08-14)
U 更新 框架 editor customBlock 支持 redo/undo、获取 historyState 详情
v3.9.2 (2025-08-07)
A 新增 API 小程序内容同步至图文 详情
U 更

... (content truncated)

---

## 10. Skyline 渲染引擎 / 增强特性 / 滚动容器及其应用场景

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/scroll-container.html](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/scroll-container.html)

Skyline 渲染引擎 /增强特性 /滚动容器及其应用场景
滚动容器及其应用场景

流畅的滚动对于提升用户体验至关重要。为了达到原生级别的滚动效果和降低开发成本，Skyline 扩展了旧的 ScrollView 组件，同时针对部分场景，新增了一些滚动容器。诸多的新能力有时会让开发者选择困难，下面对其典型应用场景进行介绍。

长列表

WebView 下的 ScrollView 组件，在快速滑动时容易出现白屏和渲染卡顿。对于长列表的优化，通常离不开按需渲染，即理想状态下仅渲染在屏节点，超出可视区域的节点及时进行回收。

Skyline 下内置了按需渲染的能力，但对于写法有一定要求，列表项需作为直接子节点，形如下面的结构。

<scroll-view type="list" scroll-y>
  <view> a </view>
  <view> b </view>
  <view> c </view>
</scroll-view>

视口大小

ScrollView 的视口大小 = ScrollView 的高度 + 指定的上下缓冲区 CacheExtent。

指定 CacheExtent 可优化滚动体验和加载速度，但会提高内存占用且影响首屏速度，可按需启用。

节点进入视口区域时开始渲染，离开视口时回收资源。资源回收的粒度为其直接子节点。当 ScrollView 仅有单个子节点时，为保证其渲染，所有的资源都无法回收，需全量布局和绘制所有内容，性能较差，因此才需要摊平子节点。

出于业务需要 ScrollView 的内容常被封装成组件，导致无法作为直接子节点。这里有一个小技巧，可将封装的组件设为虚拟的，开启 virtualHost: true。真正渲染时，virtual-comp 节点并不存在，列表项仍是摊平的。

<scroll-view type="list" scroll-y>
  <virtual-comp>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </virtual-comp>
</scroll-view>

完全的按需渲染

小程序内的按需渲染分为两个阶段。

列表项按需创建其 DOM 节点；
列表项按需绘制上屏;

ScrollView 的 list 模式实现了按需绘制，但列表项的 DOM 节点 仍是全量创建的。随着节点数增多，会带来内存压力。

为此框架提供了新的 builder 模式，可使用 list-builder、grid-builder 等组件实现 DOM 节点 的按需创建。

上图是 builder 模式在开发者工具中 wxml 的渲染结果，仅在屏列表项会被真正创建节点，离屏后列表项会被回收，滚动时始终几个子节点。

示例代码片段

在开发者工具中预览效果

ScrollView 的三种模式

ScrollView 提供了列表 list、自定义 custom 和 嵌套 nested 三种渲染模式，实际开发时如何选择呢？

列表模式

默认模式，实现了内置的按需渲染能力，但没有进行节点回收。当列表项比较简单，不会带来明显的内存压力时使用。

非长列表时，即使不摊平列表项也不会有明显性能问题，可使用单子节点写法。

<!-- 单子节点写法，全量绘制 -->
<scroll-view type="list" scroll-y>
  <view>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </view>
</scroll-view>

<!-- 列表项作为直接子节点，有按需绘制优化 -->
<scroll-view type="list" scroll-y>
  <view> a </view>
  <view> b </view>
  <view> c </view>
</scroll-view>

<!-- 列表项作为 list-view 直接子节点，有按需绘制优化，同上 -->
<scroll-view type="custom" scroll-y>
  <list-view>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </list-view>
</scroll-view>

自定义模式

列表滚动时常会和特殊布局能力结合使用，如滚动到顶部时自动吸顶 sticky 效果，或瀑布流布局。

Skyline 内置了这部分能力，可直接使用 sticky-header 和 grid-view 组件实现。

list-view 组件的效果跟列表模式是等价的，如果不需要这些特殊布局能力，可任意选择写法。

需要注意的是自定义模式下，ScrollView 直接子节点本身并没有按需绘制优化，按需绘制的能力是 list-view 组件实现的，custom 模式组合了这些能力。

<scroll-view type="custom" scroll-y>
  <sticky-section>
    <sticky-header>
      <view> h </view>
    </sticky-header>

    <!-- 非 list-view 子节点，无按需绘制优化 -->
    <view> 1</view>
    <view> 2 </view>

    <!-- 列表项作为 list-view 直接子节点，有按需绘制优化 -->
    <list-view>
      <view> a </view>
      <view> b </view>
      <view> c </view>
    </list-view>
  </sticky-section>
</scroll-view>

<scroll-view type="custom" scroll-y>
  <sticky-section>
    <sticky-header>
      <view> h </view>
    </sticky-header>

    <!-- 列表项作为 grid-view 直接子节点，有按需绘制优化 -->
    <<grid-view type="masonry">
      <view> a </view>
      <view> b </view>
      <view> c </view>
    </<grid-view>
  </sticky-section>
</scroll-view>

示例代码片段

在开发者工具中预览效果

嵌套模式

这主要是针对一类嵌套滚动场景。如下图所示，SwiperItem 内也有纵向滚动的 ScrollView 组件，当在内部 ScrollView 上滑动时，会与外层 ScrollView 产生手势冲突，导致外层的页面始终无法滚动。

纵轴+横轴+纵轴的嵌套组合
同一方向的滚动容器存在手势冲突
可使用手势协商解决，但过程较为

... (content truncated)

```html
<scroll-view type="list" scroll-y>
  <view> a </view>
  <view> b </view>
  <view> c </view>
</scroll-view>

```

```html
<scroll-view type="list" scroll-y>
  <virtual-comp>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </virtual-comp>
</scroll-view>

```

```html
<!-- 单子节点写法，全量绘制 -->
<scroll-view type="list" scroll-y>
  <view>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </view>
</scroll-view>

<!-- 列表项作为直接子节点，有按需绘制优化 -->
<scroll-view type="list" scroll-y>
  <view> a </view>
  <view> b </view>
  <view> c </view>
</scroll-view>

<!-- 列表项作为 list-view 直接子节点，有按需绘制优化，同上 -->
<scroll-view type="custom" scroll-y>
  <list-view>
    <view> a </view>
    <view> b </view>
    <view> c </view>
  </list-view>
</scroll-view>

```

---

## 11. 开放能力 / 附近的小程序

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/nearby.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/nearby.html)

开放能力 /附近的小程序
附近的小程序
概述

附近的小程序 API，提供给需快速批量创建附近地点的小程序开发者使用，使用前请先调高附近地点额度。 调高附近地点额度申请方式如下：

下载 《调高地点额度申请表》，填写后发送至 placeofminiprogram@qq.com。

邮件主题为：“账号名称”申请调高附近地点额度。审核通过后可调高额度。

管理接口
添加地点
查看地点列表
删除地点
展示/取消展示附近小程序
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 12. 开放能力 / 音视频通话 / 双人音视频对话

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/1v1voip.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/1v1voip.html)

开放能力 /音视频通话 /双人音视频对话
双人音视频对话

通过双人音视频通话功能（1v1 VoIP），用户可以直接在小程序内进行一对一视频通话或音频通话，提升小程序服务质量，且功能所需的开发成本极低。

从基础库 2.20.1 开始支持

申请开通

暂只针对国内主体如下类目的小程序开放，需要先通过类目审核，再在小程序管理后台，「开发」-「开发管理」-「接口设置」中自助开通该接口权限。

一级类目/主体类型	二级类目	应用场景
教育	在线视频课程	一对一辅导、答疑
医疗	互联网医院、公立医疗机构、私立医疗机构	在线问诊
金融	银行、信托、公募基金、私募基金、证券/期货、证券/期货投资咨询、保险、征信业务、新三板信息服务市场、股票信息服务市场（港股/美股）、消费金融	金融产品视频客服理赔等
汽车	汽车预售服务	汽车预售等
政府主体账号	/	政府相关工作在线咨询等
IT科技	多方通信、音视频设备、基础电信运营商	提供语音会议/视频会议等服务；硬件在线销售及服务等；提供在线客服等服务
工具	视频客服	不涉及以上几类内容的一对一客服服务，如企业售后一对一视频/音频通话等
前端接口
开启双人通话：wx.setEnable1v1Chat
加入（创建）双人通话：wx.join1v1Chat
退出（销毁）双人通话：wx.exitVoIPChat
更新房间麦克风/耳机静音设置：wx.updateVoIPChatMuteConfig
监听房间成员变化：wx.onVoIPChatMembersChanged
监听房间成员通话状态变化：wx.onVoIPChatSpeakersChanged
监听通话中断：wx.onVoIPChatInterrupted
监听实时语音通话成员视频状态变化：wx.onVoIPVideoMembersChanged
调用流程
通过 wx.setEnable1v1Chat 接口将用户的接听状态enable设置为true，该设置仅在当次小程序生命周期有效，小程序每次冷启动后均需要重新设置。
通过 wx.join1v1Chat 接口传入呼叫方信息caller与接听方信息listener发起呼叫，接听方与呼叫方均需在小程序内。
计费

微信为单个小程序提供每个自然月1000分钟的免费通话时长，1分钟语音通话时长扣除1分钟免费通话时长，1分钟视频通话时长扣除15分钟免费时长。超出部分需另行付费。 免费时长领取与套餐包购买需前往微信服务市场进行操作。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 13. 基础能力 / AI/AR / VisionKit 视觉能力 / Marker AR

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/marker.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/marker.html)

基础能力 /AI/AR /VisionKit 视觉能力 /Marker AR
2D/3D物体AR能力 （2D/3D Marker AR）
方法定义

2D/3D Marker AR能力，能够识别预先设定的目标物体(定义为Marker，包括2D平面物体和3D物体），进行视觉跟踪与定位，通过在目标物体周围渲染虚拟物体，从而实现AR功能。

方法区别
2D Marker，仅适用于平面类物体，用户上传一张平面物体的俯视图像作为目标物体，算法运行时识别该平面物品，并渲染出相关虚拟物体。2D Marker可以理解为特殊的3D Marker。
3D Marker，相比于2D Marker，能够识别3D物体，不局限与平面物体，具有更广的使用范围，算法运行前，需要手动制作3D Marker的识别目标文件（.map文件），然后算法运行时载入该文件用于识别。
使用提示
使用 addMarker 接口之前，需要在 createVKSession 的时候声明开启 marker 跟踪。即 wx.createVKSession({ track: { marker: true } })
可以添加 多个 Marker 图片，但不能重复添加相同的 marker 图片。
在 v2 模式下，使用 平面识别 与 Marker检测 结合，允许 同时识别多个 Marker，同时可输出多个2d/3d marker 识别结果（需要基础库版本3.0.0)，目标在视野中消失后之前返回的pose位姿信息依然有效可用，具体可以参考 平面AR能力扩展 以及内部的相关例子。
识别物体规范

为提高Marker质量，保证算法识别效果，具体请仔细阅读Marker规范文档 Marker规范

3D Marker 识别目标文件 map 生成

目前仅允许通过 小程序示例 的 接口 - VisionKit视觉能力 - 3DMarkerAR 页面生成。

生成任务状态解析
准备中 - 已上传，但生成服务器还未返回结果。建议等待20min，再考虑上传下一个视频（未更新结果，可以手动删除本任务，不过最好等待一天左右）
生成失败 - 会在错误提示上标明错误原因
已完成 - 生成完成，默认产物仅保留 30 天，请自行下载。
服务耗时：
当前版本 30s 视频耗时约 20分钟，请静待算法返回模型。
本服务同一时间仅处理一项任务，多个任务同时进行可能会导致后续任务的失败，建议闲时错峰进行生成。
对传入的视频有如下要求：
视频长宽比为 16:9 或 4:3，短边大于 480px
目标物体易于和背景物体区分出来，同时目标物体放置与背景物体一定距离，放置底面与物体易于区分，底面可以放置一张白纸。
目标物体最好为刚体，本身不会发生较大形变，容易变形的物体不适合用作识别对象
视频匀速移动，避免模糊，对目标识别面环绕物体拍摄，需要保证相机有足够的平移移动
marker物体要求 与 2d图像要求类似，具有丰富细节，避免重复单一纹理，不反光，无高光
拍摄视频中特征纹理丰富，如果 marker 本身问题较弱，可以在背景中适当添加纹理物体
不建议使用透明物体，生成效果较差。
对传入的视频建议：
视频格式：视频帧率30fps，分辨率建议1080p
视频时长：视频建议时长在20s~30s，超过30s会被截断，时长过短会导致 marker 效果欠佳
3D Marker 来源视频参考

程序示例

以下接口可在 小程序接口能力展示demo 中的 接口 - VisionKit视觉能力 中体验

2D Marker 能力
基础 2D Marker 能力示例 基础 2D Marker 识别示例。
水平面 + 2D Marker 能力示例 水平面AR 结合 2D Marker 识别示例。
水平面 + 附加能力 示例 水平面AR 结合 多种附加能力示例。
3D Marker 能力
3D Marker能力使用示例 3D Marker 的生成、调用与测试示例。
3D Marker案例 默认识别 大致效果

3D Marker案例 默认识别 来源视频参考

3D Marker案例 默认识别 图片

应用场景示例

2D示例：

工卡AR
门票AR
艺术画AR

3D物体示例:

饮料、化妆瓶等容器类AR
公仔AR

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 14. 开放能力 / 用户信息 / 获取头像昵称

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/userProfile.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/userProfile.html)

开放能力 /用户信息 /获取头像昵称
头像昵称填写

从基础库 2.21.2 开始支持

当小程序需要让用户完善个人资料时，可以通过微信提供的头像昵称填写能力快速完善。

根据相关法律法规，为确保信息安全，由用户上传的图片、昵称等信息微信侧将进行安全检测，组件从基础库2.24.4版本起，已接入内容安全服务端接口（mediaCheckAsync、msgSecCheck），以减少内容安全风险对开发者的影响。

使用方法
头像选择

需要将 button 组件 open-type 的值设置为 chooseAvatar，当用户选择需要使用的头像之后，可以通过 bindchooseavatar 事件回调获取到头像信息的临时路径。

从基础库2.24.4版本起，若用户上传的图片未通过安全监测，不触发bindchooseavatar 事件。

昵称填写

需要将 input 组件 type 的值设置为 nickname，当用户在此input进行输入时，键盘上方会展示微信昵称。

从基础库2.24.4版本起，在onBlur 事件触发时，微信将异步对用户输入的内容进行安全监测，若未通过安全监测，微信将清空用户输入的内容，建议开发者通过 form 中form-type 为submit 的button 组件收集用户输入的内容。

在开发者工具上，input 组件是用 web 组件模拟的，因此部分情况下并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。

代码示例

在开发者工具中预览效果

<button class="avatar-wrapper" open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar">
  <image class="avatar" src="{{avatarUrl}}"></image>
</button> 
<input type="nickname" class="weui-input" placeholder="请输入昵称"/>

const defaultAvatarUrl = 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0'

Page({
  data: {
    avatarUrl: defaultAvatarUrl,
  },
  onChooseAvatar(e) {
    const { avatarUrl } = e.detail 
    this.setData({
      avatarUrl,
    })
  }
})

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<button class="avatar-wrapper" open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar">
  <image class="avatar" src="{{avatarUrl}}"></image>
</button> 
<input type="nickname" class="weui-input" placeholder="请输入昵称"/>

```

```js
const defaultAvatarUrl = 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0'

Page({
  data: {
    avatarUrl: defaultAvatarUrl,
  },
  onChooseAvatar(e) {
    const { avatarUrl } = e.detail 
    this.setData({
      avatarUrl,
    })
  }
})

```

---

## 15. 连接硬件能力 / 设备消息

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/device/device-message.html](https://developers.weixin.qq.com/miniprogram/dev/framework/device/device-message.html)

连接硬件能力 /设备消息
小程序设备消息
能力介绍

「小程序设备消息」是一种长期订阅类型的「小程序订阅消息」，且需要完成「设备接入」才能够使用。

用户在使用设备过程中，需要关注某些由设备触发且需要人工介入的事件。例如安防摄像头检测到异常，设备耗材不足，设备发生故障等等。

「小程序设备消息」能力指的是，只要用户在小程序内订阅通知，开发者就可以将这些事件以订阅消息的形式发送给用户。消息在微信内的产品形态，目前以「服务通知」形式呈现。

开发流程
1. 设备接入

小程序想要使用设备消息能力，首先需要接入设备，详见「设备接入」文档。

完成接入后，开发者可获得由平台分配的 model_id 。model_id 对应一种设备类型，也是调用小程序设备能力相关接口的重要凭证。

2. 获取模版 ID

登录「小程序管理后台」——「功能」——「订阅消息」——「公共模板库」——「长期订阅」，查看可选用的设备消息模板。

选择设备消息模板中需要的关键词，并提交。

注意：设备消息模版的关键词内容由平台生成，为枚举值，开发者不能够自定义内容。

提交后，可在「我的模板」中找到对应模板的模板 ID ，每个模板以 template_id 标记。

3. 获取设备票据

获取 snTicket 用于「发起订阅」步骤。

详见服务端设备票据接口 hardwareDevice.getSnTicket 。

4. 发起订阅

调用 wx.requestSubscribeDeviceMessage 接口会有以下授权弹窗出现，用户同意订阅消息后，才会有设备消息发送至用户的微信会话。

小程序内完成设备消息订阅

用户订阅设备消息时，需要手动点击“添加提醒”，设备触发消息后才会出现“响铃+振动”的强提醒状态，开发者可以在前端界面进行引导。

示例代码
wx.requestSubscribeDeviceMessage({
    sn: 'xxxx',
    snTicket: 'xxxxx',
    modelId: 'xxxxx',
    tmplIds: ['xxxxx'],
    success(res) {
        console.log('[wx.requestSubscribeDeviceMessage success]: ', res)
        // { 'QCpBsp1TGJ1ML-UIwAIMkdXpPGzxSfwJqsKsvMVs3io': 'accept' }
    },
    fail(res) {
        console.log('[wx.requestSubscribeDeviceMessage fail]: ', res)
    }
})

5. 发送设备消息

开发者通过微信服务端接口向用户推送设备消息。

详见服务端设备消息发送接口 hardwareDevice.send 。

服务通知 - 设备消息

设备消息具体形式

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
wx.requestSubscribeDeviceMessage({
    sn: 'xxxx',
    snTicket: 'xxxxx',
    modelId: 'xxxxx',
    tmplIds: ['xxxxx'],
    success(res) {
        console.log('[wx.requestSubscribeDeviceMessage success]: ', res)
        // { 'QCpBsp1TGJ1ML-UIwAIMkdXpPGzxSfwJqsKsvMVs3io': 'accept' }
    },
    fail(res) {
        console.log('[wx.requestSubscribeDeviceMessage fail]: ', res)
    }
})

```

---

## 16. 自定义组件 / 纯数据字段

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html)

自定义组件 /纯数据字段
纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 2.8.2 开始支持。

组件数据中的纯数据字段

有些情况下，某些 data 中的字段（包括 setData 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 this.data 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

指定“纯数据字段”的方法是在 Component 构造器的 options 定义段中指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

在开发者工具中预览效果

代码示例：

Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})


上述组件中的纯数据字段不会被应用到 WXML 上：

<view wx:if="{{a}}"> 这行会被展示 </view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>

组件属性中的纯数据字段

属性也可以被指定为纯数据字段（遵循 pureDataPattern 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

代码示例：

Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      }
    },
  }
})


注意：属性中的纯数据字段的属性 observer 永远不会触发！如果想要监听属性值变化，使用 数据监听器 代替。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 pureDataPattern （这样就不需在 js 文件的 options 中再配置）。此时，其值应当写成字符串形式：

{
  "pureDataPattern": "^_"
}

使用数据监听器监听纯数据字段

数据监听器 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

在开发者工具中预览效果

代码示例：

Component({
  options: {
    pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
  },
  properties: {
    timestamp: Number,
  },
  observers: {
    timestamp: function () {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString()
      this.setData({
        timeString: timeString
      })
    }
  }
})

<view>{{timeString}}</view>

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})

```

```html
<view wx:if="{{a}}"> 这行会被展示 </view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>

```

```js
Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      }
    },
  }
})

```

---

## 17. 基础能力 / 网络 / 移动解析HttpDNS

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/ability/HTTPDNS.html](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/HTTPDNS.html)

基础能力 /网络 /移动解析HttpDNS
移动解析HttpDNS

从基础库 2.19.2 开始支持

开发者调用wx.request时，可以开启移动解析HttpDNS服务。 该服务基于Http协议向服务商的DNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免Local DNS造成的域名劫持和跨网访问问题，解决移动互联网服务中域名解析异常带来的困扰。

小程序开发者使用移动解析说明
前往微信服务市场选购 HttpDNS 资源，并在服务详情页-接入文档获取Service ID。
小程序调用wx.request，将enableHttpDNS参数设置为true，并在httpDNSServiceId参数中填入选用的服务商Service ID。
代码示例
wx.request({
  url: 'example.php', //仅为示例，并非真实的接口地址
  enableHttpDNS: true,
  httpDNSServiceId: 'wxa410372c837a5f26',
  success(res) {
    console.log('request success', res)
  },
  fail(res) {
    console.error('request fail', res)
  }
})

计费说明
使用服务所产生的费用会按照实际调用服务商接口情况进行计费，定价策略由服务提供方制定，开发者需自行前往微信服务市场进行购买、续费等操作。
微信侧每次代开发者调用服务商接口时，微信侧会进行缓存，缓存策略由服务商返回的ttl决定，因此不一定每次调用request接口都会产生费用。
从基础库 v2.32.1 开始，若开发者的服务可用额度为0，仍在wx.request接口中声明使用服务商提供的移动解析能力时，会使用 localDNS 解析来兜底，并在 success 回调参数 exception.reasons ( reasons 是数组) 中返回 httpdns 欠费的错误信息和错误码，类似 [{ "errMsg": "getDNSInfo:fail no enough httpdns quota", "errno": 602103 }]。
注意事项
HttpDNS 不兼容网络代理

在基础库 v2.22.1 版本之前，当用户设备使用了网络代理，同时又开启了 enableHttpDNS 时，request 接口会调用失败，fail 回调 errMsg 中会包含 ERR_PROXY_CONNECTION_FAILED 字样，如 {"errno":600001,"errMsg":"request:fail -130:net::ERR_PROXY_CONNECTION_FAILED"} 或 {"errno":600001,"errMsg":"request:fail errcode:-130 cronet_error_code:-130 error_msg:net::ERR_PROXY_CONNECTION_FAILED"}。

为解决此问题，从基础库 v2.22.1 开始，若用户使用了网络代理，基础库会主动强制关闭 enableHttpDNS。开发者也可以通过 wx.getNetworkType 接口检查用户是否开启了网络代理。用法：

wx.getNetworkType({
  success(res) {
    console.log(res.hasSystemProxy) // 开启网络代理时为 true，否则为 false
  }
})

HttpDNS 相关错误码
错误码	说明
600000	网络错误
602000	网络请求错误
602001	系统错误
602002	http请求httpdns服务商错误
602101	小程序未在服务市场购买httpdns服务
602102	小程序在httpdns服务市场资源包过期
602103	小程序在httpdns服务市场额度不足
602104	httpdns服务商返回结果为空
602105	调用httpdns服务商结果超时
602106	httpdns服务商返回数据不合法
602107	httpdns域名解析结果为空
602108	不支持的httpdns服务商id
移动解析服务提供商接入说明

为了保护微信客户端的安全，小程序使用的移动解析服务需要通过微信侧安全认证，认证后可在微信服务市场上架。

微信侧欢迎更多服务商为小程序提供移动解析服务。申请接入按照以下模板发送邮件，我们会有专人与您联系。

收件人：servicemarket@tencent.com
主题：【上架服务市场】XXX（服务商）申请上架HttpDNS服务
正文：需要写明服务商的基本资料，包括不仅限于服务商名称、业务范围、技术证书、合作意向、联系方式等

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
wx.request({
  url: 'example.php', //仅为示例，并非真实的接口地址
  enableHttpDNS: true,
  httpDNSServiceId: 'wxa410372c837a5f26',
  success(res) {
    console.log('request success', res)
  },
  fail(res) {
    console.error('request fail', res)
  }
})

```

```js
wx.getNetworkType({
  success(res) {
    console.log(res.hasSystemProxy) // 开启网络代理时为 true，否则为 false
  }
})

```

```md
收件人：servicemarket@tencent.com
主题：【上架服务市场】XXX（服务商）申请上架HttpDNS服务
正文：需要写明服务商的基本资料，包括不仅限于服务商名称、业务范围、技术证书、合作意向、联系方式等

```

---

## 18. 小程序框架 / 视图层 / WXSS

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

小程序框架 /视图层 /WXSS
WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

WXSS 用来决定 WXML 的组件应该怎么显示。

为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。

与 CSS 相比，WXSS 扩展的特性有：

尺寸单位
样式导入
尺寸单位
rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
设备	rpx换算px (屏幕宽度/750)	px换算rpx (750/屏幕宽度)
iPhone5	1rpx = 0.42px	1px = 2.34rpx
iPhone6	1rpx = 0.5px	1px = 2rpx
iPhone6 Plus	1rpx = 0.552px	1px = 1.81rpx

建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。

注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

样式导入

使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。

示例代码：

/** common.wxss **/
.small-p {
  padding:5px;
}

/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}

内联样式

框架组件上支持使用 style、class 属性来控制组件的样式。

style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。
<view style="color:{{color}};" />

class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。
<view class="normal_view" />

选择器

目前支持的选择器有：

选择器	样例	样例描述
.class	.intro	选择所有拥有 class="intro" 的组件
#id	#firstname	选择拥有 id="firstname" 的组件
element	view	选择所有 view 组件
element, element	view, checkbox	选择所有文档的 view 组件和所有的 checkbox 组件
::after	view::after	在 view 组件后边插入内容
::before	view::before	在 view 组件前边插入内容
全局样式与局部样式

定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```less
/** common.wxss **/
.small-p {
  padding:5px;
}

```

```less
/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}

```

```html
<view style="color:{{color}};" />

```

---

## 19. 开放能力 / 广告 / 格子广告

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/ad/grid-ad.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/ad/grid-ad.html)

开放能力 /广告 /格子广告
Grid 广告

小程序广告流量主操作指引：文档地址
开发者可以使用 ad 组件创建 Grid 广告组件，Grid 广告组件在创建后会自动拉取广告数据并显示。

广告尺寸设置

Grid 广告不允许直接设置样式属性，默认宽度为100%（width: 100%），高度会自动等比例计算，因此开发者可以设置广告外层组件的宽度调整广告的尺寸。格子广告有最小尺寸限制，5个的形态为331px，8个的形态为294px。

/* 外层组件的宽度可设置成100%或具体数值 */
.adContainer {
  width: 100%;
}

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="white" grid-count="5"></ad>
</view>

广告事件监听

Grid 广告在创建后会自动拉取广告。开发者可以通过 ad 组件的 onload 和 onerror 事件监听广告拉取成功或失败，可以通过 onclose 事件监听广告被关闭。

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="white" grid-count="5" bindload="adLoad" binderror="adError" bindclose="adClose"></ad>
</view>

Page({
  adLoad() {
    console.log('Grid 广告加载成功')
  },
  adError(err) {
    console.log('Grid 广告加载失败', err)
  },
  adClose() {
    console.log('Grid 广告关闭')
  }
})

广告主题样式设置

小程序视频广告组件提供黑、白两种主题样式，开发者可以在创建视频广告时传入ad-theme参数实现主题样式选择，ad-theme参数为字符串类型，参数值可选white, black

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="white"></ad>
</view>

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="black"></ad>
</view>

广告格子个数设置

小程序视频广告组件提供黑、白两种主题样式，开发者可以在创建视频广告时传入grid-count参数实现主题样式选择，grid-count参数为数字类型，参数值可选5, 8

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" grid-count="5"></ad>
</view>

<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" grid-count="8"></ad>
</view>

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```css
/* 外层组件的宽度可设置成100%或具体数值 */
.adContainer {
  width: 100%;
}

```

```html
<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="white" grid-count="5"></ad>
</view>

```

```html
<view class="adContainer">
  <ad unit-id="xxxx" ad-type="grid" ad-theme="white" grid-count="5" bindload="adLoad" binderror="adError" bindclose="adClose"></ad>
</view>

```

---

## 20. 开放能力 / 消息 / 客服消息 / 概述

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html)

开放能力 /消息 /客服消息 /概述
客服消息
在页面使用客服消息

需要将 button 组件 open-type 的值设置为 contact，当用户点击后就会进入客服会话，如果用户在会话中点击了小程序消息，则会返回到小程序，开发者可以通过 bindcontact 事件回调获取到用户所点消息的页面路径 path 和对应的参数 query。

示例代码
<button open-type="contact" bindcontact="handleContact"></button>

Page({
    handleContact (e) {
        console.log(e.detail.path)
        console.log(e.detail.query)
    }
})

返回参数说明
参数	类型	说明
path	String	小程序消息指定的路径
query	Object	小程序消息指定的查询参数
后台接入消息服务

用户向小程序客服发送消息、或者进入会话等情况时，开发者填写的服务器配置 URL / 云开发云函数 / 云托管服务将得到微信服务器推送过来的消息和事件，开发者可以依据自身业务逻辑进行响应。接入和使用方式请参考消息推送。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<button open-type="contact" bindcontact="handleContact"></button>

```

```javascript
Page({
    handleContact (e) {
        console.log(e.detail.path)
        console.log(e.detail.query)
    }
})

```

---

## 21. 插件 / 插件功能页 / 支付功能页

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/request-payment.html](https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/request-payment.html)

插件 /插件功能页 /支付功能页
支付功能页

自2025年6月26日起，不再支持新申请插件支付功能，如果要在小程序中实现给向第三方支付，请使用「打开半屏小程序」功能。

支付功能页用于帮助插件完成支付，相当于 wx.requestPayment 的功能。

自基础库版本 2.22.1 起，可以直接在插件中调用 wx.requestPluginPayment 实现跳转支付；通过 functional-page-navigator 跳转将会被废弃。

在满足以下条件时，调用 wx.requestPluginPayment 或点击 navigator 都将直接拉起支付收银台，跳过支付功能页：

小程序与插件绑定在同一个 open 平台账号上

小程序与插件均为 open 账号的同主体 / 关联主体时。

需要注意的是：插件使用支付功能，需要进行额外的权限申请，申请位置位于 管理后台 的“小程序插件 -> 基本设置 -> 支付能力”设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。

调用参数

参数说明：

参数名	类型	必填	说明
fee	Number	是	需要显示在页面中的金额，单位为分
paymentArgs	Object	否	任意数据，传递给功能页中的响应函数
currencyType	String	否	需要显示在页面中的货币符号的代码，默认为 CNY

currencyType 的合法值：

值	说明	最低版本
CNY	货币符号 ¥	
USD	货币符号 US$	
JPY	货币符号 J¥	
EUR	货币符号 €	
HKD	货币符号 HK$	
GBP	货币符号 ￡	
AUD	货币符号 A$	
MOP	货币符号 MOP$	
KRW	货币符号 ₩	
示例代码
wx.requestPluginPayment 方式

自基础库版本 2.22.1 起，推荐使用该方式。

<!-- plugin/components/pay.wxml -->
<button bindtap="handlePay">支付 0.01 元</button>

// plugin/components/pay.js
Component({
  data: {
    fee: 1,             // 支付金额，单位为分
    paymentArgs: 'A', // 将传递到功能页函数的自定义参数
    currencyType: 'USD' // 货币符号，页面显示货币简写 US$ 
    version: 'develop', // 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布
  },
  methods: {
    handlePay() {
        const { fee, paymentArgs, currencyType, version } = this.data
        wx.requestPluginPayment({
            fee,
            paymentArgs,
            currencyType,
            version,
            success(r) {
                console.log(r)
            },
            fail(e) {
                console.error(e)
            }
        })
    }
  }
})

functionl-page-navigator 方式（将废弃）

该方式将会被废弃，仅供参考

<!-- plugin/components/pay.wxml -->
<!-- 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布 -->
<!-- name 参数固定为 "requestPayment" -->
<functional-page-navigator
  version="develop"
  name="requestPayment"
  args="{{ args }}"
  bind:success="paymentSuccess"
  bind:fail="paymentFailed"
>
  <button class="payment-button">支付 0.01 元</button>
</functional-page-navigator>

// plugin/components/pay.js
Component({
  data: {
    args: {
      fee: 1,             // 支付金额，单位为分
      paymentArgs: 'A', // 将传递到功能页函数的自定义参数
      currencyType: 'USD' // 货币符号，页面显示货币简写 US$ 
    }
  },
  methods: {
    // 支付成功的回调接口
    paymentSuccess: function (e) {
      console.log(e);
      e.detail.extraData.timeStamp // 用 extraData 传递数据，详见下面功能页函数代码
    },
    // 支付失败的回调接口
    paymentFailed: function (e) {
      console.log(e);
    }
  }
})


用户调用 wx.requestPluginPayment 或点击 navigator 后，将会进行权限判断，然后直接拉起支付收银台或跳转到如下的支付功能页：

配置功能页函数

支付功能页需要插件开发者在插件所有者小程序中提供一个函数来响应插件中的支付调用。即，在插件中跳转到支付功能页或调用 wx.requestPluginPayment 时，这个函数就会在合适的时机被调用，来帮助完成支付。如果不提供功能页函数，功能页调用将通过 fail 事件返回失败。

支付功能页函数应以导出函数的形式提供在插件所有者小程序的根目录下的 functional-pages/request-payment.js 文件中，名为 beforeRequestPayment。该函数应接收两个参数：

参数名	类型	说明
paymentArgs	Object	即通过 functional-page-navigator 的 arg 参数中的 paymentArgs 字段传递到功能页的自定义数据
callback	Function	回调函数，调用该函数后，小程序将发起支付（类似于 wx.requestPayment）

callback 函数的参数：

参数名	类型	说明
error	Object	失败信息，若无失败，应返回 null
requestPaymentArgs	Object	支付参数，用于调用 wx.r

... (content truncated)

```html
<!-- plugin/components/pay.wxml -->
<button bindtap="handlePay">支付 0.01 元</button>

```

```javascript
// plugin/components/pay.js
Component({
  data: {
    fee: 1,             // 支付金额，单位为分
    paymentArgs: 'A', // 将传递到功能页函数的自定义参数
    currencyType: 'USD' // 货币符号，页面显示货币简写 US$ 
    version: 'develop', // 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布
  },
  methods: {
    handlePay() {
        const { fee, paymentArgs, currencyType, version } = this.data
        wx.requestPluginPayment({
            fee,
            paymentArgs,
            currencyType,
            version,
            success(r) {
                console.log(r)
            },
            fail(e) {
                console.error(e)
            }
        })
    }
  }
})

```

```html
<!-- plugin/components/pay.wxml -->
<!-- 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布 -->
<!-- name 参数固定为 "requestPayment" -->
<functional-page-navigator
  version="develop"
  name="requestPayment"
  args="{{ args }}"
  bind:success="paymentSuccess"
  bind:fail="paymentFailed"
>
  <button class="payment-button">支付 0.01 元</button>
</functional-page-navigator>

```

---

## 22. Skyline 渲染引擎 / 从 WebView 迁移 / 迁移工具

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/migration/migration-tool.html](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/migration/migration-tool.html)

Skyline 渲染引擎 /从 WebView 迁移 /迁移工具
Skyline 迁移工具

为了方便开发者从 WebView 迁移到 Skyline，我们将一些最佳实践和常见的兼容问题都整理成一个检测工具 Skylint

Skylint 不仅会罗列出有兼容问题的具体代码行，对一些明确的兼容问题，也提供自动修改代码的操作，旨在最大程度降低迁移成本

更多说明和用法请前往 Github 查看

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 23. 自定义组件 / 数据监听器

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html)

自定义组件 /数据监听器
数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。

使用数据监听器

有时，在一些数据字段被 setData 设置时，需要执行一些操作。

例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。

Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2,
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})


在开发者工具中预览效果

监听字段语法

数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12]
    },
  }
})


如果需要监听所有子数据字段的变化，可以使用通配符 ** 。

Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field
    },
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})


特别地，仅使用通配符 ** 可以监听全部 setData 。

Component({
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
  },
})

注意事项
数据监听器监听的是 setData 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
如果在数据监听器函数中使用 setData 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2,
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})

```

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12]
    },
  }
})

```

```js
Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field
    },
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})

```

---

## 24. 连接硬件能力 / 音视频通话+摄像头（for 硬件） / VoIP 通话插件 / 接口文档 / onVoipEvent

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/device/voip-plugin/api/onVoipEvent.html](https://developers.weixin.qq.com/miniprogram/dev/framework/device/voip-plugin/api/onVoipEvent.html)

连接硬件能力 /音视频通话+摄像头（for 硬件） /VoIP 通话插件 /接口文档 /onVoipEvent
function onVoipEvent(function listener)
功能描述

监听 VoIP 通话相关事件。事件绑定需要在通话开始前完成。

注意：不要在 onLoad、onShow 等生命周期内绑定事件，可能会因为生命周期多次调用而重复绑定。

参数
function listener

事件监听函数

回调参数
Object event
属性	类型	说明	最低版本
eventName	string	事件名称。请参考后文描述。	
roomId	string	通话房间号。除 bindContact、callPageOnShow 事件外提供	2.4.0
groupId	string	与 roomId 相同	
data	Object	某个事件额外的参数。不同事件的字段不同，请参考后文描述	
返回值

function

取消监听函数，调用后取消监听事件。该函数无参数，无返回值。

事件描述
1. startVoip

通话开始。

2. abortVoip

通话异常中断。

data 参数

属性	类型	说明
keepTime	number	通话时长
status	string	异常说明，取值参见后文
error	Object	错误对象
error.errMsg	Object	错误信息

status 取值

status	描述
abortByListener	通话因本端异常中断（接听方触发）
abortByCaller	通话因本端异常中断（拨打方触发）
unknown	通话因对端异常中断

常见 errMsg

room status is abort：status=unknown，接收到对端通话异常时触发，需要根据 roomId 关联对端触发的 abortVoip 事件判断真正的异常原因。
listener waitOtherToJoin timeout：status=abortByListener，接听方加入房间后，拨打方一直未成功加入（可能是网络慢等原因）或异常退出，接听方等待 20s 超时后触发。此时建议分析接听方的情况来排查。
call interrupted due to close passive float ball：用户将小程序切后台后，会展示小程序浮窗，用户通过浮窗关闭小程序时触发。
in comming call：小程序通话被其他来电打断时触发。
call interrupted due to native reason：一般是由于通话过程中一段时间未收到数据包（一般是网络原因），被踢出房间中断通话。
3. hangOnVoip

通话被接听（仅接听方触发）。

4. cancelVoip

通话未接通，拨打方取消通话。

data 参数

属性	类型	说明
status	string	取消原因说明，取值参见后文

status 取值

status	描述
manual	用户点击界面挂断按钮取消通话。（仅拨打方）
unloadCallPage	插件页面被销毁导致取消通话。（仅拨打方）
forceFromApp	小程序调用 forceHangUpVoip 取消通话。（仅拨打方）
other	拨打方取消通话。（仅接听方）
5. rejectVoip

通话未接通，接听方拒接。

data 参数

属性	类型	说明
status	string	拒接原因说明，取值参见后文

status 取值

status	描述
manual	用户点击界面挂断按钮拒接通话（仅接听方）
unloadCallPage	插件页面被销毁导致拒接通话（仅接听方）
forceFromApp	小程序调用 forceHangUpVoip 拒接通话（仅接听方）
other	接听方拒接（仅拨打方）
6. hangUpVoip

通话已接通，拨打方/接听方挂断通话。

data 参数

属性	类型	说明
keepTime	number	通话时长
status	string	挂断方说明，取值参见后文
origin	string	挂断原因说明，取值参见后文

status 取值

status	描述
endByListener	接听方挂断
endByCaller	拨打方挂断

origin 取值

为了保持向下兼容，hangUpVoip 事件额外使用 origin 字段提供具体的挂断原因信息。

origin	描述
manual	用户点击界面挂断按钮挂断通话（仅挂断方）
unloadCallPage	插件页面被销毁导致挂断通话（仅挂断方）
forceFromApp	小程序调用 forceHangUpVoip 导致挂断通话（仅挂断方）
other	对方挂断通话
timeLimit	超过最大通话时长
7. endVoip

通话结束。

data 参数

属性	类型	说明
keepTime	number	通话时长
callerName	string	拨打方名字
listenerName	string	接听方名字
roomType	string	房间类型
isCaller	boolean	是否是拨打方
businessType	number	业务类型
8. busy

通话未接通，接听方占线（仅拨打方触发）。

9. calling

通话过程中, 双方都会每秒触发一次。

data 参数

属性	类型	说明
keepTime	number	通话时长
10. timeout

通话超时未接听。

11. joinedRoomByCaller

拨打方加入房间成功（仅拨打方触发）。

12. joinFailCaller

拨打方加入房间失败（仅拨打方触发）。

data 参数

属性	类型	说明
errMsg	string	错误消息
message	string	由于向下兼容原因，某些情况下 data 是一个 Error 对象
13. joinFailListener

接听方加入房间失败（仅接听方触发）。

data 参数

属性	类型	说明
errMsg	string	错误消息
message	string	由于向下兼容原因，某些情况下 data 是一个 Error 对象
14. finishVoip

通话完成。返回本次通话结算使用的实际时长。

需从后台获取最终时间后触发，触发时机晚于 endVoip。

data 参数

属性	类型	说明
keepTime	number	结算用通话时长
15. callPageOnShow

插件通话页面 onShow。

16. showCustomBox

用户点击通话页面自定义按钮，展示自定义组件。

data 参数

属性	类型	说明
callerId	string	拨打方 Id
listenerId	string	接听方 Id
17. hideCustomBox

用户隐藏自定义组件。

data 参数

属性	类型	说明
callerId	string	拨打方 Id
listenerId	string	接听方 Id
示例代码
const w

... (content truncated)

```js
const wmpfVoip = requirePlugin('wmpf-voip').default
const offVoipEvent = wmpfVoip.onVoipEvent(event => {
  console.info(`onVoipEvent`, event)
})

// 需要取消监听时调用
offVoipEvent()

```

---

## 25. 开放能力 / 用户信息 / UnionID 机制说明

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html)

开放能力 /用户信息 /UnionID 机制说明
UnionID 机制说明

如果开发者拥有多个移动应用、网站应用、和公众账号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台账号下的移动应用、网站应用和公众账号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。

UnionID获取途径

绑定了开发者账号的小程序，可以通过以下途径获取 UnionID。

开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户授权。

小程序端调用云函数时，可在云函数中通过 Cloud.getWXContext 获取 UnionID。

用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过getPaidUnionId接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。

微信开放平台绑定小程序流程

登录微信开放平台 — 管理中心 — 小程序 — 绑定小程序

官方教程 · “UnionID关联”功能介绍及运营建议
实现同一个用户在公众号、小程序、APP、官方网站等不同场景里的身份统一识别、信息同步和行为跟踪
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 26. 插件 / 插件调用 API 的限制

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html](https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html)

插件 /插件调用 API 的限制
插件调用 API 的限制

插件可以调用的 API 与小程序不同，主要有两个区别：

插件的请求域名列表与小程序相互独立；
一些 API 不允许插件调用（这些函数不存在于 wx 对象下）。

有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考 插件功能页。

各接口在插件中的支持情况可以在各接口的文档中确认，接口文档中会有如 「本接口从基础库 2.1.0 起支持在小程序插件中使用」 的标识；如果没有标识，说明插件暂未支持，如果有需要的具体使用场景和需求，可以在开发者社区中反馈。

以下表格汇总了目前插件可以调用的 API 及其对应版本要求，但这份表格已经不再更新，是否可以使用，请以具体接口文档中的说明和真机表现为准。

插件支持接口情况参考汇总（表格已停止维护）
Bugs & Tips
wx.reportAnalytics 可以被正常调用，但目前不会进行统计展示。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 27. 小程序框架 / 逻辑层 / 注册小程序

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)

小程序框架 /逻辑层 /注册小程序
注册小程序

每个小程序都需要在 app.js 中调用 App 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

详细的参数含义和使用请参考 App 参考文档 。

// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})


整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。

// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})

```

```js
// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data

```

---

## 28. 开放能力 / 数据分析

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/data-analysis.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/data-analysis.html)

开放能力 /数据分析
数据分析接口

开发者通过数据分析接口，可获取到小程序的各项数据指标，便于进行数据存储和整理。数据分析详细功能介绍及指标解释参见数据分析文档。

相关接口
概况
访问趋势
日趋势
周趋势
月趋势
访问分布
访问留存
日留存
周留存
月留存
访问页面
用户画像
自定义数据上报
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 29. 开放能力 / 广告 / 原生模板广告

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/ad/custom-ad.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/ad/custom-ad.html)

开放能力 /广告 /原生模板广告
原生模板 广告

小程序广告流量主操作指引：文档地址
开发者可以使用 ad-custom 组件创建 原生模板 广告组件，原生模板 广告组件在创建后会自动拉取广告数据并显示。

广告尺寸设置

原生模板 广告不允许直接设置样式属性，默认宽度为100%（width: 100%），高度会自动等比例计算，因此开发者可以设置广告外层组件的宽度调整广告的尺寸。 广告外层组件的宽度和具体模板相关，具体可以参考模板编辑器文档。

/* 外层组件的宽度可设置成100%或具体数值 */
.adContainer {
  width: 100%;
}

<view class="adContainer">
  <ad-custom unit-id="xxxx"></ad-custom>
</view>

广告事件监听

原生模板 广告在创建后会自动拉取广告。开发者可以通过 ad-custom 组件的 onload 和 onerror 事件监听广告拉取成功或失败，同时可通过onclose事件监听广告关闭。

<view class="adContainer">
  <ad-custom unit-id="xxxx" bindload="adLoad" binderror="adError" bindclose="adClose"></ad-custom>
</view>

Page({
  adLoad() {
    console.log('原生模板广告加载成功')
  },
  adError(err) {
    console.log('原生模板广告加载失败', err)
  },
  adClose() {
    console.log('原生模板广告关闭')
  },
})

广告定时刷新

开发者可以在创建 原生模板 广告时传入 ad-intervals 参数实现广告的定时刷新，ad-intervals 参数为数字类型，单位为秒。注意：自动刷新的间隔不能低于30秒，因此 ad-intervals 的参数值必须大于或等于30。

<view class="adContainer">
  <ad-custom unit-id="xxxx" ad-intervals="30"></ad-custom>
</view>

监听广告隐藏
矩阵格子广告触发型特殊说明： 用户在点击右上角关闭按钮时，广告将通过控制 元素的样式 display: none 使其隐藏。 开发者可通过 ad-custom 组件的 onhide 事件监听隐藏事件，在必要时机通过改些 display 样式使广告重新展示。
<ad-custom unit-id="xxxx" bindhide="adHide"></ad-custom>

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```css
/* 外层组件的宽度可设置成100%或具体数值 */
.adContainer {
  width: 100%;
}

```

```html
<view class="adContainer">
  <ad-custom unit-id="xxxx"></ad-custom>
</view>

```

```html
<view class="adContainer">
  <ad-custom unit-id="xxxx" bindload="adLoad" binderror="adError" bindclose="adClose"></ad-custom>
</view>

```

---

## 30. 开放能力 / 用户信息 / 生物认证

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/bio-auth.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/bio-auth.html)

开放能力 /用户信息 /生物认证
生物认证

小程序通过 SOTER 提供以下生物认证方式。

目前支持指纹识别、人脸识别认证。设备支持的生物认证方式可使用 wx.checkIsSupportSoterAuthentication 查询

调用流程

流程步骤说明

调用 wx.startSoterAuthentication，获取 resultJSON 和 resultJSONSignature

（可选）签名校验。此处 resultJSONSignature 使用 SHA256withRSA/PSS 作为签名算法进行验签。此公式数学定义如下: bool 验签结果=verify(用于签名的原串，签名串，验证签名的公钥)

微信提供后台接口用于可信的密钥验签服务，微信将保证该接口返回的验签结果的正确性与可靠性，并且对于 Android root 情况下该接口具有上述特征（将返回是否保证root情况安全性）。

接口地址：

POST http://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token=%access_token


post 数据内容（JSON 编码）:

{"openid":"$openid", "json_string" : "$resultJSON", "json_signature" : "$resultJSONSignature" }


请求返回数据内容（JSON 编码）:

// 验证成功返回
{"is_ok":true}
// 验证失败返回
{"is_ok":false}
// 接口调用失败
{"errcode":"xxx,"errmsg":"xxxxx"}

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```text
POST http://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token=%access_token

```

```json
{"openid":"$openid", "json_string" : "$resultJSON", "json_signature" : "$resultJSONSignature" }

```

```text
// 验证成功返回
{"is_ok":true}
// 验证失败返回
{"is_ok":false}
// 接口调用失败
{"errcode":"xxx,"errmsg":"xxxxx"}

```

---

## 31. 开放能力 / 视频号 / 视频号主页

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/channels-profile.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/channels-profile.html)

开放能力 /视频号 /视频号主页
视频号主页

从基础库 2.21.2 开始支持

从2023年12月20日起，通过wx.openChannelsUserProfile跳转到视频号主页将不再受主体限制，使用此功能时请注意遵守运营规范。

若小程序与视频号的主体相同或为关联主体，可以通过 wx.openChannelsUserProfile 跳转到视频号主页。

## 主体判断逻辑

若小程序与视频号的主体相同，则可以调用相关接口。 若小程序与视频号的主体不同，需同时满足以下3个条件则可以调用相关接口： 1. 小程序绑定了微信开放平台账号 2. 小程序与微信开放平台账号的关系为同主体或关联主体 3. 微信开放平台账号的主体与关联主体列表中包含视频号的主体 关联主体申请流程可以参考：https://kf.qq.com/faq/190726e6JFja190726qMJBn6.html

参数获取

finderUserName表示视频号ID，获取视频号ID的需要登录视频号助手，在首页可以查看自己的视频号ID。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 32. 开放能力 / 获取小程序链接 / 获取 URL Link

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/url-link.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/url-link.html)

开放能力 /获取小程序链接 /获取 URL Link
获取加密 URL Link

自 2023 年 12 月 19 日起，对URL Link进行升级，详细调整说明可见《URL Scheme 和 URL Link优化公告》。改动点概览如下：

1. 支持开发者在原有加密 URL Link 后面拼接参数；

2. 取消 URL Link 一人一链的限制，支持同一条连接被多名用户访问；

3. 每个小程序每天 URL Scheme 和 URL Link 总打开次数上限为300万。

获取方式

通过服务端接口可以获取打开小程序任意页面的 URL Link。适用于从短信、邮件、网页、微信内等场景打开小程序。 通过 URL Link 从微信外打开小程序的场景值为 1194。当用户在微信内访问 URL Link ，会调整为开放标签打开小程序，场景值为1167。
生成的 URL Link 如下所示：

https://wxaurl.cn/*TICKET* 或 https://wxmpurl.cn/*TICKET*

拼接参数

将原有 URL Link 平滑升级为加密 URL Link，支持开发者自行在链接后面拼接参数CUSTOM PARAMETE,拼接参数后的 URL Link 如下所示：

https://wxaurl.cn/*TICKET*?cq=*CUSTOM PARAMETER* 或 https://wxmpurl.cn/*TICKET*?cq=*CUSTOM PARAMETER*


注意：

CUSTOM PARAMETE是一种特殊的query，最大256个字符，只支持数字，大小写英文以及部分特殊字符：!#$&'()*+,/:;=?@-._~%`，需要url_encode;
在本次规则调整生效前已经生成的 URL Scheme 可继续正常使用，并可直接进行CUSTOM PARAMETE参数拼接；
拼接参数后的加密 URL Link 打开小程序的场景值不变，微信外仍为1194，微信内仍会调整为开放标签打开小程序，场景值为1167。
频率限制

生成端：每天生成 URL Scheme（加密+明文） 和 URL Link 的总数量上限为50万；

打开端：每天通过 URL Scheme（加密+明文） 和 URL Link 打开小程序的总次数上限为300万。

注意事项
只能生成已发布的小程序的 URL Link。
在微信内或者安卓手机打开 URL Link 时，默认会先跳转官方 H5 中间页，如果需要定制 H5 内容，可以使用云开发静态网站。
开放范围

针对非个人主体小程序开放。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```text
https://wxaurl.cn/*TICKET* 或 https://wxmpurl.cn/*TICKET*

```

```text
https://wxaurl.cn/*TICKET*?cq=*CUSTOM PARAMETER* 或 https://wxmpurl.cn/*TICKET*?cq=*CUSTOM PARAMETER*

```

---

## 33. 开放能力 / 打开 App

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)

开放能力 /打开 App
打开 App

此功能需要用户主动触发才能打开 APP，所以不由 API 来调用，需要用 open-type 的值设置为 launchApp 的 button 组件的点击来触发。

当小程序从 APP 打开的场景打开时（场景值 1069），小程序会获得返回 APP 的能力，此时用户点击按钮可以打开拉起该小程序的 APP。即小程序不能打开任意 APP，只能 跳回 APP。

在一个小程序的生命周期内，只有在特定条件下，才具有打开 APP 的能力，这个能力的规则如下：

当小程序从 1069 场景打开时，可以打开 APP。

当小程序从非 1069 的打开时，会在小程序框架内部会管理的一个状态，为 true 则可以打开 APP，为 false 则不可以打开 APP。这个状态的维护遵循以下规则：

当小程序从以下场景打开时，保持上一次打开小程序时打开 App 能力的状态：
从其他小程序返回小程序（场景值1038）时（基础库 2.2.4 及以上版本支持）
小程序从聊天顶部场景（场景值1089）中的「最近使用」内打开时
长按小程序右上角菜单唤出最近使用历史（场景值1090）打开时
发现栏小程序主入口，「最近使用」列表（场景值1001）打开时（基础库2.17.3及以上版本支持）
浮窗（场景值1131、1187）打开时（基础库2.17.3及以上版本支持）
当小程序从非以上场景打开时，不具有打开 APP 的能力，该状态置为 false。

使用方法
小程序端

需要将 button 组件 open-type 的值设置为 launchApp。如果需要在打开 APP 时向 APP 传递参数，可以设置 app-parameter 为要传递的参数。通过 binderror 可以监听打开 APP 的错误事件。

示例代码
<button open-type="launchApp" app-parameter="wechat" binderror="launchAppError">打开APP</button>

Page({
  launchAppError (e) {
    console.log(e.detail.errMsg)
  }
})

error 事件参数说明
值	说明
invalid scene	调用场景不正确，即此时的小程序不具备打开 APP 的能力。
APP 端

APP 需要接入 OpenSDK。 文档请参考 iOS / Android

Android 第三方 app 需要处理 ShowMessageFromWX.req 的微信回调，iOS 则需要将 appId 添加到第三方 app 工程所属的 plist 文件 URL types 字段。 app-parameter 的获取方法，参数解析请参考 Android SDKSample 中 WXEntryActivity 中的 onResp 方法以及 iOS SDKSample 中 WXApiDelegate 中的 onResp 方法。

iOS 示例代码
-(void)onResp:(BaseResp *)resp 
{
     if ([resp isKindOfClass:[WXLaunchMiniProgramResp class]])
     {
          NSString *string = resp.extMsg;
          // 对应小程序组件 <button open-type="launchApp"> 中的 app-parameter 属性
     }
}

Android 示例代码

WXEntryActivity中

public void onResp(BaseResp resp) {
    if (resp.getType() == ConstantsAPI.COMMAND_LAUNCH_WX_MINIPROGRAM) {
        WXLaunchMiniProgram.Resp launchMiniProResp = (WXLaunchMiniProgram.Resp) resp;
        String extraData =launchMiniProResp.extMsg; //对应小程序组件 <button open-type="launchApp"> 中的 app-parameter 属性
    }
}


如你的 App 是使用平台推出的多端框架开发的，即可只需要调用下方的 JSAPI 即可轻松实现，无需按照上述指引在 Android 或 iOS 工程中进行接入。

wx.miniapp.launchMiniProgram 该接口已将从小程序返回 App 的回调内容进行封装，按照示例使用 res.data 即可获取
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<button open-type="launchApp" app-parameter="wechat" binderror="launchAppError">打开APP</button>

```

```js
Page({
  launchAppError (e) {
    console.log(e.detail.errMsg)
  }
})

```

```text
-(void)onResp:(BaseResp *)resp 
{
     if ([resp isKindOfClass:[WXLaunchMiniProgramResp class]])
     {
          NSString *string = resp.extMsg;
          // 对应小程序组件 <button open-type="launchApp"> 中的 app-parameter 属性
     }
}

```

---

## 34. 小程序框架 / 视图层 / WXML

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

小程序框架 /视图层 /WXML
WXML

WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。

要完整了解 WXML 语法，请参考WXML 语法参考。

用以下一些简单的例子来看看 WXML 具有什么能力：

数据绑定
<!--wxml-->
<view> {{message}} </view>

// page.js
Page({
  data: {
    message: 'Hello MINA!'
  }
})

列表渲染
<!--wxml-->
<view wx:for="{{array}}"> {{item}} </view>

// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5]
  }
})

条件渲染
<!--wxml-->
<view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
<view wx:elif="{{view == 'APP'}}"> APP </view>
<view wx:elif="{{view == 'MINA'}}"> MINA </view>
<view wx:else> UNKNOWN </view>

// page.js
Page({
  data: {
    view: 'MINA'
  }
})

模板
<!--wxml-->
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>

// page.js
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})


具体的能力以及使用方式在以下章节查看：

数据绑定、列表渲染、条件渲染、模板、引用

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<!--wxml-->
<view> {{message}} </view>

```

```js
// page.js
Page({
  data: {
    message: 'Hello MINA!'
  }
})

```

```html
<!--wxml-->
<view wx:for="{{array}}"> {{item}} </view>

```

---

## 35. Skyline 渲染引擎 / 支持与差异 / WXSS 样式

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/wxss.html](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/wxss.html)

Skyline 渲染引擎 /支持与差异 /WXSS 样式
Skyline WXSS 样式支持与差异
模块支持
模块	支持情况	备注
CSS Animation	✓	安卓 8.0.37，iOS 8.0.39，支持情况见下表
背景与边框	✓	常用的基本支持，详见属性支持
盒子模型	✓	支持 border-box 和 content-box，没有 BFC
Inline 布局	×	开发中
Inline-Block 布局	×	仅支持在 text 组件里的嵌套结构使用，完整版本开发中
Block 布局	✓	详见开启默认 Block 布局
Flex 布局	✓	包括 inline-flex 布局
字体	✓	基本支持，也支持自定义字体
Positioned 布局	✓	支持情况见下表。sticky 可使用 sticky-header/sticky-section 替代
CSS Transition	✓	
CSS Variable（CSS 变量）	✓	安卓 8.0.35，iOS 8.0.38
Media queries	✓	只支持 DarkMode
Font-face	✓	只支持 ttf 格式
选择器支持
类别	示例	支持度	备注
通配选择器	* {}	×	
元素选择器	tag {}	✓	
类选择器	.class {}	✓	
ID 选择器	#id {}	✓	
分组选择器	a, b {}	✓	
直接子代选择器	a > b {}	✓	
后代选择器	a b {}	✓	
属性选择器	[attr] {}	×	
一般兄弟选择器	a ~ b {}	✓	8.0.49
紧邻兄弟选择器	a + b {}	✓	8.0.49
伪类选择器	:active {}	✓	支持 :first-child / :last-child；微信 8.0.49 起（对应 Skyline 1.3.0）支持 :not / :only-child / :empty；微信 8.0.50 起（对应 Skyline 1.3.3）支持 :nth-child
伪元素选择器	::before {}	✓	只支持 ::before 和 ::after
属性支持
样式属性	支持格式	默认值	备注
display	none / flex / block	flex	默认值可通过配置改成 block
position	relative / absolute / fixed	relative	fixed 在微信客户端 8.0.43 版本开始支持，只支持相对于窗口 viewport 定位，不支持 top / left / bottom / right 默认值 auto 解析，z-index 只作用在兄弟节点；sticky 可使用 sticky-header/sticky-section 替代
overflow	hidden / visible	visible	scroll 不支持，只能通过 scroll-view 实现；不支持单独设置 overflow-x/y
pointer-events	auto / none	auto	
box-sizing	border-box / content-box	border-box	
transform	none / <transform-function>	none	
transform-origin	left / center / right / top / bottom / <length>{1, 2}	50% 50%	
z-index	<float>	0	不支持层叠上下文，只对兄弟节点生效；不支持在 scroll-view 下的直接子节点上应用
visibility	visible / hidden	visible	
color	<color>	black	
opacity	<float>	1	
align-items	stretch / center / flex-start / flex-end / baseline	stretch	
align-self	auto / stretch / center / flex-start / flex-end / baseline	auto	
align-content	stretch / center / flex-start / flex-end / space-between / space-around	auto	
justify-content	center / flex-start / flex-end / space-between / space-around / space-evenly	flex-start	
flex-direction	row / row-reverse / column / column-reverse	column	
flex-wrap	nowrap / wrap / wrap-reverse	nowrap	
flex-grow	<float>	0	
flex-shrink	<float>	1	
flex-basis	<length>	auto	
order	<float>	0	
gap	<length>	0	
flex			简写属性，支持解析但以展开属性为准
background-color	<color>	transparent	
background-image	none / <image>	none	不支持多张图片
background-size	contain / cover / [<length> | auto]{1, 2}	auto	
background-position	left / center / right / top / bottom / <length>	0 0	完全支持 <bg-position>#，请参考 MDN
background-repeat	repeat-x / repeat-y / repeat / no-repeat	repeat	
background			简写属性，支持解析但以展开属性为准
width	<length>	auto	
height	<length>	auto	
min-width	<length>	auto	
min-height	<length>	none	
max-width	<length>	auto	
max-height	<length>	none	
left	<length>	auto	
right	<length>	auto	
top	<length>	auto	
bottom	<length>	auto	
padding	<length>{1,4}	0 0 0 0	
padding-left	<length>	0	
padding-top	<length>	0	
padding-right	<length>	0	
padding-bottom	<length>	0	
margin	<length>{1,4}	0 0 0 0	
margin-left	<length>	0	
margin-top	<length>	0	
margin-right	<length>	0	
margi

... (content truncated)

```json
rendererOptions: {
  "skyline": {
    "defaultDisplayBlock": true,
  }
}

```

```json
rendererOptions: {
  "skyline": {
    "defaultContentBox": true,
  }
}

```

```json
rendererOptions: {
  "skyline": {
    "tagNameStyleIsolation": "legacy",
  }
}

```

---

## 36. 自定义组件 / 自定义组件扩展

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html)

自定义组件 /自定义组件扩展
自定义组件扩展

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本 2.2.3 开始支持。

扩展后的效果

为了更好的理解扩展后的效果，先举一个例子：

在开发者工具中预览效果

// behavior.js
module.exports = Behavior({
  definitionFilter(defFields) {
    defFields.data.from = 'behavior'
  },
})

// component.js
Component({
  data: {
    from: 'component'
  },
  behaviors: [require('behavior.js')],
  ready() {
    console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
  }
})


通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，上述例子就是修改了自定义组件中的 data 定义段里的内容。

使用扩展

Behavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。 definitionFilter 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的 component/behavior 的定义对象，第二个参数是该 behavior 所使用的 behavior 的 definitionFilter 函数列表。

以下举个例子来说明：

// behavior3.js
module.exports = Behavior({
    definitionFilter(defFields, definitionFilterArr) {},
})

// behavior2.js
module.exports = Behavior({
  behaviors: [require('behavior3.js')],
  definitionFilter(defFields, definitionFilterArr) {
    // definitionFilterArr[0](defFields)
  },
})

// behavior1.js
module.exports = Behavior({
  behaviors: [require('behavior2.js')],
  definitionFilter(defFields, definitionFilterArr) {},
})

// component.js
Component({
  behaviors: [require('behavior1.js')],
})


上述代码中声明了1个自定义组件和3个 behavior，每个 behavior 都使用了 definitionFilter 定义段。那么按照声明的顺序会有如下事情发生：

当进行 behavior2 的声明时就会调用 behavior3 的 definitionFilter 函数，其中 defFields 参数是 behavior2 的定义段， definitionFilterArr 参数即为空数组，因为 behavior3 没有使用其他的 behavior 。
当进行 behavior1 的声明时就会调用 behavior2 的 definitionFilter 函数，其中 defFields 参数是 behavior1 的定义段， definitionFilterArr 参数是一个长度为1的数组，definitionFilterArr[0] 即为 behavior3 的 definitionFilter 函数，因为 behavior2 使用了 behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用 behavior3 的 definitionFilter 函数，如果需要调用，在此处补充代码 definitionFilterArr[0](defFields) 即可，definitionFilterArr 参数会由基础库补充传入。
同理，在进行 component 的声明时就会调用 behavior1 的 definitionFilter 函数。

简单概括，definitionFilter 函数可以理解为当 A 使用了 B 时，A 声明就会调用 B 的 definitionFilter 函数并传入 A 的定义对象让 B 去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和 D 的 definitionFilter 函数去过滤 A 的定义对象。

代码示例：

在开发者工具中预览效果

真实案例

下面利用扩展简单实现自定义组件的计算属性功能:

// behavior.js
module.exports = Behavior({
  lifetimes: {
    created() {
      this._originalSetData = this.setData // 原始 setData
      this.setData = this._setData // 封装后的 setData
    }
  },
  definitionFilter(defFields) {
    const computed = defFields.computed || {}
    const computedKeys = Object.keys(computed)
    const computedCache = {}

    // 计算 computed
    const calcComputed = (scope, insertToData) => {
      const needUpdate = {}
      const data = defFields.data = defFields.data || {}

      for (let key of computedKeys) {
        const value = computed[key].call(scope) // 计算新值
        if (computedCache[key] !== value) needUpdate[key] = computedCache[key] = value
        if (insertToData) data[key] = needUpdate[key] // 直接插入到 data 中，初始化时才需要的操作
      }

      return needUpdate
    }

    // 重写 setData 方法
    defFields.methods = defFields.methods || {}
    defFields.methods._setData 

... (content truncated)

```js
// behavior.js
module.exports = Behavior({
  definitionFilter(defFields) {
    defFields.data.from = 'behavior'
  },
})

// component.js
Component({
  data: {
    from: 'component'
  },
  behaviors: [require('behavior.js')],
  ready() {
    console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
  }
})

```

```js
// behavior3.js
module.exports = Behavior({
    definitionFilter(defFields, definitionFilterArr) {},
})

// behavior2.js
module.exports = Behavior({
  behaviors: [require('behavior3.js')],
  definitionFilter(defFields, definitionFilterArr) {
    // definitionFilterArr[0](defFields)
  },
})

// behavior1.js
module.exports = Behavior({
  behaviors: [require('behavior2.js')],
  definitionFilter(defFields, definitionFilterArr) {},
})

// component.js
Component({
  behaviors: [require('behavior1.js')],
})

```

---

## 37. 基础能力 / AI/AR / VisionKit 视觉能力 / 身份证检测

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/idcard.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/idcard.html)

基础能力 /AI/AR /VisionKit 视觉能力 /身份证检测
身份证检测

VisionKit 从基础库 3.3.0 版本 后开始支持。

身份证检测 能力作为与 其他 VisionKit 能力 平行的能力接口。

该能力，一般用于用户进行 身份证识别 或者 身份证裁剪 等功能的开发。

方法定义

身份证检测，目前只支持通过 视觉模式，即输入一张静态图片进行身份证识别，返回身份证对应信息。

可以通过配置 getAffineImg ，决定每次识别是否返回 身份证区域裁剪矩阵。

输入身份证图片要求

输入的身份证图片，尽量以 正常的角度拍摄。不同角度带来的 透视效果，会影响识别的 准确度。

视觉模式接口

首先需要创建 VKSession 的配置，然后通过 VKSession.start 启动 VKSession 实例。

开启VKSession，并添加返回对应身份证信息监听事件，示例代码：

// VKSession 配置
const session = wx.createVKSession({
    track: {
        IDCard: {
            mode: 2 // 照片模式
        }
    },
    version: 'v1',
})

// VKSession start
session.start(err => {

  // 静态图片估计模式下，每调一次 detectIDCard 接口就会触发一次 updateAnchors 事件
  session.on('updateAnchors', anchors => {
      // 处理返回的身份证信息
      if (anchors && anchors[0]) {
          // 存在数组，证明存在身份证信息
          const anchor = anchors[0];

          // 识别信息
          const isComplete = anchor.isComplete; // 身份证是否完整
          const label = anchor.label; // 身份证面信息（0 照片面 / 1 国徽面 ）
          const orientation = anchor.orientation; // 身份证朝向 （0 朝上 1 朝下 2 朝下 3 朝左）
          const box = anchor.box; // 身份证坐标框点数组 （0 左上点 1 右上点 2 右下点 3 左下点）

          // 裁剪信息，接口 getAffineImg 为 true 时会返回。
          const affineImgWidth = anchor.affineImgWidth;
          const affineImgHeight = anchor.affineImgHeight;
          const affineMat = anchor.affineMat;

          // 存在裁剪信息，可以结合原图获取裁剪后的身份证图片
          if (affineImgWidth && affineImgHeight && affineMat) {
            /*
              * affineMat 3x3仿射变换矩阵，行主序
              *  [0 1 2
              *   3 4 5
              *   6 7 8]
              */
            /*
              * canvas 2d setTransform
              * setTransform(a, b, c, d, e, f)
              *  [a c e
              *   b d f
              *   0 0 1]
              */
             // 可以利用离屏的Canvas2D，结合原图与裁剪矩阵，进行具体的身份证图片裁剪。
          }
      }

  })
  // 图片没有识别到身份证，会触发一次 removeAnchors
  session.on('removeAnchors', anchors => {
      console.log("没有识别到身份证")
  })
});



调用身份证识别，示例代码：


// 调用具体的身份证图片识别接口
session.detectIDCard({
    // 识别身份证图片的 ArrayBuffer，Uint8ClampedArray，RGBA
    // 比如可以通过 canvas（2D）的 context.getImageData 获取
    frameBuffer: imgDataBuffer,
    // 传入识别图片的原始宽度
    width: imgOriginWidth,
    // 传入识别图片的原始高度
    height: imgOriginHeight,
    // 是否获取裁剪图片信息
    getAffineImg: true,
})
// 调用后，识别处理完毕后
// 识别成功会触发 updateAnchors 回调，处理失败会触发 removeAnchors 回调

输出说明

anchor 信息

struct anchor
{
  isComplete,  // 身份证是否完整
  label,       // 身份证面信息（0 照片面 / 1 国徽面 ）
  orientation, // 身份证朝向 （0 朝上 1 朝下 2 朝下 3 朝左）
  box,         // 身份证坐标框点数组 （0 左上点 1 右上点 2 右下点 3 左下点）
  /* 身份证裁剪信息
   * getAffineImg 为 true 时返回 */
  affineImgWidth,   // 身份证裁剪宽度
  affineImgHeight,  // 身份证裁剪区域高度
  affineMat,        // 身份证裁剪矩阵
}

身份证坐标框点数组 box

长度为 4 的数组，表示 身份证位于原图中，框的坐标点位置。

Array<Point>(8) box


每个数组元素结构为:

struct Point { x, y }

身份证裁剪矩阵 affineMat

长度为 9 的数组，表示行主序 的 3x3仿射变换矩阵。可以结合 Canvas (2D) 以及原图进行具体的身份证图片裁剪。

程序示例
身份证照片识别示例

小程序示例 的 接口 - VisionKit视觉能力 - 照片身份证识别

开源地址：照片身份证识别

关于腾讯 文档中心 辟谣中心 客服中心

Copyright ©

... (content truncated)

```js

// 调用具体的身份证图片识别接口
session.detectIDCard({
    // 识别身份证图片的 ArrayBuffer，Uint8ClampedArray，RGBA
    // 比如可以通过 canvas（2D）的 context.getImageData 获取
    frameBuffer: imgDataBuffer,
    // 传入识别图片的原始宽度
    width: imgOriginWidth,
    // 传入识别图片的原始高度
    height: imgOriginHeight,
    // 是否获取裁剪图片信息
    getAffineImg: true,
})
// 调用后，识别处理完毕后
// 识别成功会触发 updateAnchors 回调，处理失败会触发 removeAnchors 回调

```

```js
struct anchor
{
  isComplete,  // 身份证是否完整
  label,       // 身份证面信息（0 照片面 / 1 国徽面 ）
  orientation, // 身份证朝向 （0 朝上 1 朝下 2 朝下 3 朝左）
  box,         // 身份证坐标框点数组 （0 左上点 1 右上点 2 右下点 3 左下点）
  /* 身份证裁剪信息
   * getAffineImg 为 true 时返回 */
  affineImgWidth,   // 身份证裁剪宽度
  affineImgHeight,  // 身份证裁剪区域高度
  affineMat,        // 身份证裁剪矩阵
}

```

---

## 38. 基础能力 / 分包加载 / 独立分包

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html)

基础能力 /分包加载 /独立分包
独立分包

微信客户端 6.7.2，基础库 2.3.0 及以上版本开始支持。开发者工具请使用 1.02.1808300 及以上版本，可 点此下载。

独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。

开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。

一个小程序中可以有多个独立分包。

小游戏在基础库 v2.12.2 开始支持独立分包，详见 小游戏独立分包指南。

配置方法

假设小程序目录结构如下：

├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils


开发者通过在app.json的subpackages字段中对应的分包配置项中定义independent字段声明对应分包为独立分包。

{
  "pages": [
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "moduleA",
      "pages": [
        "pages/rabbit",
        "pages/squirrel"
      ]
    }, {
      "root": "moduleB",
      "pages": [
        "pages/pear",
        "pages/pineapple"
      ],
      "independent": true
    }
  ]
}

限制

独立分包属于分包的一种。普通分包的所有限制都对独立分包有效。独立分包中插件、自定义组件的处理方式同普通分包。

此外，使用独立分包时要注意：

独立分包中不能依赖主包和其他分包中的内容，包括 js 文件、template、wxss、自定义组件、插件等（使用 分包异步化 时 js 文件、自定义组件、插件不受此条限制）
主包中的 app.wxss 对独立分包无效，应避免在独立分包页面中使用 app.wxss 中的样式；
App 只能在主包内定义，独立分包中不能定义 App，会造成无法预期的行为；
独立分包中暂时不支持使用插件。
注意事项
（1）关于 getApp()

与普通分包不同，独立分包运行时，App 并不一定被注册，因此 getApp() 也不一定可以获得 App 对象：

当用户从独立分包页面启动小程序时，主包不存在，App也不存在，此时调用 getApp() 获取到的是 undefined。 当用户进入普通分包或主包内页面时，主包才会被下载，App 才会被注册。
当用户是从普通分包或主包内页面跳转到独立分包页面时，主包已经存在，此时调用 getApp() 可以获取到真正的 App。

由于这一限制，开发者无法通过 App 对象实现独立分包和小程序其他部分的全局变量共享。

为了在独立分包中满足这一需求，基础库 2.2.4 版本开始 getApp 支持 [allowDefault] 参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中。

示例代码：

独立分包中
const app = getApp({allowDefault: true}) // {}
app.data = 456
app.global = {}

app.js 中
App({
  data: 123,
  other: 'hello'
})

console.log(getApp()) // {global: {}, data: 456, other: 'hello'}

（2）关于 App 生命周期

当从独立分包启动小程序时，主包中 App 的 onLaunch 和首次 onShow 会在从独立分包页面首次进入主包或其他普通分包页面时调用。

由于独立分包中无法定义 App，小程序生命周期的监听可以使用 wx.onAppShow，wx.onAppHide 完成。App 上的其他事件可以使用 wx.onError，wx.onPageNotFound 监听。

低版本兼容

在低于 6.7.2 版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。

注意：在兼容模式下，主包中的 app.wxss 可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用 app.wxss 中的样式。

官方教程 · 使用独立分包和分包预下载（上）
讲师：李艺，是腾讯云TVP 、小程序从0到1的作者，极客时间 微信小程序全栈开发实战课程讲师。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```text
├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils

```

```json
{
  "pages": [
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "moduleA",
      "pages": [
        "pages/rabbit",
        "pages/squirrel"
      ]
    }, {
      "root": "moduleB",
      "pages": [
        "pages/pear",
        "pages/pineapple"
      ],
      "independent": true
    }
  ]
}

```

```js
const app = getApp({allowDefault: true}) // {}
app.data = 456
app.global = {}

```

---

## 39. 调试 / Source Map

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/usability/sourceMap.html](https://developers.weixin.qq.com/miniprogram/dev/framework/usability/sourceMap.html)

调试 /Source Map
Source Map

目前只在 iOS 6.7.2 及以上版本支持

小程序/小游戏在打包时，会将所有 JavaScript 代码打包成一个文件，为了便于开发者在手机上调试时定位错误位置，小程序/小游戏提供了 Source Map 支持。

在开发者工具中开启 ES6 转 ES5、代码压缩时，会生成 Source Map 的 .map 文件。开发版小程序中，基础库会使用代码包中的 .map 文件，对 vConsole 中展示的错误信息堆栈进行重新映射（只对开发者代码文件进行）。

如果使用外部的编译脚本对源文件进行处理，只需将对应生成的 Source Map 文件放置在源文件的相同目录下

如：

pages/index.js
pages/index.js.map
app.js
app.js.map


开发者工具会读取、解析 Source Map 文件，并进行将其上传

后续可以在小程序后台的运营中心可以利用上传的 Source Map 文件进行错误分析

注意事项
Source Map 文件不计入代码包大小计算，也不会被包含在体验版/正式版代码包中。
inline sourcemap 不计入代码包大小计算。
开发版代码包中由于包含了 .map 文件，实际代码包大小会比体验版和正式版大。
官方教程 · 使用断点调试功能，及Source Map和真机调试2.0介绍
讲师：李艺，是腾讯云TVP 、小程序从0到1的作者，极客时间 微信小程序全栈开发实战课程讲师。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```text
pages/index.js
pages/index.js.map
app.js
app.js.map

```

---

## 40. 性能与体验 / 调试工具 / 性能面板

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/performance/panel.html](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/panel.html)

性能与体验 /调试工具 /性能面板
性能面板

从微信 6.5.8 开始，我们提供了性能面板让开发者了解小程序的性能。开发者可以在开发版小程序下打开性能面板，打开方法：进入开发版小程序，进入右上角更多按钮，点击「显示性能窗口」。

性能面板指标说明
指标	说明
CPU	小程序进程的 CPU 占用率，仅 Android 下提供
内存	小程序进程的内存占用（Total Pss)，仅 Android 下提供
启动耗时	小程序启动总耗时
下载耗时	小程序包下载耗时，首次打开或资源包需更新时会进行下载
页面切换耗时	小程序页面切换的耗时
帧率/FPS	
首次渲染耗时	页面首次渲染的耗时
再次渲染耗时	页面再次渲染的耗时（通常由开发者的 setData 操作触发）
数据缓存	小程序通过 Storage 接口储存的缓存大小
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 41. 小程序运行时 / 更新机制

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html)

小程序运行时 /更新机制
小程序更新机制

开发者在管理后台发布新版本的小程序之后，微信客户端会有若干个时机去检查本地缓存的小程序有没有新版本，并进行小程序的代码包更新。但如果用户本地有小程序的历史版本，此时打开的可能还是旧版本。

1. 启动时同步更新

在以下情况下，小程序启动时会同步更新代码包。同步更新会阻塞小程序的启动流程，影响小程序的启动耗时。

如果更新失败或超时，为了保障小程序的可用性，还是会使用本地版本打开。

定期检查发现版本更新

微信运行时，会定期检查最近使用的小程序是否有更新。如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序，尽可能保证用户能够尽快使用小程序的最新版本。

用户长时间未使用小程序

用户长时间未使用小程序时，为保障小程序版本的实时性，会强制同步检查版本更新，更新到最新版本后再打开小程序。

若用户处于弱网环境、下载最新版本失败等情况下，仍会启动本地的较低版本。

2. 启动时异步更新

即使启动前未发现更新，小程序每次冷启动时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包。但当次启动仍会使用客户端本地的旧版本代码，即新版本的小程序需要等下一次冷启动才会使用。

开发者手动触发更新

在启动时异步更新的情况下，如果开发者希望立刻进行版本更新，可以使用 wx.getUpdateManager API 进行处理。在有新版本时提示用户重启小程序更新新版本。

const updateManager = wx.getUpdateManager()

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function () {
  wx.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success(res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate()
      }
    }
  })
})

updateManager.onUpdateFailed(function () {
  // 新版本下载失败
})

3. 小程序管理后台的相关设置

小程序开发者可以通过在小程序管理后台进行设置，影响更新逻辑。

优先使用本地版本设置

若开发者判断某些较新的小程序版本无需强制用户同步更新到最新版本，可以在小程序管理后台「设置」-「版本设置」-「优先使用本地版本设置」中进行设置，设置后若同步更新时检查本地版本不低于该版本，则优先使用本地版本，同时将会异步下载最新版本的代码包。

小程序最低可用版本设置

若开发者判断某些较旧的小程序版本服务不再可用，可以在小程序管理后台「设置」-「版本设置」-「小程序最低可用版本设置」中进行设置。设置后若同步更新时检查本地版本低于该版本，则无法打开，并继续尝试下载最新版本、若异步更新，则会在检查到更新后提示用户重启小程序更新新版本。

注意
开发者在后台发布新版本之后，无法立刻影响到所有现网用户，正常情况下，在全量发布 24 小时之后，新版本可以覆盖 99% 以上的用户。
小程序管理后台的「优先使用本地版本设置」和「小程序最低可用版本设置」不会影响同步更新与异步更新的选择。
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
const updateManager = wx.getUpdateManager()

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function () {
  wx.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success(res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate()
      }
    }
  })
})

updateManager.onUpdateFailed(function () {
  // 新版本下载失败
})

```

---

## 42. 开放能力 / 获取小程序码

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html)

开放能力 /获取小程序码
获取小程序码

通过后台接口可以获取小程序任意页面的小程序码，扫描该小程序码可以直接进入小程序对应的页面，所有生成的小程序码永久有效，可放心使用。 我们推荐生成并使用小程序码，它具有更好的辨识度，且拥有展示“公众号关注组件”等高级能力。 生成的小程序码如下所示：

可以使用开发者工具 1.02.1803130 及以后版本通过 工具栏-自定义编译条件-通过二维码编译 功能来调试所获得的小程序码

为满足不同需求和场景，这里提供了两个接口，开发者可挑选适合自己的接口。

接口 A: 适用于需要的码数量较少的业务场景
生成小程序码，可接受 path 参数较长，生成个数受限，数量限制见 注意事项，请谨慎使用。
接口 B：适用于需要的码数量极多的业务场景
生成小程序码，可接受页面参数较短，生成个数不受限。
获取小程序二维码（不推荐使用）

通过后台接口可以获取小程序任意页面的小程序二维码，生成的小程序二维码如下所示：

接口 C：适用于需要的码数量较少的业务场景
生成二维码，可接受 path 参数较长，生成个数受限，数量限制见 注意事项。
获取小程序码（一物一码）

微信一物一码 支持生成小程序码。微信通过“一物一码”接口发放的二维码相比较普通链接二维码更安全、支持更小的印刷面积，支持跳转到指定小程序页面，且无数量限制。

接口 D：适用于“一物一码”的业务场景
注意事项
接口只能生成已发布的小程序的二维码
接口 A 加上接口 C，总共生成的码数量限制为 100,000，请谨慎调用。
接口 B 调用分钟频率受限(5000次/分钟)，如需大量小程序码，建议预生成。
官方教程 · “小程序二维码”功能介绍与生成方式
通过生成小程序二维码，并将印有小程序码的物料铺设在线下场景，或通过线上分享等方式，引导用户扫码或长按识别二维码进入小程序，实现小程序引流；并可通过配置带参数的小程序码，监控各来源渠道的转化效果
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 43. 开放能力 / 消息 / 订阅消息

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message-overview.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message-overview.html)

开放能力 /消息 /订阅消息
小程序订阅消息
功能介绍

消息能力是小程序能力中的重要组成，我们为开发者提供了订阅消息能力，以便实现服务的闭环和更优的体验。

订阅消息推送位置：服务通知

订阅消息下发条件：开发者通过一定的方式触发用户主动订阅

订阅消息卡片跳转能力：点击查看详情可跳转至该小程序的页面

消息分类
新版一次性订阅消息Beta

新版一次性订阅消息是一种无需用户在弹窗中主动订阅即可向用户下发消息的能力，用户的订阅方式为：

当用户在小程序中进行微信支付后，开发者可将微信支付订单号作为 code 向用户下发服务通知
开发者可在小程序中将触发服务的 button 组件的 open-type 的值设置为 liveActivity，当用户点击 button 后可获得 code ，后续可使用此 code 向用户下发服务通知

此下发方式由平台定义模版，开发者根据自身业务选择模版进行接入。

详见订阅消息接入 Beta开发指南文档。

一次性订阅消息（用户通过弹窗订阅）

一次性订阅消息用于解决用户使用小程序后，后续服务环节的通知问题。

开发者在小程序中调用 requestSubscribeMessage 接口后，将向用户展示弹窗，用户可打开自己想要接受的消息开关。用户订阅后，开发者可不限时间地下发一条对应的服务消息；每条消息可单独订阅或退订。

详见小程序订阅消息开发指南文档。

长期订阅消息（用户通过弹窗订阅）

一次性订阅消息可满足小程序的大部分服务场景需求，但线下公共服务领域存在一次性订阅无法满足的场景，如航班延误，需根据航班实时动态来多次发送消息提醒。为便于服务，我们提供了长期性订阅消息，用户订阅一次后，开发者可长期下发多条消息。

目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放，后期将逐步支持到其他线下公共服务业务。

详见小程序订阅消息开发指南文档。

同时长期订阅消息支持语音提醒与添加提醒能力。

长期订阅限频消息

为满足介于长期订阅与一次性订阅之间的部分业务场景需求，长期订阅消息现细分为「不限频」与「限频」两种类型。其中，限频类型支持用户完成一次订阅后，开发者按照预设频次（如每日一次、每月一次等）向用户下发消息。

需特别说明的是，限频消息引入「必填字段」概念，该字段将作为频次校验的核心标识（code）。例如：用户持有三张当月到期的保单（保单 1、保单 2、保单 3），若对应的「保单到期提醒」消息模版频次限制为每月一次，则开发者在「保单编号」这一必填字段中分别填入保单 1、保单 2 的编号时，可分别触发一次消息下发（即每张保单每月可基于该模版触发一次消息下发）。

限频消息的开发方式与长期订阅消息保持一致，开发者可进入公共模版库，选择与自身小程序类目匹配的消息模版。当前限频消息暂向金融等指定行业开放，若开发者存在更多模版需求，可通过行业对接人员反馈，或前往微信开放社区提交需求反馈。

设备订阅消息

设备订阅消息是一种特殊类型的订阅消息，它属于长期订阅消息类型，且需要完成「设备接入」才能使用。

设备订阅消息用于在设备触发某些需要人工介入的事件时（例如设备发生故障、设备耗材不足等），向用户发送消息通知。

详见设备订阅消息文档。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 44. 性能与体验 / 弱网体验优化

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/performance/weak-network.html](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/weak-network.html)

性能与体验 /弱网体验优化
弱网体验优化

在用户使用小程序时，可能会陷入某些网络不通畅的场景，此时一些严格依赖网络的功能可能就无法使用。

框架优化

为了让小程序在弱网情况下使用可以更加顺畅，小程序框架做了以下优化来解决弱网使用小程序的体验：

启动小程序支持异步 launch

以前启动的流程是同步 launch，同步时在弱网的时候会出现页面卡在 loading 页的情况，小程序框架在弱网的时候默认使用异步 launch 来优化弱网启动小程序的体验：

同步 launch：拉取新的配置、如有新代码包会拉新代码包，再启动小程序；
异步 launch：使用默认本地缓存的配置、代码包来启动小程序；
支持弱网/离线一次性授权

对于 wx.getLocation 等需要用户 授权 的接口，因为授权关系会记录在后台，但是在弱网或者断网的时候请求是很难走通的，所以小程序框架在弱网/断网时支持一次性授权的方式来走通流程：

调用授权类接口时，不管先前有无授权，都直接弹授权框走本地授权；
在弱网/断网这一周期内使用该授权结果；
网络恢复后清除掉一次性授权结果，重新走回向后台发请求检查授权的逻辑；

除此之外，小程序提供了 缓存管理器 来帮助开发者解决小程序弱网的问题.

目前，以下依赖网络的功能可以通过接入缓存管理器改善：

纯展示类的功能
只依赖部分用户授权的功能
缓存管理器

小程序提供了一个无侵入式的缓存管理器，开发者可以不需要修改原有业务代码进行接入。缓存管理器主要有以下几个能力：

在网络通畅时，对符合规则的网络请求进行缓存；在弱网时对该网络请求使用缓存返回。
在网络通畅时，对部分 wx api 调用进行缓存；在弱网时对这些 wx api 的调用使用缓存返回。

简单来说，缓存管理器可以帮助开发者在不修改小程序主要逻辑的情况下，快速接入缓存能力。接入过程只需要额外编写如下几行代码：

// 创建缓存管理器
const cacheManager = wx.createCacheManager({
  origin: 'https://weixin.qq.com',
})

// 添加请求规则
cacheManager.addRules([
  '/cgi/home',
  '/cgi/detail/:id',
])

// 监听符合规则的 wx.request 请求，默认在弱网时调用 wx.request 即会触发
cacheManager.on('request', evt => {
  return new Promise((resolve, reject) => {
    // 匹配是否存在缓存
    const matchRes = cacheManager.match(evt)

    if (matchRes && matchRes.data) {
      // 使用缓存返回
      resolve(matchRes.data)
    } else {
      // 没有匹配到缓存
      reject({errMsg: `catch not found: ${evt.url}`})
    }
  })
})


上述示例中使用 wx.createCacheManager 即可创建缓存管理器。缓存管理器全局只有唯一实例，一旦被成功创建出来即表示接入成功。

开发者需要添加请求规则，用来匹配哪些请求需要被缓存，不在请求规则内的请求会被自动放过。一旦请求命中规则，则在网络通畅时会对结果进行缓存，在弱网时会拦截请求，然后触发 request 事件给开发者。开发者可以在事件回调中决定是否使用缓存返回，如果使用缓存返回，则不会再发起网络请求；如果仍要尝试发起网络请求，可像如下方式操作：

cacheManager.on('request', async evt => {
  try {
    // 仍然走网络请求
    const res = await evt.request()
    
    // ......
  } catch (err) {
    // ......
  }
})


为了适应更多的请求场景，请求规则支持多种写法，如：

cacheManager.addRule('/abc') // uri 串，会自动使用调用 wx.createCacheManager 时传入的 origin 进行拼接，然后匹配
cacheManager.addRule('GET /abc') // 在 uri 串基础上，补充请求方法的匹配
cacheManager.addRule('/abc/:id') // 带可变部分的 uri 串

cacheManager.addRule(/\/(abc|cba)$/ig) // 正则表达式

cacheManager.addRule({
  method: 'POST',
  url: '/abc',
  dataSchema: [
    {name: 'param1', schema: {value: /(aaa|bbb)/ig}},
    {name: 'param2', schema: {value: '123'}},
  ],
}) // 规则对象


更多规则写法可参考 addRule 文档

每个命中了规则的请求，会根据一定策略生成缓存 id，如果两个请求生成的缓存 id 相同，则后者会覆盖前者，因此在编写规则时需要注意这点。一般来说，请求 url 不同或请求方法不同，生成的缓存 id 一定不同；如果请求参数不同，则需要考虑命中的规则有没有考虑参数的情况，详细的缓存 id 生成策略可参考 addRule 文档。

缓存存储会使用独立的用户空间（不占用用户的 storage），不过有缓存数量和大小限制，所以也不要无节制地使用缓存。请善用规则，尽可能只让必要的请求缓存。

关于缓存管理器的详细使用方式可参考 api 文档。此处同时提供一个完整可运行的例子，参考例子的 README 进行操作即可体验。

云托管使用 cacheManager

通过 wx.cloud.callContainer 调用的接口也可以使用 wx.createCacheManager 进行弱网体验优化。缓存请求需要开发者调用 addRule 添加规则。 这里对于 addRule 参数中的 url 字段有个统一规范：https://wx.cloud.callContainer/env/servicename/path ，其中 env / servicename / path 对应 wx.cloud.callContainer 调用服务的标识字段。比如对于如下的云调用，可以按示例添加缓存规则：

const res = await wx.cloud.callContainer({
    config: {
      env: 'test-123'
    },
    path: '/api/count',
    header: {
      'X-WX-SERVICE': 'express-server',
      'c

... (content truncated)

```js
// 创建缓存管理器
const cacheManager = wx.createCacheManager({
  origin: 'https://weixin.qq.com',
})

// 添加请求规则
cacheManager.addRules([
  '/cgi/home',
  '/cgi/detail/:id',
])

// 监听符合规则的 wx.request 请求，默认在弱网时调用 wx.request 即会触发
cacheManager.on('request', evt => {
  return new Promise((resolve, reject) => {
    // 匹配是否存在缓存
    const matchRes = cacheManager.match(evt)

    if (matchRes && matchRes.data) {
      // 使用缓存返回
      resolve(matchRes.data)
    } else {
      // 没有匹配到缓存
      reject({errMsg: `catch not found: ${evt.url}`})
    }
  })
})

```

```js
cacheManager.on('request', async evt => {
  try {
    // 仍然走网络请求
    const res = await evt.request()
    
    // ......
  } catch (err) {
    // ......
  }
})

```

```js
cacheManager.addRule('/abc') // uri 串，会自动使用调用 wx.createCacheManager 时传入的 origin 进行拼接，然后匹配
cacheManager.addRule('GET /abc') // 在 uri 串基础上，补充请求方法的匹配
cacheManager.addRule('/abc/:id') // 带可变部分的 uri 串

cacheManager.addRule(/\/(abc|cba)$/ig) // 正则表达式

cacheManager.addRule({
  method: 'POST',
  url: '/abc',
  dataSchema: [
    {name: 'param1', schema: {value: /(aaa|bbb)/ig}},
    {name: 'param2', schema: {value: '123'}},
  ],
}) // 规则对象

```

---

## 45. 小程序框架 / 视图层 / 基础组件

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/view/component.html](https://developers.weixin.qq.com/miniprogram/dev/framework/view/component.html)

小程序框架 /视图层 /基础组件
基础组件

框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考组件文档。

什么是组件：

组件是视图层的基本组成单元。
组件自带一些功能与微信风格一致的样式。
一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。
<tagname property="value">
Content goes here ...
</tagname>


注意：所有组件与属性都是小写，以连字符-连接

属性类型
类型	描述	注解
Boolean	布尔值	组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。
如果属性值为变量，变量的值会被转换为Boolean类型
Number	数字	1, 2.5
String	字符串	"string"
Array	数组	[ 1, "string" ]
Object	对象	{ key: value }
EventHandler	事件处理函数名	"handlerName" 是 Page 中定义的事件处理函数名
Any	任意属性	
公共属性

所有组件都有以下属性：

属性名	类型	描述	注解
id	String	组件的唯一标示	保持整个页面唯一
class	String	组件的样式类	在对应的 WXSS 中定义的样式类
style	String	组件的内联样式	可以动态设置的内联样式
hidden	Boolean	组件是否显示	所有组件默认显示
data-*	Any	自定义属性	组件上触发的事件时，会发送给事件处理函数
bind* / catch*	EventHandler	组件的事件	详见事件
特殊属性

几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个组件的定义。

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<tagname property="value">
Content goes here ...
</tagname>

```

---

## 46. 连接硬件能力 / 音视频通话+摄像头（for 硬件） / 用户授权设备

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/device/voip/auth.html](https://developers.weixin.qq.com/miniprogram/dev/framework/device/voip/auth.html)

连接硬件能力 /音视频通话+摄像头（for 硬件） /用户授权设备
用户授权设备

设备如果要向用户发起通话，需要用户在手机微信端先对设备进行授权。

微信呼叫设备，若使用 callWMPF 或 callDevice 接口不需要授权。使用 initByCaller 接口仍需要授权。

1. 请求授权

用户授权前，需要从开发者的后台通过获取设备票据 接口拿到设备票据 snTicket。

拿到 snTicket 后，需要在小程序内调用 wx.requestDeviceVoIP 请用户进行授权。

需要基础库 >= 2.27.3 支持。设备组 >= 2.30.4 支持。

wx.requestDeviceVoIP({
  sn: 'xxxxxx', // 向用户发起通话的设备 sn（需要与设备注册时一致）
  snTicket: 'xxxxxx', // 获取的 snTicket
  modelId: 'xxxxxx', // 「设备接入」从微信公众平台获取的 model_id
  deviceName: 'xxx', // 设备名称，用于授权时显示给用户
  success(res) {
    console.log(`requestDeviceVoIP success:`, res)
  },
  fail(err) {
    console.error(`requestDeviceVoIP fail:`, err)
  },
})


注意：

如果用户拒绝授权或在设置页中取消授权，再次调用 requestDeviceVoIP 不会出现授权弹框。开发者应引导用户在设置页中手动开启。
授权框中「设备名字」= 「deviceName」 + 「modelId 对应设备型号」。如「devcieName」为「iot」，modelId 对应设备型号是「校园电话」，最终名字为「iot 校园电话」

2. 处理授权失效的情况

用户在授权成功后，下列操作可能导致授权失效：

清空授权：在最近使用中删除小程序，用户的授权记录会被清空。
取消授权：用户同意授权后，小程序设置页面中会出现「语音、视频通话提醒」模块，点击进入后用户可以管理已授权的设备，并可以取消授权。（需要微信客户端 >= 8.0.30 支持）

为了保证用户能够正常使用音视频通话能力，开发者需要处理授权失效的情况。 在发起通话前，建议开发者通过第 4 节所述方式检查授权状态。并在必要时提醒用户重新授权：

清空授权：可以直接调用 requestDeviceVoIP 请用户进行重新授权。
取消授权/用户拒绝授权：再次调用 requestDeviceVoIP 不会出现授权弹框。开发者应引导用户在设置页中手动开启授权开关。

开发者可以通过以下方式判断用户的授权状态：

通过发起通话失败的错误码。使用插件发起通话时，若用户未授权设备，会返回 errCode: 9。（若使用设备组，请确认设备组内存在此设备）
在用户使用小程序时，查询授权状态。参见第 4 节。
3. 批量授权

如果需要批量授权，可以创建设备组。在用户授权和设备进行音视频通话时，可以批量授权给一个设备组，而无需对每台设备重复授权。

例如，在校园电话场景下，同一所学校可能有很多台话机。可以将同一所学校的设备加入到一个设备组，并使用 wx.requestDeviceVoIP 对整个设备组进行授权。

注意：对于设备组，deviceName 显示为创建设备组时指定的名称，授权时暂不允许自定义。

需要基础库 >= 2.30.4 支持。

wx.requestDeviceVoIP({
  isGroup: true,
  groupId: '设备组 ID',
  success(res) {
    console.log(res)
  },
  fail(res) {
    console.log(res)
  },
})

4. 授权状态查询

开发者可以在用户使用小程序时，通过下列方式查询授权状态。根据小程序统一的授权体系设计，不提供后台接口查询授权状态，也不提供用户操作授权的事件回调。

4.1 当前用户授权的设备（组）

查询当前登录的用户同意/拒绝或取消授权了哪些设备（组）。

在手机微信端小程序内调用 wx.getDeviceVoIPList，可用于在手机端发起通话前检查授权状态。

需要基础库 >= 2.30.3 支持。设备组 >= 2.30.4 支持。

// 小程序基础库接口
wx.getDeviceVoIPList({
  success(res) {
    console.log('[getDeviceVoIPList]', res.list)
    // [{sn: 'xxx', model_id: 'xxx', status: 0}]
    // status: 0/未授权；1/已授权
  },
})

设备组只有 groupId 字段，sn 和 model_id 为 undefined。
4.2 当前设备是否被授权

根据用户 openId，查询指定用户是否授权设备（组）。

由插件提供 getIotBindContactList 接口，一般在设备端使用，可用于在设备端发起通话前（如联系人页面）检查授权状态。

const wmpfVoip = requirePlugin('wmpf-voip').default

wmpfVoip
  .getIotBindContactList({
    sn: '设备sn',
    model_id: '申请的modelid',
    openid_list: ['openid_1', 'openid_2'], // 传入需要验证的openid列表
  })
  .then(res => {
    console.log(`[getIotBindContactList]:`, res.contact_list)
    // [{sn: 'xxx', model_id: 'xxx', status: 0}]
    // status: 0/未授权；1/已授权
  })

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
wx.requestDeviceVoIP({
  sn: 'xxxxxx', // 向用户发起通话的设备 sn（需要与设备注册时一致）
  snTicket: 'xxxxxx', // 获取的 snTicket
  modelId: 'xxxxxx', // 「设备接入」从微信公众平台获取的 model_id
  deviceName: 'xxx', // 设备名称，用于授权时显示给用户
  success(res) {
    console.log(`requestDeviceVoIP success:`, res)
  },
  fail(err) {
    console.error(`requestDeviceVoIP fail:`, err)
  },
})

```

```js
wx.requestDeviceVoIP({
  isGroup: true,
  groupId: '设备组 ID',
  success(res) {
    console.log(res)
  },
  fail(res) {
    console.log(res)
  },
})

```

```js
// 小程序基础库接口
wx.getDeviceVoIPList({
  success(res) {
    console.log('[getDeviceVoIPList]', res.list)
    // [{sn: 'xxx', model_id: 'xxx', status: 0}]
    // status: 0/未授权；1/已授权
  },
})

```

---

## 47. glass-easel 组件框架 / 新增特性 / Chaining API

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/chaining-api.html](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/chaining-api.html)

glass-easel 组件框架 /新增特性 /Chaining API
Chaining API

由于目前 glass-easel 组件框架仅可用于 Skyline 渲染引擎，因此这些特性也同样受此限制。

Chaining API 接口形式

Chaining API 是一种新的页面和自定义组件定义形式。

对于一个传统的自定义组件定义：

Component({
  properties: {
    myProperty: String,
    myAnotherProperty: String,
  },
  data: {
    myDataField: 'someValue',
  },
})


它可以被等价地写成以下 Chaining API 形式：

Component()
  .property('myProperty', String)
  .property('myAnotherProperty', String)
  .data(() => ({
    myDataField: 'someValue',
  }))
  .register()


使用 Chaining API 的主要好处是它具有更好的 TypeScript 支持，且对于复杂组件更加友好，还可以配合 init 函数 来使用。但它也使得对简单组件的定义看起来稍显繁琐。

因而，每个组件都可以分别选用传统的定义方式或者 Chaining API 来进行定义，可以对于每个组件都选用更合适它的定义方式。

常用的链式调用项

以下是一些常用链式调用项。

.property 用来定义单个属性，等价于传统形式的 properties 定义段中的单个项目。例如：

Component()
  .property('myProperty', {
    type: String
  })
  .register()


.data 用来定义数据字段表，作用上相当于传统形式的 data 定义段，但它接受一个函数。这个函数在每次组件创建时执行一次，它的返回值被用作数据字段。例如：

Component()
  .data(() => ({
    myDataField: 'someValue',
  }))
  .register()


.externalClasses 用来定义外部样式类，等价于传统形式的 externalClasses 定义段。例如：

Component()
  .externalClasses(['my-class'])
  .register()


.options 用来指定组件选项，等价于传统形式的 options 定义段。（注意，如果多次调用，仅有最后一次调用有效。）例如：

Component()
  .options({
    multipleSlots: true,
  })
  .register()


.options 用来指定组件选项，等价于传统形式的 options 定义段。（注意，如果多次调用，仅有最后一次调用有效。）例如：

Component()
  .options({
    multipleSlots: true,
  })
  .register()


以下链式调用项也是可用的，但通过 init 函数 来调用通常更加友好。

.methods 用来定义一组方法，等价于传统形式的 methods 定义段。例如：

Component()
  .methods({
    myMethod() { /* ... */ }
  })
  .register()


.lifetime 和 .pageLifetime 分别用来定义单个生命周期方法和组件所在页面的生命周期方法，等价于传统形式的 lifetime 和 pageLifetime 定义段中的单个项目。例如：

Component()
  .lifetime('attached', function () { /* ... */ })
  .pageLifetime('show', function () { /* ... */ })
  .register()


.observer 用来定义单个数据监听器，类似于传统形式的 observers 定义段中的单个项目，但在同时监听多个数据字段时，应写成数组形式。例如：

Component()
  .data(() => ({
    a: 1,
    b: 2,
  }))
  .observer(['a', 'b'], function () { /* ... */ })
  .register()


.relation 用来定义单个组件间关系项，等价于传统形式的 relations 定义段中的单个项目。例如：

Component()
  .relation('another-component', {
    type: 'parent',
  })
  .register()

在链式调用项中使用 behavior

类似地， Behavior 也支持 Chaining API 。例如：

const beh = Behavior()
  .property('myProperty', String)
  .register()


这样，在组件中，可以使用 .behavior 将其引入：

Component()
  .behavior(beh)
  .register()


需要注意的是，引入 behavior 导致出现了重复的同名属性或同名数据字段时， TypeScript 将会报出类型错误。

重复使用链式调用项

除了 options 和 export ，其他链式调用项都可以重复调用多次，调用结果会组合起来。

这样可以把复杂的组件拆解成好几个部分来定义，对于很复杂的组件定义会有帮助。

Component()
  // 定义 myDataField 字段和相关的处理逻辑
  .data(() => ({
    myDataField: 'someValue',
  }))
  .lifetime('attached', function () {
    this.setData({ myDataField: updatedValue })
  })
  // 定义 anotherField 字段和相关的处理逻辑
  .data(() => ({
    anotherField: 1,
  }))
  .lifetime('attached', function () {
    this.setData({ anotherField: updatedValue })
  })
  .register()

非连续链式调用

链式调用项也可以分开写。例如：

const componentDefinition = Component()
componentDefinition.property('myProperty', String)
componentDefinition.data(() => ({


... (content truncated)

```js
Component({
  properties: {
    myProperty: String,
    myAnotherProperty: String,
  },
  data: {
    myDataField: 'someValue',
  },
})

```

```js
Component()
  .property('myProperty', String)
  .property('myAnotherProperty', String)
  .data(() => ({
    myDataField: 'someValue',
  }))
  .register()

```

```js
Component()
  .property('myProperty', {
    type: String
  })
  .register()

```

---

## 48. 性能与体验 / 运行时性能 / 概述

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html)

性能与体验 /运行时性能 /概述
运行时性能

小程序的运行时性能直接决定了用户在使用小程序功能时的体验。如果运行时性能出现问题，很容易出现页面滚动卡顿、响应延迟等问题，影响用户使用。如果内存占用过高，还会出现黑屏、闪退等问题。

在优化运行时性能前，建议开发者先了解下小程序的运行环境和运行机制。

开发者可以从以下方面着手进行启动性能的优化：

合理使用 setData
渲染性能优化
页面切换优化
资源加载优化
内存优化
关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

---

## 49. 小程序框架 / 视图层 / WXS

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/)

小程序框架 /视图层 /WXS
WXS

WXS（WeiXin Script）是内联在 WXML 中的脚本段。通过 WXS 可以在模版中内联少量处理脚本，丰富模板的数据预处理能力。另外， WXS 还可以用来编写简单的 WXS 事件响应函数。

从语法上看， WXS 类似于有少量限制的 JavaScript 。要完整了解 WXS 语法，请参考WXS 语法参考。

以下是一些使用 WXS 的简单示例。

页面渲染
<!--wxml-->
<wxs module="m1">
var msg = "hello world";

module.exports.message = msg;
</wxs>

<view> {{m1.message}} </view>


页面输出：

hello world

数据处理
// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  }
})

<!--wxml-->
<!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
<wxs module="m1">
var getMax = function(array) {
  var max = undefined;
  for (var i = 0; i < array.length; ++i) {
    max = max === undefined ?
      array[i] :
      (max >= array[i] ? max : array[i]);
  }
  return max;
}

module.exports.getMax = getMax;
</wxs>

<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
<view> {{m1.getMax(array)}} </view>


页面输出：

5

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```html
<!--wxml-->
<wxs module="m1">
var msg = "hello world";

module.exports.message = msg;
</wxs>

<view> {{m1.message}} </view>

```

```text
hello world

```

```js
// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  }
})

```

---

## 50. 开放能力 / 转发 / 小程序私密消息

**Source**: [https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share/private-message.html](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share/private-message.html)

开放能力 /转发 /小程序私密消息
小程序私密消息
功能介绍

小程序私密消息功能是这样一种能力：当分享者分享小程序卡片给其他用户或者微信群后，其他用户点击此小程序卡片时，开发者可以鉴别出点击卡片的用户是否被分享者分享过小程序卡片。

使用说明
1. 分享

创建业务活动后、分享小程序消息前，需要通过后台接口 createActivityId 创建activityId，建立一个activityId与一个业务活动id唯一关联。

然后通过 wx.updateShareMenu 接口声明本次分享的消息为私密消息，私密消息具有不可二次转发性。

声明完成后，可以通过右上角菜单、分享按钮组件、wx.shareAppMessage（仅小游戏）分享私密消息给个人、群聊。

场景一： 个人分享给个人

A --> B

场景二： 个人分享给群

A --> [B, C, D, E]

示例代码

wx.updateShareMenu({
  withShareTicket: true,
  isPrivateMessage: true,
  activityId: 'xxx',
})

2. 验证

从群聊、单聊消息卡片进入小程序时，通过 wx.authPrivateMessage 接口可以验证当前用户是否是私密消息的接收者，即验证这条消息是否是A直接转发给B或者A转发给B所在的群。

该接口使用前，需要通过 wx.login() 接口登录小程序。

接口参数
参数	类型	说明
shareTicket	string	shareTicket
success回调
参数	类型	说明
valid	Boolean	验证是否通过
iv	String	加密算法的初始向量，详细见加密数据解密算法
encryptedData	String	经过加密的activityId，解密后可得到原始的activityId。若解密后得到的activityId可以与开发者后台的活动id对应上则验证通过，否则表明valid字段不可靠（被篡改） 详细见加密数据解密算法
注意事项
若返回的valid字段为false，表示此次验证不通过。
若返回的valid字段为true，表示验证通过。但是为了安全起见，预防valid字段被篡改的可能，可以把encryptedData和iv传到开发者后台去解密。若解密后得到的activityId就是当前活动所对应的activityId 则验证通过，否则表示验证不通过。
当私密消息分享给群时，是按鉴别时刻用户是否在群里作为判断。
activityId创建后7天内分享有效，120天内验证有效。
示例代码
wx.authPrivateMessage({
  shareTicket: 'xxxxxx',
  success(res) {
    console.log('authPrivateMessage success', res)
    // res
    // {
    //   errMsg: 'authPrivateMessage:ok'
    //   valid: true
    //   iv: 'xxxx',
    //   encryptedData: 'xxxxxx'
    // }
  },
  fail(res) {
    console.log('authPrivateMessage fail', res)
  }
})

关于腾讯 文档中心 辟谣中心 客服中心

Copyright © 2012-2026 Tencent. All Rights Reserved.

```js
wx.updateShareMenu({
  withShareTicket: true,
  isPrivateMessage: true,
  activityId: 'xxx',
})

```

```js
wx.authPrivateMessage({
  shareTicket: 'xxxxxx',
  success(res) {
    console.log('authPrivateMessage success', res)
    // res
    // {
    //   errMsg: 'authPrivateMessage:ok'
    //   valid: true
    //   iv: 'xxxx',
    //   encryptedData: 'xxxxxx'
    // }
  },
  fail(res) {
    console.log('authPrivateMessage fail', res)
  }
})

```

---

