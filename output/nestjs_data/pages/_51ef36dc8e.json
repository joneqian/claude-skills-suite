{
  "url": "https://docs.nestjs.com/techniques/database",
  "title": "",
  "content": "Nest is database agnostic, allowing you to easily integrate with any SQL or NoSQL database. You have a number of options available to you, depending on your preferences. At the most general level, connecting Nest to a database is simply a matter of loading an appropriate Node.js driver for the database, just as you would with Express or Fastify.\n\nYou can also directly use any general purpose Node.js database integration library or ORM, such as MikroORM (see MikroORM recipe), Sequelize (see Sequelize integration), Knex.js (see Knex.js tutorial), TypeORM, and Prisma (see Prisma recipe), to operate at a higher level of abstraction.\n\nFor convenience, Nest provides tight integration with TypeORM and Sequelize out-of-the-box with the @nestjs/typeorm and @nestjs/sequelize packages respectively, which we'll cover in the current chapter, and Mongoose with @nestjs/mongoose, which is covered in this chapter. These integrations provide additional NestJS-specific features, such as model/repository injection, testability, and asynchronous configuration to make accessing your chosen database even easier.\n\nFor integrating with SQL and NoSQL databases, Nest provides the @nestjs/typeorm package. TypeORM is the most mature Object Relational Mapper (ORM) available for TypeScript. Since it's written in TypeScript, it integrates well with the Nest framework.\n\nTo begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular MySQL Relational DBMS, but TypeORM provides support for many relational databases, such as PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. The procedure we walk through in this chapter will be the same for any database supported by TypeORM. You'll simply need to install the associated client API libraries for your selected database.\n\nOnce the installation process is complete, we can import the TypeOrmModule into the root AppModule.\n\nThe forRoot() method supports all the configuration properties exposed by the DataSource constructor from the TypeORM package. In addition, there are several extra configuration properties described below.\n\nOnce this is done, the TypeORM DataSource and EntityManager objects will be available to inject across the entire project (without needing to import any modules), for example:\n\nTypeORM supports the repository design pattern, so each entity has its own repository. These repositories can be obtained from the database data source.\n\nTo continue the example, we need at least one entity. Let's define the User entity.\n\nThe User entity file sits in the users directory. This directory contains all files related to the UsersModule. You can decide where to keep your model files, however, we recommend creating them near their domain, in the corresponding module directory.\n\nTo begin using the User entity, we need to let TypeORM know about it by inserting it into the entities array in the module forRoot() method options (unless you use a static glob path):\n\nNext, let's look at the UsersModule:\n\nThis module uses the forFeature() method to define which repositories are registered in the current scope. With that in place, we can inject the UsersRepository into the UsersService using the @InjectRepository() decorator:\n\nIf you want to use the repository outside of the module which imports TypeOrmModule.forFeature, you'll need to re-export the providers generated by it. You can do this by exporting the whole module, like this:\n\nNow if we import UsersModule in UserHttpModule, we can use @InjectRepository(User) in the providers of the latter module.\n\nRelations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.\n\nThere are three types of relations:\n\nTo define relations in entities, use the corresponding decorators. For example, to define that each User can have multiple photos, use the @OneToMany() decorator.\n\nManually adding entities to the entities array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the autoLoadEntities property of the configuration object (passed into the forRoot() method) to true, as shown below:\n\nWith that option specified, every entity registered through the forFeature() method will be automatically added to the entities array of the configuration object.\n\nYou can define an entity and its columns right in the model, using decorators. But some people prefer to define entities and their columns inside separate files using the \"entity schemas\".\n\nNest allows you to use an EntitySchema instance wherever an Entity is expected, for example:\n\nA database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (learn more).\n\nThere are many different strategies to handle TypeORM transactions. We recommend using the QueryRunner class because it gives full control over the transaction.\n\nFirst, we need to inject the DataSource object into a class in the normal way:\n\nNow, we can use this object to create a transaction.\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nAlternatively, you can use the callback-style approach with the transaction method of the DataSource object (read more).\n\nWith TypeORM subscribers, you can listen to specific entity events.\n\nNow, add the UserSubscriber class to the providers array:\n\nMigrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated CLI.\n\nMigration classes are separate from the Nest application source code. Their lifecycle is maintained by the TypeORM CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the TypeORM documentation.\n\nSome projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, data source naming becomes mandatory.\n\nSuppose you have an Album entity stored in its own database.\n\nSee this issue for more details.\n\nAt this point, you have User and Album entities registered with their own data source. With this setup, you have to tell the TypeOrmModule.forFeature() method and the @InjectRepository() decorator which data source should be used. If you do not pass any data source name, the default data source is used.\n\nYou can also inject the DataSource or EntityManager for a given data source:\n\nIt's also possible to inject any DataSource to the providers:\n\nWhen it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on repositories that are pulled from the data source (connection) instance. How do we handle that? The solution is to create mock repositories. In order to achieve that, we set up custom providers. Each registered repository is automatically represented by an <EntityName>Repository token, where EntityName is the name of your entity class.\n\nThe @nestjs/typeorm package exposes the getRepositoryToken() function which returns a prepared token based on a given entity.\n\nNow a substitute mockRepository will be used as the UsersRepository. Whenever any class asks for UsersRepository using an @InjectRepository() decorator, Nest will use the registered mockRepository object.\n\nYou may want to pass your repository module options asynchronously instead of statically. In this case, use the forRootAsync() method, which provides several ways to deal with async configuration.\n\nOne approach is to use a factory function:\n\nOur factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject).\n\nAlternatively, you can use the useClass syntax:\n\nThe construction above will instantiate TypeOrmConfigService inside TypeOrmModule and use it to provide an options object by calling createTypeOrmOptions(). Note that this means that the TypeOrmConfigService has to implement the TypeOrmOptionsFactory interface, as shown below:\n\nIn order to prevent the creation of TypeOrmConfigService inside TypeOrmModule and use a provider imported from a different module, you can use the useExisting syntax.\n\nThis construction works the same as useClass with one critical difference - TypeOrmModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.\n\nIn conjunction with async configuration using useFactory, useClass, or useExisting, you can optionally specify a dataSourceFactory function which will allow you to provide your own TypeORM data source rather than allowing TypeOrmModule to create the data source.\n\ndataSourceFactory receives the TypeORM DataSourceOptions configured during async configuration using useFactory, useClass, or useExisting and returns a Promise that resolves a TypeORM DataSource.\n\nA working example is available here.\n\nOfficial enterprise support Providing technical guidance Performing in-depth code reviews Mentoring team members Advising best practices Explore more\n\nAn alternative to using TypeORM is to use the Sequelize ORM with the @nestjs/sequelize package. In addition, we leverage the sequelize-typescript package which provides a set of additional decorators to declaratively define entities.\n\nTo begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular MySQL Relational DBMS, but Sequelize provides support for many relational databases, such as PostgreSQL, MySQL, Microsoft SQL Server, SQLite, and MariaDB. The procedure we walk through in this chapter will be the same for any database supported by Sequelize. You'll simply need to install the associated client API libraries for your selected database.\n\nOnce the installation process is complete, we can import the SequelizeModule into the root AppModule.\n\nThe forRoot() method supports all the configuration properties exposed by the Sequelize constructor (read more). In addition, there are several extra configuration properties described below.\n\nOnce this is done, the Sequelize object will be available to inject across the entire project (without needing to import any modules), for example:\n\nSequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database. To continue the example, we need at least one model. Let's define the User model.\n\nThe User model file sits in the users directory. This directory contains all files related to the UsersModule. You can decide where to keep your model files, however, we recommend creating them near their domain, in the corresponding module directory.\n\nTo begin using the User model, we need to let Sequelize know about it by inserting it into the models array in the module forRoot() method options:\n\nNext, let's look at the UsersModule:\n\nThis module uses the forFeature() method to define which models are registered in the current scope. With that in place, we can inject the UserModel into the UsersService using the @InjectModel() decorator:\n\nIf you want to use the model outside of the module which imports SequelizeModule.forFeature, you'll need to re-export the providers generated by it. You can do this by exporting the whole module, like this:\n\nNow if we import UsersModule in UserHttpModule, we can use @InjectModel(User) in the providers of the latter module.\n\nRelations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.\n\nThere are three types of relations:\n\nTo define relations in models, use the corresponding decorators. For example, to define that each User can have multiple photos, use the @HasMany() decorator.\n\nManually adding models to the models array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both autoLoadModels and synchronize properties of the configuration object (passed into the forRoot() method) to true, as shown below:\n\nWith that option specified, every model registered through the forFeature() method will be automatically added to the models array of the configuration object.\n\nA database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (learn more).\n\nThere are many different strategies to handle Sequelize transactions. Below is a sample implementation of a managed transaction (auto-callback).\n\nFirst, we need to inject the Sequelize object into a class in the normal way:\n\nNow, we can use this object to create a transaction.\n\nMigrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, Sequelize provides a dedicated CLI.\n\nMigration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the Sequelize documentation.\n\nLearn the right way! 80+ chapters 5+ hours of videos Official certificate Deep-dive sessions Explore official courses\n\nSome projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes mandatory.\n\nSuppose you have an Album entity stored in its own database.\n\nAt this point, you have User and Album models registered with their own connection. With this setup, you have to tell the SequelizeModule.forFeature() method and the @InjectModel() decorator which connection should be used. If you do not pass any connection name, the default connection is used.\n\nYou can also inject the Sequelize instance for a given connection:\n\nIt's also possible to inject any Sequelize instance to the providers:\n\nWhen it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up custom providers. Each registered model is automatically represented by a <ModelName>Model token, where ModelName is the name of your model class.\n\nThe @nestjs/sequelize package exposes the getModelToken() function which returns a prepared token based on a given model.\n\nNow a substitute mockModel will be used as the UserModel. Whenever any class asks for UserModel using an @InjectModel() decorator, Nest will use the registered mockModel object.\n\nYou may want to pass your SequelizeModule options asynchronously instead of statically. In this case, use the forRootAsync() method, which provides several ways to deal with async configuration.\n\nOne approach is to use a factory function:\n\nOur factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject).\n\nAlternatively, you can use the useClass syntax:\n\nThe construction above will instantiate SequelizeConfigService inside SequelizeModule and use it to provide an options object by calling createSequelizeOptions(). Note that this means that the SequelizeConfigService has to implement the SequelizeOptionsFactory interface, as shown below:\n\nIn order to prevent the creation of SequelizeConfigService inside SequelizeModule and use a provider imported from a different module, you can use the useExisting syntax.\n\nThis construction works the same as useClass with one critical difference - SequelizeModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.\n\nA working example is available here.",
  "headings": [
    {
      "level": "h3",
      "text": "Database",
      "id": "database"
    },
    {
      "level": "h3",
      "text": "TypeORM Integration",
      "id": "typeorm-integration"
    },
    {
      "level": "h4",
      "text": "Repository pattern#",
      "id": "repository-pattern"
    },
    {
      "level": "h4",
      "text": "Relations#",
      "id": "relations"
    },
    {
      "level": "h4",
      "text": "Auto-load entities#",
      "id": "auto-load-entities"
    },
    {
      "level": "h4",
      "text": "Separating entity definition#",
      "id": "separating-entity-definition"
    },
    {
      "level": "h4",
      "text": "TypeORM Transactions#",
      "id": "typeorm-transactions"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Subscribers#",
      "id": "subscribers"
    },
    {
      "level": "h4",
      "text": "Migrations#",
      "id": "migrations"
    },
    {
      "level": "h4",
      "text": "Multiple databases#",
      "id": "multiple-databases"
    },
    {
      "level": "h4",
      "text": "Testing#",
      "id": "testing"
    },
    {
      "level": "h4",
      "text": "Async configuration#",
      "id": "async-configuration"
    },
    {
      "level": "h4",
      "text": "Custom DataSource Factory#",
      "id": "custom-datasource-factory"
    },
    {
      "level": "h4",
      "text": "Example#",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Official enterprise support",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Sequelize Integration",
      "id": "sequelize-integration"
    },
    {
      "level": "h4",
      "text": "Models#",
      "id": "models"
    },
    {
      "level": "h4",
      "text": "Relations#",
      "id": "relations-1"
    },
    {
      "level": "h4",
      "text": "Auto-load models#",
      "id": "auto-load-models"
    },
    {
      "level": "h4",
      "text": "Sequelize Transactions#",
      "id": "sequelize-transactions"
    },
    {
      "level": "h4",
      "text": "Migrations#",
      "id": "migrations-1"
    },
    {
      "level": "h2",
      "text": "Learn the right way!",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Multiple databases#",
      "id": "multiple-databases-1"
    },
    {
      "level": "h4",
      "text": "Testing#",
      "id": "testing-1"
    },
    {
      "level": "h4",
      "text": "Async configuration#",
      "id": "async-configuration-1"
    },
    {
      "level": "h4",
      "text": "Example#",
      "id": "example-1"
    }
  ],
  "code_samples": [
    {
      "code": "$ npm install --save @nestjs/typeorm typeorm mysql2",
      "language": "bash"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      entities: [],\n      synchronize: true,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { DataSource } from 'typeorm';\n\n@Module({\n  imports: [TypeOrmModule.forRoot(), UsersModule],\n})\nexport class AppModule {\n  constructor(private dataSource: DataSource) {}\n}",
      "language": "typescript"
    },
    {
      "code": "import { DataSource } from 'typeorm';\n\n@Dependencies(DataSource)\n@Module({\n  imports: [TypeOrmModule.forRoot(), UsersModule],\n})\nexport class AppModule {\n  constructor(dataSource) {\n    this.dataSource = dataSource;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity()\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  firstName: string;\n\n  @Column()\n  lastName: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { User } from './users/user.entity';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      entities: [User],\n      synchronize: true,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService],\n  controllers: [UsersController],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from './user.entity';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n  ) {}\n\n  findAll(): Promise<User[]> {\n    return this.usersRepository.find();\n  }\n\n  findOne(id: number): Promise<User | null> {\n    return this.usersRepository.findOneBy({ id });\n  }\n\n  async remove(id: number): Promise<void> {\n    await this.usersRepository.delete(id);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, Dependencies } from '@nestjs/common';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { User } from './user.entity';\n\n@Injectable()\n@Dependencies(getRepositoryToken(User))\nexport class UsersService {\n  constructor(usersRepository) {\n    this.usersRepository = usersRepository;\n  }\n\n  findAll() {\n    return this.usersRepository.find();\n  }\n\n  findOne(id) {\n    return this.usersRepository.findOneBy({ id });\n  }\n\n  async remove(id) {\n    await this.usersRepository.delete(id);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  exports: [TypeOrmModule]\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { UsersModule } from './users.module';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\n\n@Module({\n  imports: [UsersModule],\n  providers: [UsersService],\n  controllers: [UsersController]\n})\nexport class UserHttpModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';\nimport { Photo } from '../photos/photo.entity';\n\n@Entity()\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  firstName: string;\n\n  @Column()\n  lastName: string;\n\n  @Column({ default: true })\n  isActive: boolean;\n\n  @OneToMany(type => Photo, photo => photo.user)\n  photos: Photo[];\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      ...\n      autoLoadEntities: true,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { EntitySchema } from 'typeorm';\nimport { User } from './user.entity';\n\nexport const UserSchema = new EntitySchema<User>({\n  name: 'User',\n  target: User,\n  columns: {\n    id: {\n      type: Number,\n      primary: true,\n      generated: true,\n    },\n    firstName: {\n      type: String,\n    },\n    lastName: {\n      type: String,\n    },\n    isActive: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  relations: {\n    photos: {\n      type: 'one-to-many',\n      target: 'Photo', // the name of the PhotoSchema\n    },\n  },\n});",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserSchema } from './user.schema';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([UserSchema])],\n  providers: [UsersService],\n  controllers: [UsersController],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class UsersService {\n  constructor(private dataSource: DataSource) {}\n}",
      "language": "typescript"
    },
    {
      "code": "async createMany(users: User[]) {\n  const queryRunner = this.dataSource.createQueryRunner();\n\n  await queryRunner.connect();\n  await queryRunner.startTransaction();\n  try {\n    await queryRunner.manager.save(users[0]);\n    await queryRunner.manager.save(users[1]);\n\n    await queryRunner.commitTransaction();\n  } catch (err) {\n    // since we have errors lets rollback the changes we made\n    await queryRunner.rollbackTransaction();\n  } finally {\n    // you need to release a queryRunner which was manually instantiated\n    await queryRunner.release();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "async createMany(users: User[]) {\n  await this.dataSource.transaction(async manager => {\n    await manager.save(users[0]);\n    await manager.save(users[1]);\n  });\n}",
      "language": "typescript"
    },
    {
      "code": "import {\n  DataSource,\n  EntitySubscriberInterface,\n  EventSubscriber,\n  InsertEvent,\n} from 'typeorm';\nimport { User } from './user.entity';\n\n@EventSubscriber()\nexport class UserSubscriber implements EntitySubscriberInterface<User> {\n  constructor(dataSource: DataSource) {\n    dataSource.subscribers.push(this);\n  }\n\n  listenTo() {\n    return User;\n  }\n\n  beforeInsert(event: InsertEvent<User>) {\n    console.log(`BEFORE USER INSERTED: `, event.entity);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { User } from './user.entity';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\nimport { UserSubscriber } from './user.subscriber';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService, UserSubscriber],\n  controllers: [UsersController],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "const defaultOptions = {\n  type: 'postgres',\n  port: 5432,\n  username: 'user',\n  password: 'password',\n  database: 'db',\n  synchronize: true,\n};\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      ...defaultOptions,\n      host: 'user_db_host',\n      entities: [User],\n    }),\n    TypeOrmModule.forRoot({\n      ...defaultOptions,\n      name: 'albumsConnection',\n      host: 'album_db_host',\n      entities: [Album],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  name: 'albumsConnection',\n  useFactory: ...,\n  inject: ...,\n}),",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    TypeOrmModule.forFeature([User]),\n    TypeOrmModule.forFeature([Album], 'albumsConnection'),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class AlbumsService {\n  constructor(\n    @InjectDataSource('albumsConnection')\n    private dataSource: DataSource,\n    @InjectEntityManager('albumsConnection')\n    private entityManager: EntityManager,\n  ) {}\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  providers: [\n    {\n      provide: AlbumsService,\n      useFactory: (albumsConnection: DataSource) => {\n        return new AlbumsService(albumsConnection);\n      },\n      inject: [getDataSourceToken('albumsConnection')],\n    },\n  ],\n})\nexport class AlbumsModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  providers: [\n    UsersService,\n    {\n      provide: getRepositoryToken(User),\n      useValue: mockRepository,\n    },\n  ],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  useFactory: () => ({\n    type: 'mysql',\n    host: 'localhost',\n    port: 3306,\n    username: 'root',\n    password: 'root',\n    database: 'test',\n    entities: [],\n    synchronize: true,\n  }),\n});",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  imports: [ConfigModule],\n  useFactory: (configService: ConfigService) => ({\n    type: 'mysql',\n    host: configService.get('HOST'),\n    port: +configService.get('PORT'),\n    username: configService.get('USERNAME'),\n    password: configService.get('PASSWORD'),\n    database: configService.get('DATABASE'),\n    entities: [],\n    synchronize: true,\n  }),\n  inject: [ConfigService],\n});",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  useClass: TypeOrmConfigService,\n});",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class TypeOrmConfigService implements TypeOrmOptionsFactory {\n  createTypeOrmOptions(): TypeOrmModuleOptions {\n    return {\n      type: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      entities: [],\n      synchronize: true,\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  imports: [ConfigModule],\n  useExisting: ConfigService,\n});",
      "language": "typescript"
    },
    {
      "code": "TypeOrmModule.forRootAsync({\n  imports: [ConfigModule],\n  inject: [ConfigService],\n  // Use useFactory, useClass, or useExisting\n  // to configure the DataSourceOptions.\n  useFactory: (configService: ConfigService) => ({\n    type: 'mysql',\n    host: configService.get('HOST'),\n    port: +configService.get('PORT'),\n    username: configService.get('USERNAME'),\n    password: configService.get('PASSWORD'),\n    database: configService.get('DATABASE'),\n    entities: [],\n    synchronize: true,\n  }),\n  // dataSource receives the configured DataSourceOptions\n  // and returns a Promise<DataSource>.\n  dataSourceFactory: async (options) => {\n    const dataSource = await new DataSource(options).initialize();\n    return dataSource;\n  },\n});",
      "language": "typescript"
    },
    {
      "code": "$ npm install --save @nestjs/sequelize sequelize sequelize-typescript mysql2\n$ npm install --save-dev @types/sequelize",
      "language": "bash"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { SequelizeModule } from '@nestjs/sequelize';\n\n@Module({\n  imports: [\n    SequelizeModule.forRoot({\n      dialect: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      models: [],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { Sequelize } from 'sequelize-typescript';\n\n@Injectable()\nexport class AppService {\n  constructor(private sequelize: Sequelize) {}\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { Sequelize } from 'sequelize-typescript';\n\n@Dependencies(Sequelize)\n@Injectable()\nexport class AppService {\n  constructor(sequelize) {\n    this.sequelize = sequelize;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Column, Model, Table } from 'sequelize-typescript';\n\n@Table\nexport class User extends Model {\n  @Column\n  firstName: string;\n\n  @Column\n  lastName: string;\n\n  @Column({ defaultValue: true })\n  isActive: boolean;\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { SequelizeModule } from '@nestjs/sequelize';\nimport { User } from './users/user.model';\n\n@Module({\n  imports: [\n    SequelizeModule.forRoot({\n      dialect: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      models: [User],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { SequelizeModule } from '@nestjs/sequelize';\nimport { User } from './user.model';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\n\n@Module({\n  imports: [SequelizeModule.forFeature([User])],\n  providers: [UsersService],\n  controllers: [UsersController],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/sequelize';\nimport { User } from './user.model';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectModel(User)\n    private userModel: typeof User,\n  ) {}\n\n  async findAll(): Promise<User[]> {\n    return this.userModel.findAll();\n  }\n\n  findOne(id: string): Promise<User> {\n    return this.userModel.findOne({\n      where: {\n        id,\n      },\n    });\n  }\n\n  async remove(id: string): Promise<void> {\n    const user = await this.findOne(id);\n    await user.destroy();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, Dependencies } from '@nestjs/common';\nimport { getModelToken } from '@nestjs/sequelize';\nimport { User } from './user.model';\n\n@Injectable()\n@Dependencies(getModelToken(User))\nexport class UsersService {\n  constructor(usersRepository) {\n    this.usersRepository = usersRepository;\n  }\n\n  async findAll() {\n    return this.userModel.findAll();\n  }\n\n  findOne(id) {\n    return this.userModel.findOne({\n      where: {\n        id,\n      },\n    });\n  }\n\n  async remove(id) {\n    const user = await this.findOne(id);\n    await user.destroy();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { SequelizeModule } from '@nestjs/sequelize';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [SequelizeModule.forFeature([User])],\n  exports: [SequelizeModule]\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { UsersModule } from './users.module';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\n\n@Module({\n  imports: [UsersModule],\n  providers: [UsersService],\n  controllers: [UsersController]\n})\nexport class UserHttpModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Column, Model, Table, HasMany } from 'sequelize-typescript';\nimport { Photo } from '../photos/photo.model';\n\n@Table\nexport class User extends Model {\n  @Column\n  firstName: string;\n\n  @Column\n  lastName: string;\n\n  @Column({ defaultValue: true })\n  isActive: boolean;\n\n  @HasMany(() => Photo)\n  photos: Photo[];\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { SequelizeModule } from '@nestjs/sequelize';\n\n@Module({\n  imports: [\n    SequelizeModule.forRoot({\n      ...\n      autoLoadModels: true,\n      synchronize: true,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class UsersService {\n  constructor(private sequelize: Sequelize) {}\n}",
      "language": "typescript"
    },
    {
      "code": "async createMany() {\n  try {\n    await this.sequelize.transaction(async t => {\n      const transactionHost = { transaction: t };\n\n      await this.userModel.create(\n          { firstName: 'Abraham', lastName: 'Lincoln' },\n          transactionHost,\n      );\n      await this.userModel.create(\n          { firstName: 'John', lastName: 'Boothe' },\n          transactionHost,\n      );\n    });\n  } catch (err) {\n    // Transaction has been rolled back\n    // err is whatever rejected the promise chain returned to the transaction callback\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const defaultOptions = {\n  dialect: 'postgres',\n  port: 5432,\n  username: 'user',\n  password: 'password',\n  database: 'db',\n  synchronize: true,\n};\n\n@Module({\n  imports: [\n    SequelizeModule.forRoot({\n      ...defaultOptions,\n      host: 'user_db_host',\n      models: [User],\n    }),\n    SequelizeModule.forRoot({\n      ...defaultOptions,\n      name: 'albumsConnection',\n      host: 'album_db_host',\n      models: [Album],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    SequelizeModule.forFeature([User]),\n    SequelizeModule.forFeature([Album], 'albumsConnection'),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class AlbumsService {\n  constructor(\n    @InjectConnection('albumsConnection')\n    private sequelize: Sequelize,\n  ) {}\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  providers: [\n    {\n      provide: AlbumsService,\n      useFactory: (albumsSequelize: Sequelize) => {\n        return new AlbumsService(albumsSequelize);\n      },\n      inject: [getDataSourceToken('albumsConnection')],\n    },\n  ],\n})\nexport class AlbumsModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  providers: [\n    UsersService,\n    {\n      provide: getModelToken(User),\n      useValue: mockModel,\n    },\n  ],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "SequelizeModule.forRootAsync({\n  useFactory: () => ({\n    dialect: 'mysql',\n    host: 'localhost',\n    port: 3306,\n    username: 'root',\n    password: 'root',\n    database: 'test',\n    models: [],\n  }),\n});",
      "language": "typescript"
    },
    {
      "code": "SequelizeModule.forRootAsync({\n  imports: [ConfigModule],\n  useFactory: (configService: ConfigService) => ({\n    dialect: 'mysql',\n    host: configService.get('HOST'),\n    port: +configService.get('PORT'),\n    username: configService.get('USERNAME'),\n    password: configService.get('PASSWORD'),\n    database: configService.get('DATABASE'),\n    models: [],\n  }),\n  inject: [ConfigService],\n});",
      "language": "typescript"
    },
    {
      "code": "SequelizeModule.forRootAsync({\n  useClass: SequelizeConfigService,\n});",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nclass SequelizeConfigService implements SequelizeOptionsFactory {\n  createSequelizeOptions(): SequelizeModuleOptions {\n    return {\n      dialect: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      models: [],\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "SequelizeModule.forRootAsync({\n  imports: [ConfigModule],\n  useExisting: ConfigService,\n});",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Once this is done, the TypeORM DataSource and EntityManager objects will be available to inject across the entire project (without needing to import any modules), for example:",
      "code": "DataSource"
    },
    {
      "description": "Nest allows you to use an EntitySchema instance wherever an Entity is expected, for example:",
      "code": "EntitySchema"
    },
    {
      "description": "Once this is done, the Sequelize object will be available to inject across the entire project (without needing to import any modules), for example:",
      "code": "Sequelize"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}