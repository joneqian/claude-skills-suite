{
  "url": "https://docs.nestjs.com/interceptors",
  "title": "",
  "content": "An interceptor is a class annotated with the @Injectable() decorator and implements the NestInterceptor interface.\n\nInterceptors have a set of useful capabilities which are inspired by the Aspect Oriented Programming (AOP) technique. They make it possible to:\n\nEach interceptor implements the intercept() method, which takes two arguments. The first one is the ExecutionContext instance (exactly the same object as for guards). The ExecutionContext inherits from ArgumentsHost. We saw ArgumentsHost before in the exception filters chapter. There, we saw that it's a wrapper around arguments that have been passed to the original handler, and contains different arguments arrays based on the type of the application. You can refer back to the exception filters for more on this topic.\n\nBy extending ArgumentsHost, ExecutionContext also adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic interceptors that can work across a broad set of controllers, methods, and execution contexts. Learn more about ExecutionContexthere.\n\nThe second argument is a CallHandler. The CallHandler interface implements the handle() method, which you can use to invoke the route handler method at some point in your interceptor. If you don't call the handle() method in your implementation of the intercept() method, the route handler method won't be executed at all.\n\nThis approach means that the intercept() method effectively wraps the request/response stream. As a result, you may implement custom logic both before and after the execution of the final route handler. It's clear that you can write code in your intercept() method that executes before calling handle(), but how do you affect what happens afterward? Because the handle() method returns an Observable, we can use powerful RxJS operators to further manipulate the response. Using Aspect Oriented Programming terminology, the invocation of the route handler (i.e., calling handle()) is called a Pointcut, indicating that it's the point at which our additional logic is inserted.\n\nConsider, for example, an incoming POST /cats request. This request is destined for the create() handler defined inside the CatsController. If an interceptor which does not call the handle() method is called anywhere along the way, the create() method won't be executed. Once handle() is called (and its Observable has been returned), the create() handler will be triggered. And once the response stream is received via the Observable, additional operations can be performed on the stream, and a final result returned to the caller.\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nThe first use case we'll look at is to use an interceptor to log user interaction (e.g., storing user calls, asynchronously dispatching events or calculating a timestamp). We show a simple LoggingInterceptor below:\n\nSince handle() returns an RxJS Observable, we have a wide choice of operators we can use to manipulate the stream. In the example above, we used the tap() operator, which invokes our anonymous logging function upon graceful or exceptional termination of the observable stream, but doesn't otherwise interfere with the response cycle.\n\nIn order to set up the interceptor, we use the @UseInterceptors() decorator imported from the @nestjs/common package. Like pipes and guards, interceptors can be controller-scoped, method-scoped, or global-scoped.\n\nUsing the above construction, each route handler defined in CatsController will use LoggingInterceptor. When someone calls the GET /cats endpoint, you'll see the following output in your standard output:\n\nNote that we passed the LoggingInterceptor class (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes, guards, and exception filters, we can also pass an in-place instance:\n\nAs mentioned, the construction above attaches the interceptor to every handler declared by this controller. If we want to restrict the interceptor's scope to a single method, we simply apply the decorator at the method level.\n\nIn order to set up a global interceptor, we use the useGlobalInterceptors() method of the Nest application instance:\n\nGlobal interceptors are used across the whole application, for every controller and every route handler. In terms of dependency injection, global interceptors registered from outside of any module (with useGlobalInterceptors(), as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can set up an interceptor directly from any module using the following construction:\n\nWe already know that handle() returns an Observable. The stream contains the value returned from the route handler, and thus we can easily mutate it using RxJS's map() operator.\n\nLet's create the TransformInterceptor, which will modify each response in a trivial way to demonstrate the process. It will use RxJS's map() operator to assign the response object to the data property of a newly created object, returning the new object to the client.\n\nWith the above construction, when someone calls the GET /cats endpoint, the response would look like the following (assuming that route handler returns an empty array []):\n\nInterceptors have great value in creating re-usable solutions to requirements that occur across an entire application. For example, imagine we need to transform each occurrence of a null value to an empty string ''. We can do it using one line of code and bind the interceptor globally so that it will automatically be used by each registered handler.\n\nAnother interesting use-case is to take advantage of RxJS's catchError() operator to override thrown exceptions:\n\nThere are several reasons why we may sometimes want to completely prevent calling the handler and return a different value instead. An obvious example is to implement a cache to improve response time. Let's take a look at a simple cache interceptor that returns its response from a cache. In a realistic example, we'd want to consider other factors like TTL, cache invalidation, cache size, etc., but that's beyond the scope of this discussion. Here we'll provide a basic example that demonstrates the main concept.\n\nOur CacheInterceptor has a hardcoded isCached variable and a hardcoded response [] as well. The key point to note is that we return a new stream here, created by the RxJS of() operator, therefore the route handler won't be called at all. When someone calls an endpoint that makes use of CacheInterceptor, the response (a hardcoded, empty array) will be returned immediately. In order to create a generic solution, you can take advantage of Reflector and create a custom decorator. The Reflector is well described in the guards chapter.\n\nThe possibility of manipulating the stream using RxJS operators gives us many capabilities. Let's consider another common use case. Imagine you would like to handle timeouts on route requests. When your endpoint doesn't return anything after a period of time, you want to terminate with an error response. The following construction enables this:\n\nAfter 5 seconds, request processing will be canceled. You can also add custom logic before throwing RequestTimeoutException (e.g. release resources).",
  "headings": [
    {
      "level": "h3",
      "text": "Interceptors",
      "id": "interceptors"
    },
    {
      "level": "h4",
      "text": "Basics#",
      "id": "basics"
    },
    {
      "level": "h4",
      "text": "Execution context#",
      "id": "execution-context"
    },
    {
      "level": "h4",
      "text": "Call handler#",
      "id": "call-handler"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Aspect interception#",
      "id": "aspect-interception"
    },
    {
      "level": "h4",
      "text": "Binding interceptors#",
      "id": "binding-interceptors"
    },
    {
      "level": "h4",
      "text": "Response mapping#",
      "id": "response-mapping"
    },
    {
      "level": "h4",
      "text": "Exception mapping#",
      "id": "exception-mapping"
    },
    {
      "level": "h4",
      "text": "Stream overriding#",
      "id": "stream-overriding"
    },
    {
      "level": "h4",
      "text": "More operators#",
      "id": "more-operators"
    }
  ],
  "code_samples": [
    {
      "code": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LoggingInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    console.log('Before...');\n\n    const now = Date.now();\n    return next\n      .handle()\n      .pipe(\n        tap(() => console.log(`After... ${Date.now() - now}ms`)),\n      );\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LoggingInterceptor {\n  intercept(context, next) {\n    console.log('Before...');\n\n    const now = Date.now();\n    return next\n      .handle()\n      .pipe(\n        tap(() => console.log(`After... ${Date.now() - now}ms`)),\n      );\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@UseInterceptors(LoggingInterceptor)\nexport class CatsController {}",
      "language": "typescript"
    },
    {
      "code": "Before...\nAfter... 1ms",
      "language": "typescript"
    },
    {
      "code": "@UseInterceptors(new LoggingInterceptor())\nexport class CatsController {}",
      "language": "typescript"
    },
    {
      "code": "const app = await NestFactory.create(AppModule);\napp.useGlobalInterceptors(new LoggingInterceptor());",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { APP_INTERCEPTOR } from '@nestjs/core';\n\n@Module({\n  providers: [\n    {\n      provide: APP_INTERCEPTOR,\n      useClass: LoggingInterceptor,\n    },\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface Response<T> {\n  data: T;\n}\n\n@Injectable()\nexport class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {\n    return next.handle().pipe(map(data => ({ data })));\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { map } from 'rxjs/operators';\n\n@Injectable()\nexport class TransformInterceptor {\n  intercept(context, next) {\n    return next.handle().pipe(map(data => ({ data })));\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "{\n  \"data\": []\n}",
      "language": "json"
    },
    {
      "code": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@Injectable()\nexport class ExcludeNullInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next\n      .handle()\n      .pipe(map(value => value === null ? '' : value ));\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { map } from 'rxjs/operators';\n\n@Injectable()\nexport class ExcludeNullInterceptor {\n  intercept(context, next) {\n    return next\n      .handle()\n      .pipe(map(value => value === null ? '' : value ));\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import {\n  Injectable,\n  NestInterceptor,\n  ExecutionContext,\n  BadGatewayException,\n  CallHandler,\n} from '@nestjs/common';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\n@Injectable()\nexport class ErrorsInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next\n      .handle()\n      .pipe(\n        catchError(err => throwError(() => new BadGatewayException())),\n      );\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, BadGatewayException } from '@nestjs/common';\nimport { throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\n@Injectable()\nexport class ErrorsInterceptor {\n  intercept(context, next) {\n    return next\n      .handle()\n      .pipe(\n        catchError(err => throwError(() => new BadGatewayException())),\n      );\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable, of } from 'rxjs';\n\n@Injectable()\nexport class CacheInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const isCached = true;\n    if (isCached) {\n      return of([]);\n    }\n    return next.handle();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { of } from 'rxjs';\n\n@Injectable()\nexport class CacheInterceptor {\n  intercept(context, next) {\n    const isCached = true;\n    if (isCached) {\n      return of([]);\n    }\n    return next.handle();\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from '@nestjs/common';\nimport { Observable, throwError, TimeoutError } from 'rxjs';\nimport { catchError, timeout } from 'rxjs/operators';\n\n@Injectable()\nexport class TimeoutInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      timeout(5000),\n      catchError(err => {\n        if (err instanceof TimeoutError) {\n          return throwError(() => new RequestTimeoutException());\n        }\n        return throwError(() => err);\n      }),\n    );\n  };\n};",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, RequestTimeoutException } from '@nestjs/common';\nimport { Observable, throwError, TimeoutError } from 'rxjs';\nimport { catchError, timeout } from 'rxjs/operators';\n\n@Injectable()\nexport class TimeoutInterceptor {\n  intercept(context, next) {\n    return next.handle().pipe(\n      timeout(5000),\n      catchError(err => {\n        if (err instanceof TimeoutError) {\n          return throwError(() => new RequestTimeoutException());\n        }\n        return throwError(() => err);\n      }),\n    );\n  };\n};",
      "language": "typescript"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}