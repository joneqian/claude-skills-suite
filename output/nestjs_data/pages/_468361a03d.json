{
  "url": "https://docs.nestjs.com/microservices/custom-transport",
  "title": "",
  "content": "Nest provides a variety of transporters out-of-the-box, as well as an API allowing developers to build new custom transport strategies. Transporters enable you to connect components over a network using a pluggable communications layer and a very simple application-level message protocol (read full article).\n\nWith a custom transporter, you can integrate any messaging system/protocol (including Google Cloud Pub/Sub, Amazon Kinesis, and others) or extend the existing one, adding extra features on top (for example, QoS for MQTT).\n\nFirst, let's define a class representing our custom transporter.\n\nIn our example above, we declared the GoogleCloudPubSubServer class and provided listen() and close() methods enforced by the CustomTransportStrategy interface. Also, our class extends the Server class imported from the @nestjs/microservices package that provides a few useful methods, for example, methods used by Nest runtime to register message handlers. Alternatively, in case you want to extend the capabilities of an existing transport strategy, you could extend the corresponding server class, for example, ServerRedis. Conventionally, we added the \"Server\" suffix to our class as it will be responsible for subscribing to messages/events (and responding to them, if necessary).\n\nWith this in place, we can now use our custom strategy instead of using a built-in transporter, as follows:\n\nBasically, instead of passing the normal transporter options object with transport and options properties, we pass a single property, strategy, whose value is an instance of our custom transporter class.\n\nBack to our GoogleCloudPubSubServer class, in a real-world application, we would be establishing a connection to our message broker/external service and registering subscribers/listening to specific channels in listen() method (and then removing subscriptions & closing the connection in the close() teardown method), but since this requires a good understanding of how Nest microservices communicate with each other, we recommend reading this article series. In this chapter instead, we'll focus on the capabilities the Server class provides and how you can leverage them to build custom strategies.\n\nFor example, let's say that somewhere in our application, the following message handler is defined:\n\nThis message handler will be automatically registered by Nest runtime. With Server class, you can see what message patterns have been registered and also, access and execute the actual methods that were assigned to them. To test this out, let's add a simple console.log inside listen() method before callback function is called:\n\nAfter your application restarts, you'll see the following log in your terminal:\n\nAs you can see, the messageHandlers property is a Map collection of all message (and event) handlers, in which patterns are being used as keys. Now, you can use a key (for example, \"echo\") to receive a reference to the message handler:\n\nOnce we execute the echoHandler passing an arbitrary string as an argument (\"Hello world!\" here), we should see it in the console:\n\nWhich means that our method handler was properly executed.\n\nWhen using a CustomTransportStrategy with Interceptors the handlers are wrapped into RxJS streams. This means that you need to subscribe to them in order to execute the streams underlying logic (e.g. continue into the controller logic after an interceptor has been executed).\n\nAn example of this can be seen below:\n\nAs we mentioned in the first section, you don't necessarily need to use the @nestjs/microservices package to create microservices, but if you decide to do so and you need to integrate a custom strategy, you will need to provide a \"client\" class too.\n\nTo communicate with an external service/emit & publish messages (or events) you can either use a library-specific SDK package, or implement a custom client class that extends the ClientProxy, as follows:\n\nAs you can see, ClientProxy class requires us to provide several methods for establishing & closing the connection and publishing messages (publish) and events (dispatchEvent). Note, if you don't need a request-response communication style support, you can leave the publish() method empty. Likewise, if you don't need to support event-based communication, skip the dispatchEvent() method.\n\nTo observe what and when those methods are executed, let's add multiple console.log calls, as follows:\n\nWith this in place, let's create an instance of GoogleCloudPubSubClient class and run the send() method (which you might have seen in earlier chapters), subscribing to the returned observable stream.\n\nNow, you should see the following output in your terminal:\n\nTo test if our \"teardown\" method (which our publish() method returns) is properly executed, let's apply a timeout operator to our stream, setting it to 2 seconds to make sure it throws earlier then our setTimeout calls the callback function.\n\nWith timeout operator applied, your terminal output should look as follows:\n\nTo dispatch an event (instead of sending a message), use the emit() method:\n\nAnd that's what you should see in the console:\n\nIf you need to add some custom logic around the serialization of responses on the client side, you can use a custom class that extends the ClientProxy class or one of its child classes. For modifying successful requests you can override the serializeResponse method, and for modifying any errors that go through this client you can override the serializeError method. To make use of this custom class, you can pass the class itself to the ClientsModule.register() method using the customClass property. Below is an example of a custom ClientProxy that serializes each error into an RpcException.\n\nand then use it in the ClientsModule like so:",
  "headings": [
    {
      "level": "h3",
      "text": "Custom transporters",
      "id": "custom-transporters"
    },
    {
      "level": "h4",
      "text": "Creating a strategy#",
      "id": "creating-a-strategy"
    },
    {
      "level": "h4",
      "text": "Client proxy#",
      "id": "client-proxy"
    },
    {
      "level": "h4",
      "text": "Message serialization#",
      "id": "message-serialization"
    }
  ],
  "code_samples": [
    {
      "code": "import { CustomTransportStrategy, Server } from '@nestjs/microservices';\n\nclass GoogleCloudPubSubServer\n  extends Server\n  implements CustomTransportStrategy\n{\n  /**\n   * Triggered when you run \"app.listen()\".\n   */\n  listen(callback: () => void) {\n    callback();\n  }\n\n  /**\n   * Triggered on application shutdown.\n   */\n  close() {}\n\n  /**\n   * You can ignore this method if you don't want transporter users\n   * to be able to register event listeners. Most custom implementations\n   * will not need this.\n   */\n  on(event: string, callback: Function) {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * You can ignore this method if you don't want transporter users\n   * to be able to retrieve the underlying native server. Most custom implementations\n   * will not need this.\n   */\n  unwrap<T = never>(): T {\n    throw new Error('Method not implemented.');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n  AppModule,\n  {\n    strategy: new GoogleCloudPubSubServer(),\n  },\n);",
      "language": "typescript"
    },
    {
      "code": "@MessagePattern('echo')\necho(@Payload() data: object) {\n  return data;\n}",
      "language": "typescript"
    },
    {
      "code": "listen(callback: () => void) {\n  console.log(this.messageHandlers);\n  callback();\n}",
      "language": "typescript"
    },
    {
      "code": "Map { 'echo' => [AsyncFunction] { isEventHandler: false } }",
      "language": "typescript"
    },
    {
      "code": "async listen(callback: () => void) {\n  const echoHandler = this.messageHandlers.get('echo');\n  console.log(await echoHandler('Hello world!'));\n  callback();\n}",
      "language": "typescript"
    },
    {
      "code": "Hello world!",
      "language": "json"
    },
    {
      "code": "async listen(callback: () => void) {\n  const echoHandler = this.messageHandlers.get('echo');\n  const streamOrResult = await echoHandler('Hello World');\n  if (isObservable(streamOrResult)) {\n    streamOrResult.subscribe();\n  }\n  callback();\n}",
      "language": "typescript"
    },
    {
      "code": "import { ClientProxy, ReadPacket, WritePacket } from '@nestjs/microservices';\n\nclass GoogleCloudPubSubClient extends ClientProxy {\n  async connect(): Promise<any> {}\n  async close() {}\n  async dispatchEvent(packet: ReadPacket<any>): Promise<any> {}\n  publish(\n    packet: ReadPacket<any>,\n    callback: (packet: WritePacket<any>) => void,\n  ): Function {}\n  unwrap<T = never>(): T {\n    throw new Error('Method not implemented.');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "class GoogleCloudPubSubClient extends ClientProxy {\n  async connect(): Promise<any> {\n    console.log('connect');\n  }\n\n  async close() {\n    console.log('close');\n  }\n\n  async dispatchEvent(packet: ReadPacket<any>): Promise<any> {\n    return console.log('event to dispatch: ', packet);\n  }\n\n  publish(\n    packet: ReadPacket<any>,\n    callback: (packet: WritePacket<any>) => void,\n  ): Function {\n    console.log('message:', packet);\n\n    // In a real-world application, the \"callback\" function should be executed\n    // with payload sent back from the responder. Here, we'll simply simulate (5 seconds delay)\n    // that response came through by passing the same \"data\" as we've originally passed in.\n    //\n    // The \"isDisposed\" bool on the WritePacket tells the response that no further data is\n    // expected. If not sent or is false, this will simply emit data to the Observable.\n    setTimeout(() => callback({ \n      response: packet.data,\n      isDisposed: true,\n    }), 5000);\n\n    return () => console.log('teardown');\n  }\n\n  unwrap<T = never>(): T {\n    throw new Error('Method not implemented.');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const googlePubSubClient = new GoogleCloudPubSubClient();\ngooglePubSubClient\n  .send('pattern', 'Hello world!')\n  .subscribe((response) => console.log(response));",
      "language": "typescript"
    },
    {
      "code": "connect\nmessage: { pattern: 'pattern', data: 'Hello world!' }\nHello world! // <-- after 5 seconds",
      "language": "typescript"
    },
    {
      "code": "const googlePubSubClient = new GoogleCloudPubSubClient();\ngooglePubSubClient\n  .send('pattern', 'Hello world!')\n  .pipe(timeout(2000))\n  .subscribe(\n    (response) => console.log(response),\n    (error) => console.error(error.message),\n  );",
      "language": "typescript"
    },
    {
      "code": "connect\nmessage: { pattern: 'pattern', data: 'Hello world!' }\nteardown // <-- teardown\nTimeout has occurred",
      "language": "typescript"
    },
    {
      "code": "googlePubSubClient.emit('event', 'Hello world!');",
      "language": "typescript"
    },
    {
      "code": "connect\nevent to dispatch:  { pattern: 'event', data: 'Hello world!' }",
      "language": "typescript"
    },
    {
      "code": "import { ClientTcp, RpcException } from '@nestjs/microservices';\n\nclass ErrorHandlingProxy extends ClientTCP {\n  serializeError(err: Error) {\n    return new RpcException(err);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ClientsModule.register([{\n      name: 'CustomProxy',\n      customClass: ErrorHandlingProxy,\n    }]),\n  ]\n})\nexport class AppModule",
      "language": "typescript"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}