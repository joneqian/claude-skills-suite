{
  "url": "https://docs.nestjs.com/recipes/passport",
  "title": "",
  "content": "Passport is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a Nest application using the @nestjs/passport module. At a high level, Passport executes a series of steps to:\n\nPassport has a rich ecosystem of strategies that implement various authentication mechanisms. While simple in concept, the set of Passport strategies you can choose from is large and presents a lot of variety. Passport abstracts these varied steps into a standard pattern, and the @nestjs/passport module wraps and standardizes this pattern into familiar Nest constructs.\n\nIn this chapter, we'll implement a complete end-to-end authentication solution for a RESTful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example.\n\nLet's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a bearer token in an authorization header on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT.\n\nWe'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request.\n\nFirst we need to install the required packages. Passport provides a strategy called passport-local that implements a username/password authentication mechanism, which suits our needs for this portion of our use case.\n\nWe're now ready to implement the authentication feature. We'll start with an overview of the process used for any Passport strategy. It's helpful to think of Passport as a mini framework in itself. The elegance of the framework is that it abstracts the authentication process into a few basic steps that you customize based on the strategy you're implementing. It's like a framework because you configure it by supplying customization parameters (as plain JSON objects) and custom code in the form of callback functions, which Passport calls at the appropriate time. The @nestjs/passport module wraps this framework in a Nest style package, making it easy to integrate into a Nest application. We'll use @nestjs/passport below, but first let's consider how vanilla Passport works.\n\nIn vanilla Passport, you configure a strategy by providing two things:\n\nWith @nestjs/passport, you configure a Passport strategy by extending the PassportStrategy class. You pass the strategy options (item 1 above) by calling the super() method in your subclass, optionally passing in an options object. You provide the verify callback (item 2 above) by implementing a validate() method in your subclass.\n\nWe'll start by generating an AuthModule and in it, an AuthService:\n\nAs we implement the AuthService, we'll find it useful to encapsulate user operations in a UsersService, so let's generate that module and service now:\n\nReplace the default contents of these generated files as shown below. For our sample app, the UsersService simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.).\n\nIn the UsersModule, the only change needed is to add the UsersService to the exports array of the @Module decorator so that it is visible outside this module (we'll soon use it in our AuthService).\n\nOur AuthService has the job of retrieving a user and verifying the password. We create a validateUser() method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. We'll be calling into the validateUser() method from our Passport local strategy in a moment.\n\nNow, we update our AuthModule to import the UsersModule.\n\nNow we can implement our Passport local authentication strategy. Create a file called local.strategy.ts in the auth folder, and add the following code:\n\nWe've followed the recipe described earlier for all Passport strategies. In our use case with passport-local, there are no configuration options, so our constructor simply calls super(), without an options object.\n\nWe've also implemented the validate() method. For each strategy, Passport will call the verify function (implemented with the validate() method in @nestjs/passport) using an appropriate strategy-specific set of parameters. For the local-strategy, Passport expects a validate() method with the following signature: validate(username: string, password:string): any.\n\nMost of the validation work is done in our AuthService (with the help of our UsersService), so this method is quite straightforward. The validate() method for any Passport strategy will follow a similar pattern, varying only in the details of how credentials are represented. If a user is found and the credentials are valid, the user is returned so Passport can complete its tasks (e.g., creating the user property on the Request object), and the request handling pipeline can continue. If it's not found, we throw an exception and let our exceptions layer handle it.\n\nTypically, the only significant difference in the validate() method for each strategy is how you determine if a user exists and is valid. For example, in a JWT strategy, depending on requirements, we may evaluate whether the userId carried in the decoded token matches a record in our user database, or matches a list of revoked tokens. Hence, this pattern of sub-classing and implementing strategy-specific validation is consistent, elegant and extensible.\n\nWe need to configure our AuthModule to use the Passport features we just defined. Update auth.module.ts to look like this:\n\nThe Guards chapter describes the primary function of Guards: to determine whether a request will be handled by the route handler or not. That remains true, and we'll use that standard capability soon. However, in the context of using the @nestjs/passport module, we will also introduce a slight new wrinkle that may at first be confusing, so let's discuss that now. Consider that your app can exist in two states, from an authentication perspective:\n\nIn the first case (user is not logged in), we need to perform two distinct functions:\n\nRestrict the routes an unauthenticated user can access (i.e., deny access to restricted routes). We'll use Guards in their familiar capacity to handle this function, by placing a Guard on the protected routes. As you may anticipate, we'll be checking for the presence of a valid JWT in this Guard, so we'll work on this Guard later, once we are successfully issuing JWTs.\n\nInitiate the authentication step itself when a previously unauthenticated user attempts to login. This is the step where we'll issue a JWT to a valid user. Thinking about this for a moment, we know we'll need to POST username/password credentials to initiate authentication, so we'll set up a POST /auth/login route to handle that. This raises the question: how exactly do we invoke the passport-local strategy in that route?\n\nThe answer is straightforward: by using another, slightly different type of Guard. The @nestjs/passport module provides us with a built-in Guard that does this for us. This Guard invokes the Passport strategy and kicks off the steps described above (retrieving credentials, running the verify function, creating the user property, etc).\n\nThe second case enumerated above (logged in user) simply relies on the standard type of Guard we already discussed to enable access to protected routes for logged in users.\n\nLearn the right way! 19 chapters Authn & Authz Official certificate Deep-dive sessions Purchase the Authentication course\n\nWith the strategy in place, we can now implement a bare-bones /auth/login route, and apply the built-in Guard to initiate the passport-local flow.\n\nOpen the app.controller.ts file and replace its contents with the following:\n\nWith @UseGuards(AuthGuard('local')) we are using an AuthGuard that @nestjs/passportautomatically provisioned for us when we extended the passport-local strategy. Let's break that down. Our Passport local strategy has a default name of 'local'. We reference that name in the @UseGuards() decorator to associate it with code supplied by the passport-local package. This is used to disambiguate which strategy to invoke in case we have multiple Passport strategies in our app (each of which may provision a strategy-specific AuthGuard). While we only have one such strategy so far, we'll shortly add a second, so this is needed for disambiguation.\n\nIn order to test our route we'll have our /auth/login route simply return the user for now. This also lets us demonstrate another Passport feature: Passport automatically creates a user object, based on the value we return from the validate() method, and assigns it to the Request object as req.user. Later, we'll replace this with code to create and return a JWT instead.\n\nSince these are API routes, we'll test them using the commonly available cURL library. You can test with any of the user objects hard-coded in the UsersService.\n\nWhile this works, passing the strategy name directly to the AuthGuard() introduces magic strings in the codebase. Instead, we recommend creating your own class, as shown below:\n\nNow, we can update the /auth/login route handler and use the LocalAuthGuard instead:\n\nTo log out, we can create an additional route that invokes req.logout() to clear the user's session. This is a typical approach used in session-based authentication, but it does not apply to JWTs.\n\nWe're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:\n\nWe'll need to install a couple more packages to support our JWT requirements:\n\nThe @nestjs/jwt package (see more here) is a utility package that helps with JWT manipulation. The passport-jwt package is the Passport package that implements the JWT strategy and @types/passport-jwt provides the TypeScript type definitions.\n\nLet's take a closer look at how a POST /auth/login request is handled. We've decorated the route using the built-in AuthGuard provided by the passport-local strategy. This means that:\n\nWith this in mind, we can now finally generate a real JWT, and return it in this route. To keep our services cleanly modularized, we'll handle generating the JWT in the authService. Open the auth.service.ts file in the auth folder, and add the login() method, and import the JwtService as shown:\n\nWe're using the @nestjs/jwt library, which supplies a sign() function to generate our JWT from a subset of the user object properties, which we then return as a simple object with a single access_token property. Note: we choose a property name of sub to hold our userId value to be consistent with JWT standards. Don't forget to inject the JwtService provider into the AuthService.\n\nWe now need to update the AuthModule to import the new dependencies and configure the JwtModule.\n\nFirst, create constants.ts in the auth folder, and add the following code:\n\nWe'll use this to share our key between the JWT signing and verifying steps.\n\nNow, open auth.module.ts in the auth folder and update it to look like this:\n\nWe configure the JwtModule using register(), passing in a configuration object. See here for more on the Nest JwtModule and here for more details on the available configuration options.\n\nNow we can update the /auth/login route to return a JWT.\n\nLet's go ahead and test our routes using cURL again. You can test with any of the user objects hard-coded in the UsersService.\n\nWe can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. Passport can help us here too. It provides the passport-jwt strategy for securing RESTful endpoints with JSON Web Tokens. Start by creating a file called jwt.strategy.ts in the auth folder, and add the following code:\n\nWith our JwtStrategy, we've followed the same recipe described earlier for all Passport strategies. This strategy requires some initialization, so we do that by passing in an options object in the super() call. You can read more about the available options here. In our case, these options are:\n\nThe validate() method deserves some discussion. For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our validate() method passing the decoded JSON as its single parameter. Based on the way JWT signing works, we're guaranteed that we're receiving a valid token that we have previously signed and issued to a valid user.\n\nAs a result of all this, our response to the validate() callback is trivial: we simply return an object containing the userId and username properties. Recall again that Passport will build a user object based on the return value of our validate() method, and attach it as a property on the Request object.\n\nAdditionally, you can return an array, where the first value is used to create a user object and the second value is used to create an authInfo object.\n\nIt's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our validate() method to extract more information about the user, resulting in a more enriched user object being available in our Request. This is also the place we may decide to do further token validation, such as looking up the userId in a list of revoked tokens, enabling us to perform token revocation. The model we've implemented here in our sample code is a fast, \"stateless JWT\" model, where each API call is immediately authorized based on the presence of a valid JWT, and a small bit of information about the requester (its userId and username) is available in our Request pipeline.\n\nAdd the new JwtStrategy as a provider in the AuthModule:\n\nBy importing the same secret used when we signed the JWT, we ensure that the verify phase performed by Passport, and the sign phase performed in our AuthService, use a common secret.\n\nFinally, we define the JwtAuthGuard class which extends the built-in AuthGuard:\n\nWe can now implement our protected route and its associated Guard.\n\nOpen the app.controller.ts file and update it as shown below:\n\nOnce again, we're applying the AuthGuard that the @nestjs/passport module has automatically provisioned for us when we configured the passport-jwt module. This Guard is referenced by its default name, jwt. When our GET /profile route is hit, the Guard will automatically invoke our passport-jwt custom configured strategy, validate the JWT, and assign the user property to the Request object.\n\nEnsure the app is running, and test the routes using cURL.\n\nNote that in the AuthModule, we configured the JWT to have an expiration of 60 seconds. This is probably too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs and the passport-jwt strategy. If you wait 60 seconds after authenticating before attempting a GET /profile request, you'll receive a 401 Unauthorized response. This is because Passport automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application.\n\nWe've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server.\n\nIn most cases, using a provided AuthGuard class is sufficient. However, there might be use-cases when you would like to simply extend the default error handling or authentication logic. For this, you can extend the built-in class and override methods within a sub-class.\n\nIn addition to extending the default error handling and authentication logic, we can allow authentication to go through a chain of strategies. The first strategy to succeed, redirect, or error will halt the chain. Authentication failures will proceed through each strategy in series, ultimately failing if all strategies fail.\n\nIf the vast majority of your endpoints should be protected by default, you can register the authentication guard as a global guard and instead of using @UseGuards() decorator on top of each controller, you could simply flag which routes should be public.\n\nFirst, register the JwtAuthGuard as a global guard using the following construction (in any module):\n\nWith this in place, Nest will automatically bind JwtAuthGuard to all endpoints.\n\nNow we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the SetMetadata decorator factory function.\n\nIn the file above, we exported two constants. One being our metadata key named IS_PUBLIC_KEY, and the other being our new decorator itself that weâ€™re going to call Public (you can alternatively name it SkipAuth or AllowAnon, whatever fits your project).\n\nNow that we have a custom @Public() decorator, we can use it to decorate any method, as follows:\n\nLastly, we need the JwtAuthGuard to return true when the \"isPublic\" metadata is found. For this, we'll use the Reflector class (read more here).\n\nThe passport API is based on registering strategies to the global instance of the library. Therefore strategies are not designed to have request-dependent options or to be dynamically instantiated per request (read more about the request-scoped providers). When you configure your strategy to be request-scoped, Nest will never instantiate it since it's not tied to any specific route. There is no physical way to determine which \"request-scoped\" strategies should be executed per request.\n\nHowever, there are ways to dynamically resolve request-scoped providers within the strategy. For this, we leverage the module reference feature.\n\nFirst, open the local.strategy.ts file and inject the ModuleRef in the normal way:\n\nBe sure to set the passReqToCallback configuration property to true, as shown above.\n\nIn the next step, the request instance will be used to obtain the current context identifier, instead of generating a new one (read more about request context here).\n\nNow, inside the validate() method of the LocalStrategy class, use the getByRequest() method of the ContextIdFactory class to create a context id based on the request object, and pass this to the resolve() call:\n\nIn the example above, the resolve() method will asynchronously return the request-scoped instance of the AuthService provider (we assumed that AuthService is marked as a request-scoped provider).\n\nAny standard Passport customization options can be passed the same way, using the register() method. The available options depend on the strategy being implemented. For example:\n\nYou can also pass strategies an options object in their constructors to configure them. For the local strategy you can pass e.g.:\n\nTake a look at the official Passport Website for property names.\n\nWhen implementing a strategy, you can provide a name for it by passing a second argument to the PassportStrategy function. If you don't do this, each strategy will have a default name (e.g., 'jwt' for jwt-strategy):\n\nThen, you refer to this via a decorator like @UseGuards(AuthGuard('myjwt')).\n\nIn order to use an AuthGuard with GraphQL, extend the built-in AuthGuard class and override the getRequest() method.\n\nTo get the current authenticated user in your graphql resolver, you can define a @CurrentUser() decorator:\n\nTo use above decorator in your resolver, be sure to include it as a parameter of your query or mutation:\n\nFor the passport-local strategy, you'll also need to add the GraphQL context's arguments to the request body so Passport can access them for validation. Otherwise, you'll get an Unauthorized error.",
  "headings": [
    {
      "level": "h3",
      "text": "Passport (authentication)",
      "id": "passport-authentication"
    },
    {
      "level": "h4",
      "text": "Authentication requirements#",
      "id": "authentication-requirements"
    },
    {
      "level": "h4",
      "text": "Implementing Passport strategies#",
      "id": "implementing-passport-strategies"
    },
    {
      "level": "h4",
      "text": "Implementing Passport local#",
      "id": "implementing-passport-local"
    },
    {
      "level": "h4",
      "text": "Built-in Passport Guards#",
      "id": "built-in-passport-guards"
    },
    {
      "level": "h2",
      "text": "Learn the right way!",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Login route#",
      "id": "login-route"
    },
    {
      "level": "h4",
      "text": "Logout route#",
      "id": "logout-route"
    },
    {
      "level": "h4",
      "text": "JWT functionality#",
      "id": "jwt-functionality"
    },
    {
      "level": "h4",
      "text": "Implementing Passport JWT#",
      "id": "implementing-passport-jwt"
    },
    {
      "level": "h4",
      "text": "Implement protected route and JWT strategy guards#",
      "id": "implement-protected-route-and-jwt-strategy-guards"
    },
    {
      "level": "h4",
      "text": "Extending guards#",
      "id": "extending-guards"
    },
    {
      "level": "h4",
      "text": "Enable authentication globally#",
      "id": "enable-authentication-globally"
    },
    {
      "level": "h4",
      "text": "Request-scoped strategies#",
      "id": "request-scoped-strategies"
    },
    {
      "level": "h4",
      "text": "Customize Passport#",
      "id": "customize-passport"
    },
    {
      "level": "h4",
      "text": "Named strategies#",
      "id": "named-strategies"
    },
    {
      "level": "h4",
      "text": "GraphQL#",
      "id": "graphql"
    }
  ],
  "code_samples": [
    {
      "code": "$ npm install --save @nestjs/passport passport passport-local\n$ npm install --save-dev @types/passport-local",
      "language": "bash"
    },
    {
      "code": "$ nest g module auth\n$ nest g service auth",
      "language": "bash"
    },
    {
      "code": "$ nest g module users\n$ nest g service users",
      "language": "bash"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\n\n// This should be a real class/interface representing a user entity\nexport type User = any;\n\n@Injectable()\nexport class UsersService {\n  private readonly users = [\n    {\n      userId: 1,\n      username: 'john',\n      password: 'changeme',\n    },\n    {\n      userId: 2,\n      username: 'maria',\n      password: 'guess',\n    },\n  ];\n\n  async findOne(username: string): Promise<User | undefined> {\n    return this.users.find(user => user.username === username);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService {\n  constructor() {\n    this.users = [\n      {\n        userId: 1,\n        username: 'john',\n        password: 'changeme',\n      },\n      {\n        userId: 2,\n        username: 'maria',\n        password: 'guess',\n      },\n    ];\n  }\n\n  async findOne(username) {\n    return this.users.find(user => user.username === username);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService) {}\n\n  async validateUser(username: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, Dependencies } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\n@Dependencies(UsersService)\nexport class AuthService {\n  constructor(usersService) {\n    this.usersService = usersService;\n  }\n\n  async validateUser(username, pass) {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super();\n  }\n\n  async validate(username: string, password: string): Promise<any> {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException, Dependencies } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\n@Dependencies(AuthService)\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(authService) {\n    super();\n    this.authService = authService;\n  }\n\n  async validate(username, password) {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller()\nexport class AppController {\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  async login(@Request() req) {\n    return req.user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller()\nexport class AppController {\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return req.user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "$ # POST to /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d '{\"username\": \"john\", \"password\": \"changeme\"}' -H \"Content-Type: application/json\"\n$ # result -> {\"userId\":1,\"username\":\"john\"}",
      "language": "bash"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class LocalAuthGuard extends AuthGuard('local') {}",
      "language": "typescript"
    },
    {
      "code": "@UseGuards(LocalAuthGuard)\n@Post('auth/login')\nasync login(@Request() req) {\n  return req.user;\n}",
      "language": "typescript"
    },
    {
      "code": "@UseGuards(LocalAuthGuard)\n@Post('auth/logout')\nasync logout(@Request() req) {\n  return req.logout();\n}",
      "language": "typescript"
    },
    {
      "code": "$ npm install --save @nestjs/jwt passport-jwt\n$ npm install --save-dev @types/passport-jwt",
      "language": "bash"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\nimport { JwtService } from '@nestjs/jwt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService\n  ) {}\n\n  async validateUser(username: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n\n  async login(user: any) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable, Dependencies } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\nimport { JwtService } from '@nestjs/jwt';\n\n@Dependencies(UsersService, JwtService)\n@Injectable()\nexport class AuthService {\n  constructor(usersService, jwtService) {\n    this.usersService = usersService;\n    this.jwtService = jwtService;\n  }\n\n  async validateUser(username, pass) {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n\n  async login(user) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export const jwtConstants = {\n  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',\n};",
      "language": "typescript"
    },
    {
      "code": "export const jwtConstants = {\n  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',\n};",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return this.authService.login(req.user);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "$ # POST to /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d '{\"username\": \"john\", \"password\": \"changeme\"}' -H \"Content-Type: application/json\"\n$ # result -> {\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"}\n$ # Note: above JWT truncated",
      "language": "bash"
    },
    {
      "code": "import { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { JwtStrategy } from './jwt.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { JwtStrategy } from './jwt.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}",
      "language": "typescript"
    },
    {
      "code": "import { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Get, Request, Post, UseGuards } from '@nestjs/common';\nimport { JwtAuthGuard } from './auth/jwt-auth.guard';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('profile')\n  getProfile(@Request() req) {\n    return req.user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { Controller, Dependencies, Bind, Get, Request, Post, UseGuards } from '@nestjs/common';\nimport { JwtAuthGuard } from './auth/jwt-auth.guard';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Dependencies(AuthService)\n@Controller()\nexport class AppController {\n  constructor(authService) {\n    this.authService = authService;\n  }\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('profile')\n  @Bind(Request())\n  getProfile(req) {\n    return req.user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "$ # GET /profile\n$ curl http://localhost:3000/profile\n$ # result -> {\"statusCode\":401,\"message\":\"Unauthorized\"}\n\n$ # POST /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d '{\"username\": \"john\", \"password\": \"changeme\"}' -H \"Content-Type: application/json\"\n$ # result -> {\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm... }\n\n$ # GET /profile using access_token returned from previous step as bearer code\n$ curl http://localhost:3000/profile -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm...\"\n$ # result -> {\"userId\":1,\"username\":\"john\"}",
      "language": "bash"
    },
    {
      "code": "import {\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    // Add your custom authentication logic here\n    // for example, call super.logIn(request) to establish a session.\n    return super.canActivate(context);\n  }\n\n  handleRequest(err, user, info) {\n    // You can throw an exception based on either \"info\" or \"err\" arguments\n    if (err || !user) {\n      throw err || new UnauthorizedException();\n    }\n    return user;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export class JwtAuthGuard extends AuthGuard(['strategy_jwt_1', 'strategy_jwt_2', '...']) { ... }",
      "language": "typescript"
    },
    {
      "code": "providers: [\n  {\n    provide: APP_GUARD,\n    useClass: JwtAuthGuard,\n  },\n],",
      "language": "typescript"
    },
    {
      "code": "import { SetMetadata } from '@nestjs/common';\n\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);",
      "language": "typescript"
    },
    {
      "code": "@Public()\n@Get()\nfindAll() {\n  return [];\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n    return super.canActivate(context);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "constructor(private moduleRef: ModuleRef) {\n  super({\n    passReqToCallback: true,\n  });\n}",
      "language": "typescript"
    },
    {
      "code": "async validate(\n  request: Request,\n  username: string,\n  password: string,\n) {\n  const contextId = ContextIdFactory.getByRequest(request);\n  // \"AuthService\" is a request-scoped provider\n  const authService = await this.moduleRef.resolve(AuthService, contextId);\n  ...\n}",
      "language": "typescript"
    },
    {
      "code": "PassportModule.register({ session: true });",
      "language": "typescript"
    },
    {
      "code": "constructor(private authService: AuthService) {\n  super({\n    usernameField: 'email',\n    passwordField: 'password',\n  });\n}",
      "language": "typescript"
    },
    {
      "code": "export class JwtStrategy extends PassportStrategy(Strategy, 'myjwt')",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class GqlAuthGuard extends AuthGuard('jwt') {\n  getRequest(context: ExecutionContext) {\n    const ctx = GqlExecutionContext.create(context);\n    return ctx.getContext().req;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "import { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { GqlExecutionContext } from '@nestjs/graphql';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, context: ExecutionContext) => {\n    const ctx = GqlExecutionContext.create(context);\n    return ctx.getContext().req.user;\n  },\n);",
      "language": "typescript"
    },
    {
      "code": "@Query(() => User)\n@UseGuards(GqlAuthGuard)\nwhoAmI(@CurrentUser() user: User) {\n  return this.usersService.findById(user.id);\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class GqlLocalAuthGuard extends AuthGuard('local') {\n  getRequest(context: ExecutionContext) {\n    const gqlExecutionContext = GqlExecutionContext.create(context);\n    const gqlContext = gqlExecutionContext.getContext();\n    const gqlArgs = gqlExecutionContext.getArgs();\n\n    gqlContext.req.body = { ...gqlContext.req.body, ...gqlArgs };\n    return gqlContext.req;\n  }\n}",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Any standard Passport customization options can be passed the same way, using the register() method. The available options depend on the strategy being implemented. For example:",
      "code": "register()"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors",
    "https://docs.nestjs.com/recipes/exception-filters",
    "https://docs.nestjs.com/recipes/guards"
  ]
}