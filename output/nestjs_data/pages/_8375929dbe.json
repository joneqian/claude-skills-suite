{
  "url": "https://docs.nestjs.com/fundamentals/execution-context",
  "title": "",
  "content": "Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic guards, filters, and interceptors that can work across a broad set of controllers, methods, and execution contexts.\n\nWe cover two such classes in this chapter: ArgumentsHost and ExecutionContext.\n\nThe ArgumentsHost class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of ArgumentsHost, typically referenced as a host parameter, in places where you may want to access it. For example, the catch() method of an exception filter is called with an ArgumentsHostinstance.\n\nArgumentsHost simply acts as an abstraction over a handler's arguments. For example, for HTTP server applications (when @nestjs/platform-express is being used), the host object encapsulates Express's [request, response, next] array, where request is the request object, response is the response object, and next is a function that controls the application's request-response cycle. On the other hand, for GraphQL applications, the host object contains the [root, args, context, info] array.\n\nWhen building generic guards, filters, and interceptors which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the getType() method of ArgumentsHost:\n\nWith the application type available, we can write more generic components, as shown below.\n\nTo retrieve the array of arguments being passed to the handler, one approach is to use the host object's getArgs() method.\n\nYou can pluck a particular argument by index using the getArgByIndex() method:\n\nIn these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the host object's utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below.\n\nLet's rewrite the previous example using the switchToHttp() method. The host.switchToHttp() helper call returns an HttpArgumentsHost object that is appropriate for the HTTP application context. The HttpArgumentsHost object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:\n\nSimilarly WsArgumentsHost and RpcArgumentsHost have methods to return appropriate objects in the microservices and WebSockets contexts. Here are the methods for WsArgumentsHost:\n\nFollowing are the methods for RpcArgumentsHost:\n\nExecutionContext extends ArgumentsHost, providing additional details about the current execution process. Like ArgumentsHost, Nest provides an instance of ExecutionContext in places you may need it, such as in the canActivate() method of a guard and the intercept() method of an interceptor. It provides the following methods:\n\nThe getHandler() method returns a reference to the handler about to be invoked. The getClass() method returns the type of the Controller class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a POST request, bound to the create() method on the CatsController, getHandler() returns a reference to the create() method and getClass() returns the CatsControllerclass (not instance).\n\nThe ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through either decorators created via Reflector#createDecorator or the built-in @SetMetadata() decorator from within guards or interceptors. We cover this use case below.\n\nOfficial enterprise support Providing technical guidance Performing in-depth code reviews Mentoring team members Advising best practices Explore more\n\nNest provides the ability to attach custom metadata to route handlers through decorators created via Reflector#createDecorator method, and the built-in @SetMetadata() decorator. In this section, let's compare the two approaches and see how to access the metadata from within a guard or interceptor.\n\nTo create strongly-typed decorators using Reflector#createDecorator, we need to specify the type argument. For example, let's create a Roles decorator that takes an array of strings as an argument.\n\nThe Roles decorator here is a function that takes a single argument of type string[].\n\nNow, to use this decorator, we simply annotate the handler with it:\n\nHere we've attached the Roles decorator metadata to the create() method, indicating that only users with the admin role should be allowed to access this route.\n\nTo access the route's role(s) (custom metadata), we'll use the Reflector helper class again. Reflector can be injected into a class in the normal way:\n\nNow, to read the handler metadata, use the get() method:\n\nThe Reflector#get method allows us to easily access the metadata by passing in two arguments: a decorator reference and a context (decorator target) to retrieve the metadata from. In this example, the specified decorator is Roles (refer back to the roles.decorator.ts file above). The context is provided by the call to context.getHandler(), which results in extracting the metadata for the currently processed route handler. Remember, getHandler() gives us a reference to the route handler function.\n\nAlternatively, we may organize our controller by applying metadata at the controller level, applying to all routes in the controller class.\n\nIn this case, to extract controller metadata, we pass context.getClass() as the second argument (to provide the controller class as the context for metadata extraction) instead of context.getHandler():\n\nGiven the ability to provide metadata at multiple levels, you may need to extract and merge metadata from several contexts. The Reflector class provides two utility methods used to help with this. These methods extract both controller and method metadata at once, and combine them in different ways.\n\nConsider the following scenario, where you've supplied Roles metadata at both levels.\n\nIf your intent is to specify 'user' as the default role, and override it selectively for certain methods, you would probably use the getAllAndOverride() method.\n\nA guard with this code, running in the context of the create() method, with the above metadata, would result in roles containing ['admin'].\n\nTo get metadata for both and merge it (this method merges both arrays and objects), use the getAllAndMerge() method:\n\nThis would result in roles containing ['user', 'admin'].\n\nFor both of these merge methods, you pass the metadata key as the first argument, and an array of metadata target contexts (i.e., calls to the getHandler() and/or getClass() methods) as the second argument.\n\nAs mentioned earlier, instead of using Reflector#createDecorator, you can also use the built-in @SetMetadata() decorator to attach metadata to a handler.\n\nWith the construction above, we attached the roles metadata (roles is a metadata key and ['admin'] is the associated value) to the create() method. While this works, it's not good practice to use @SetMetadata() directly in your routes. Instead, you can create your own decorators, as shown below:\n\nThis approach is much cleaner and more readable, and somewhat resembles the Reflector#createDecorator approach. The difference is that with @SetMetadata you have more control over the metadata key and value, and also can create decorators that take more than one argument.\n\nNow that we have a custom @Roles() decorator, we can use it to decorate the create() method.\n\nTo access the route's role(s) (custom metadata), we'll use the Reflector helper class again:\n\nNow, to read the handler metadata, use the get() method.\n\nHere instead of passing a decorator reference, we pass the metadata key as the first argument (which in our case is 'roles'). Everything else remains the same as in the Reflector#createDecorator example.",
  "headings": [
    {
      "level": "h3",
      "text": "Execution context",
      "id": "execution-context"
    },
    {
      "level": "h4",
      "text": "ArgumentsHost class#",
      "id": "argumentshost-class"
    },
    {
      "level": "h4",
      "text": "Current application context#",
      "id": "current-application-context"
    },
    {
      "level": "h4",
      "text": "Host handler arguments#",
      "id": "host-handler-arguments"
    },
    {
      "level": "h4",
      "text": "ExecutionContext class#",
      "id": "executioncontext-class"
    },
    {
      "level": "h2",
      "text": "Official enterprise support",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Reflection and metadata#",
      "id": "reflection-and-metadata"
    },
    {
      "level": "h4",
      "text": "Low-level approach#",
      "id": "low-level-approach"
    }
  ],
  "code_samples": [
    {
      "code": "if (host.getType() === 'http') {\n  // do something that is only important in the context of regular HTTP requests (REST)\n} else if (host.getType() === 'rpc') {\n  // do something that is only important in the context of Microservice requests\n} else if (host.getType<GqlContextType>() === 'graphql') {\n  // do something that is only important in the context of GraphQL requests\n}",
      "language": "typescript"
    },
    {
      "code": "const [req, res, next] = host.getArgs();",
      "language": "typescript"
    },
    {
      "code": "const request = host.getArgByIndex(0);\nconst response = host.getArgByIndex(1);",
      "language": "typescript"
    },
    {
      "code": "/**\n * Switch context to RPC.\n */\nswitchToRpc(): RpcArgumentsHost;\n/**\n * Switch context to HTTP.\n */\nswitchToHttp(): HttpArgumentsHost;\n/**\n * Switch context to WebSockets.\n */\nswitchToWs(): WsArgumentsHost;",
      "language": "typescript"
    },
    {
      "code": "const ctx = host.switchToHttp();\nconst request = ctx.getRequest<Request>();\nconst response = ctx.getResponse<Response>();",
      "language": "typescript"
    },
    {
      "code": "export interface WsArgumentsHost {\n  /**\n   * Returns the data object.\n   */\n  getData<T>(): T;\n  /**\n   * Returns the client object.\n   */\n  getClient<T>(): T;\n}",
      "language": "typescript"
    },
    {
      "code": "export interface RpcArgumentsHost {\n  /**\n   * Returns the data object.\n   */\n  getData<T>(): T;\n\n  /**\n   * Returns the context object.\n   */\n  getContext<T>(): T;\n}",
      "language": "typescript"
    },
    {
      "code": "export interface ExecutionContext extends ArgumentsHost {\n  /**\n   * Returns the type of the controller class which the current handler belongs to.\n   */\n  getClass<T>(): Type<T>;\n  /**\n   * Returns a reference to the handler (method) that will be invoked next in the\n   * request pipeline.\n   */\n  getHandler(): Function;\n}",
      "language": "typescript"
    },
    {
      "code": "const methodKey = ctx.getHandler().name; // \"create\"\nconst className = ctx.getClass().name; // \"CatsController\"",
      "language": "typescript"
    },
    {
      "code": "import { Reflector } from '@nestjs/core';\n\nexport const Roles = Reflector.createDecorator<string[]>();",
      "language": "javascript"
    },
    {
      "code": "@Post()\n@Roles(['admin'])\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Roles(['admin'])\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class RolesGuard {\n  constructor(private reflector: Reflector) {}\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\n@Dependencies(Reflector)\nexport class CatsService {\n  constructor(reflector) {\n    this.reflector = reflector;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const roles = this.reflector.get(Roles, context.getHandler());",
      "language": "typescript"
    },
    {
      "code": "@Roles(['admin'])\n@Controller('cats')\nexport class CatsController {}",
      "language": "typescript"
    },
    {
      "code": "@Roles(['admin'])\n@Controller('cats')\nexport class CatsController {}",
      "language": "typescript"
    },
    {
      "code": "const roles = this.reflector.get(Roles, context.getClass());",
      "language": "typescript"
    },
    {
      "code": "@Roles(['user'])\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  @Roles(['admin'])\n  async create(@Body() createCatDto: CreateCatDto) {\n    this.catsService.create(createCatDto);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Roles(['user'])\n@Controller('cats')\nexport class CatsController {}\n  @Post()\n  @Roles(['admin'])\n  @Bind(Body())\n  async create(createCatDto) {\n    this.catsService.create(createCatDto);\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()]);",
      "language": "typescript"
    },
    {
      "code": "const roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()]);",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@SetMetadata('roles', ['admin'])\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@SetMetadata('roles', ['admin'])\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "import { SetMetadata } from '@nestjs/common';\n\nexport const Roles = (...roles: string[]) => SetMetadata('roles', roles);",
      "language": "typescript"
    },
    {
      "code": "import { SetMetadata } from '@nestjs/common';\n\nexport const Roles = (...roles) => SetMetadata('roles', roles);",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Roles('admin')\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Post()\n@Roles('admin')\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class RolesGuard {\n  constructor(private reflector: Reflector) {}\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\n@Dependencies(Reflector)\nexport class CatsService {\n  constructor(reflector) {\n    this.reflector = reflector;\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "const roles = this.reflector.get<string[]>('roles', context.getHandler());",
      "language": "typescript"
    }
  ],
  "patterns": [],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}