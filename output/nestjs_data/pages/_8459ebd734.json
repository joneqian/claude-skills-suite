{
  "url": "https://docs.nestjs.com/fundamentals/testing",
  "title": "",
  "content": "Automated testing is considered an essential part of any serious software development effort. Automation makes it easy to repeat individual tests or test suites quickly and easily during development. This helps ensure that releases meet quality and performance goals. Automation helps increase coverage and provides a faster feedback loop to developers. Automation both increases the productivity of individual developers and ensures that tests are run at critical development lifecycle junctures, such as source code control check-in, feature integration, and version release.\n\nSuch tests often span a variety of types, including unit tests, end-to-end (e2e) tests, integration tests, and so on. While the benefits are unquestionable, it can be tedious to set them up. Nest strives to promote development best practices, including effective testing, so it includes features such as the following to help developers and teams build and automate tests. Nest:\n\nAs mentioned, you can use any testing framework that you like, as Nest doesn't force any specific tooling. Simply replace the elements needed (such as the test runner), and you will still enjoy the benefits of Nest's ready-made testing facilities.\n\nTo get started, first install the required package:\n\nIn the following example, we test two classes: CatsController and CatsService. As mentioned, Jest is provided as the default testing framework. It serves as a test-runner and also provides assert functions and test-double utilities that help with mocking, spying, etc. In the following basic test, we manually instantiate these classes, and ensure that the controller and service fulfill their API contract.\n\nBecause the above sample is trivial, we aren't really testing anything Nest-specific. Indeed, we aren't even using dependency injection (notice that we pass an instance of CatsService to our catsController). This form of testing - where we manually instantiate the classes being tested - is often called isolated testing as it is independent from the framework. Let's introduce some more advanced capabilities that help you test applications that make more extensive use of Nest features.\n\nThe @nestjs/testing package provides a set of utilities that enable a more robust testing process. Let's rewrite the previous example using the built-in Test class:\n\nThe Test class is useful for providing an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The Test class has a createTestingModule() method that takes a module metadata object as its argument (the same object you pass to the @Module() decorator). This method returns a TestingModule instance which in turn provides a few methods. For unit tests, the important one is the compile() method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional main.ts file using NestFactory.create()), and returns a module that is ready for testing.\n\nTestingModule inherits from the module reference class, and therefore its ability to dynamically resolve scoped providers (transient or request-scoped). Do this with the resolve() method (the get() method can only retrieve static instances).\n\nInstead of using the production version of any provider, you can override it with a custom provider for testing purposes. For example, you can mock a database service instead of connecting to a live database. We'll cover overrides in the next section, but they're available for unit tests as well.\n\nLearn the right way! 80+ chapters 5+ hours of videos Official certificate Deep-dive sessions Explore official courses\n\nNest also allows you to define a mock factory to apply to all of your missing dependencies. This is useful for cases where you have a large number of dependencies in a class and mocking all of them will take a long time and a lot of setup. To make use of this feature, the createTestingModule() will need to be chained up with the useMocker() method, passing a factory for your dependency mocks. This factory can take in an optional token, which is an instance token, any token which is valid for a Nest provider, and returns a mock implementation. The below is an example of creating a generic mocker using jest-mock and a specific mock for CatsService using jest.fn().\n\nYou can also retrieve these mocks out of the testing container as you normally would custom providers, moduleRef.get(CatsService).\n\nUnlike unit testing, which focuses on individual modules and classes, end-to-end (e2e) testing covers the interaction of classes and modules at a more aggregate level -- closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements. To perform e2e tests we use a similar configuration to the one we just covered in unit testing. In addition, Nest makes it easy to use the Supertest library to simulate HTTP requests.\n\nIn this example, we build on some of the concepts described earlier. In addition to the compile() method we used earlier, we now use the createNestApplication() method to instantiate a full Nest runtime environment.\n\nOne caveat to consider is that when your application is compiled using the compile() method, the HttpAdapterHost#httpAdapter will be undefined at that time. This is because there isn't an HTTP adapter or server created yet during this compilation phase. If your test requires the httpAdapter, you should use the createNestApplication() method to create the application instance, or refactor your project to avoid this dependency when initializing the dependencies graph.\n\nAlright, let's break down the example:\n\nWe save a reference to the running app in our app variable so we can use it to simulate HTTP requests.\n\nWe simulate HTTP tests using the request() function from Supertest. We want these HTTP requests to route to our running Nest app, so we pass the request() function a reference to the HTTP listener that underlies Nest (which, in turn, may be provided by the Express platform). Hence the construction request(app.getHttpServer()). The call to request() hands us a wrapped HTTP Server, now connected to the Nest app, which exposes methods to simulate an actual HTTP request. For example, using request(...).get('/cats') will initiate a request to the Nest app that is identical to an actual HTTP request like get '/cats' coming in over the network.\n\nIn this example, we also provide an alternate (test-double) implementation of the CatsService which simply returns a hard-coded value that we can test for. Use overrideProvider() to provide such an alternate implementation. Similarly, Nest provides methods to override modules, guards, interceptors, filters and pipes with the overrideModule(), overrideGuard(), overrideInterceptor(), overrideFilter(), and overridePipe() methods respectively.\n\nEach of the override methods (except for overrideModule()) returns an object with 3 different methods that mirror those described for custom providers:\n\nOn the other hand, overrideModule() returns an object with the useModule() method, which you can use to supply a module that will override the original module, as follows:\n\nEach of the override method types, in turn, returns the TestingModule instance, and can thus be chained with other methods in the fluent style. You should use compile() at the end of such a chain to cause Nest to instantiate and initialize the module.\n\nAlso, sometimes you may want to provide a custom logger e.g. when the tests are run (for example, on a CI server). Use the setLogger() method and pass an object that fulfills the LoggerService interface to instruct the TestModuleBuilder how to log during tests (by default, only \"error\" logs will be logged to the console).\n\nThe compiled module has several useful methods, as described in the following table:\n\nIf you have a globally registered guard (or pipe, interceptor, or filter), you need to take a few more steps to override that enhancer. To recap the original registration looks like this:\n\nThis is registering the guard as a \"multi\"-provider through the APP_* token. To be able to replace the JwtAuthGuard here, the registration needs to use an existing provider in this slot:\n\nNow the JwtAuthGuard is visible to Nest as a regular provider that can be overridden when creating the TestingModule:\n\nNow all your tests will use the MockAuthGuard on every request.\n\nRequest-scoped providers are created uniquely for each incoming request. The instance is garbage-collected after the request has completed processing. This poses a problem, because we can't access a dependency injection sub-tree generated specifically for a tested request.\n\nWe know (based on the sections above) that the resolve() method can be used to retrieve a dynamically instantiated class. Also, as described here, we know we can pass a unique context identifier to control the lifecycle of a DI container sub-tree. How do we leverage this in a testing context?\n\nThe strategy is to generate a context identifier beforehand and force Nest to use this particular ID to create a sub-tree for all incoming requests. In this way we'll be able to retrieve instances created for a tested request.\n\nTo accomplish this, use jest.spyOn() on the ContextIdFactory:\n\nNow we can use the contextId to access a single generated DI container sub-tree for any subsequent request.",
  "headings": [
    {
      "level": "h3",
      "text": "Testing",
      "id": "testing"
    },
    {
      "level": "h4",
      "text": "Installation#",
      "id": "installation"
    },
    {
      "level": "h4",
      "text": "Unit testing#",
      "id": "unit-testing"
    },
    {
      "level": "h4",
      "text": "Testing utilities#",
      "id": "testing-utilities"
    },
    {
      "level": "h2",
      "text": "Learn the right way!",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Auto mocking#",
      "id": "auto-mocking"
    },
    {
      "level": "h4",
      "text": "End-to-end testing#",
      "id": "end-to-end-testing"
    },
    {
      "level": "h4",
      "text": "Overriding globally registered enhancers#",
      "id": "overriding-globally-registered-enhancers"
    },
    {
      "level": "h4",
      "text": "Testing request-scoped instances#",
      "id": "testing-request-scoped-instances"
    }
  ],
  "code_samples": [
    {
      "code": "$ npm i --save-dev @nestjs/testing",
      "language": "bash"
    },
    {
      "code": "import { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController: CatsController;\n  let catsService: CatsService;\n\n  beforeEach(() => {\n    catsService = new CatsService();\n    catsController = new CatsController(catsService);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "import { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController;\n  let catsService;\n\n  beforeEach(() => {\n    catsService = new CatsService();\n    catsController = new CatsController(catsService);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "import { Test } from '@nestjs/testing';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController: CatsController;\n  let catsService: CatsService;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n        controllers: [CatsController],\n        providers: [CatsService],\n      }).compile();\n\n    catsService = moduleRef.get(CatsService);\n    catsController = moduleRef.get(CatsController);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "import { Test } from '@nestjs/testing';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController;\n  let catsService;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n        controllers: [CatsController],\n        providers: [CatsService],\n      }).compile();\n\n    catsService = moduleRef.get(CatsService);\n    catsController = moduleRef.get(CatsController);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "const moduleRef = await Test.createTestingModule({\n  controllers: [CatsController],\n  providers: [CatsService],\n}).compile();\n\ncatsService = await moduleRef.resolve(CatsService);",
      "language": "typescript"
    },
    {
      "code": "// ...\nimport { ModuleMocker, MockMetadata } from 'jest-mock';\n\nconst moduleMocker = new ModuleMocker(global);\n\ndescribe('CatsController', () => {\n  let controller: CatsController;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n      controllers: [CatsController],\n    })\n      .useMocker((token) => {\n        const results = ['test1', 'test2'];\n        if (token === CatsService) {\n          return { findAll: jest.fn().mockResolvedValue(results) };\n        }\n        if (typeof token === 'function') {\n          const mockMetadata = moduleMocker.getMetadata(\n            token,\n          ) as MockMetadata<any, any>;\n          const Mock = moduleMocker.generateFromMetadata(\n            mockMetadata,\n          ) as ObjectConstructor;\n          return new Mock();\n        }\n      })\n      .compile();\n\n    controller = moduleRef.get(CatsController);\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "import * as request from 'supertest';\nimport { Test } from '@nestjs/testing';\nimport { CatsModule } from '../../src/cats/cats.module';\nimport { CatsService } from '../../src/cats/cats.service';\nimport { INestApplication } from '@nestjs/common';\n\ndescribe('Cats', () => {\n  let app: INestApplication;\n  let catsService = { findAll: () => ['test'] };\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [CatsModule],\n    })\n      .overrideProvider(CatsService)\n      .useValue(catsService)\n      .compile();\n\n    app = moduleRef.createNestApplication();\n    await app.init();\n  });\n\n  it(`/GET cats`, () => {\n    return request(app.getHttpServer())\n      .get('/cats')\n      .expect(200)\n      .expect({\n        data: catsService.findAll(),\n      });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "import * as request from 'supertest';\nimport { Test } from '@nestjs/testing';\nimport { CatsModule } from '../../src/cats/cats.module';\nimport { CatsService } from '../../src/cats/cats.service';\nimport { INestApplication } from '@nestjs/common';\n\ndescribe('Cats', () => {\n  let app: INestApplication;\n  let catsService = { findAll: () => ['test'] };\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [CatsModule],\n    })\n      .overrideProvider(CatsService)\n      .useValue(catsService)\n      .compile();\n\n    app = moduleRef.createNestApplication();\n    await app.init();\n  });\n\n  it(`/GET cats`, () => {\n    return request(app.getHttpServer())\n      .get('/cats')\n      .expect(200)\n      .expect({\n        data: catsService.findAll(),\n      });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});",
      "language": "typescript"
    },
    {
      "code": "let app: NestFastifyApplication;\n\nbeforeAll(async () => {\n  app = moduleRef.createNestApplication<NestFastifyApplication>(\n    new FastifyAdapter(),\n  );\n\n  await app.init();\n  await app.getHttpAdapter().getInstance().ready();\n});\n\nit(`/GET cats`, () => {\n  return app\n    .inject({\n      method: 'GET',\n      url: '/cats',\n    })\n    .then((result) => {\n      expect(result.statusCode).toEqual(200);\n      expect(result.payload).toEqual(/* expectedPayload */);\n    });\n});\n\nafterAll(async () => {\n  await app.close();\n});",
      "language": "javascript"
    },
    {
      "code": "const moduleRef = await Test.createTestingModule({\n  imports: [AppModule],\n})\n  .overrideModule(CatsModule)\n  .useModule(AlternateCatsModule)\n  .compile();",
      "language": "typescript"
    },
    {
      "code": "providers: [\n  {\n    provide: APP_GUARD,\n    useClass: JwtAuthGuard,\n  },\n],",
      "language": "typescript"
    },
    {
      "code": "providers: [\n  {\n    provide: APP_GUARD,\n    useExisting: JwtAuthGuard,\n    // ^^^^^^^^ notice the use of 'useExisting' instead of 'useClass'\n  },\n  JwtAuthGuard,\n],",
      "language": "typescript"
    },
    {
      "code": "const moduleRef = await Test.createTestingModule({\n  imports: [AppModule],\n})\n  .overrideProvider(JwtAuthGuard)\n  .useClass(MockAuthGuard)\n  .compile();",
      "language": "typescript"
    },
    {
      "code": "const contextId = ContextIdFactory.create();\njest\n  .spyOn(ContextIdFactory, 'getByRequest')\n  .mockImplementation(() => contextId);",
      "language": "typescript"
    },
    {
      "code": "catsService = await moduleRef.resolve(CatsService, contextId);",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Alright, let's break down the example:",
      "code": "app"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}