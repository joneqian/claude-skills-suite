{
  "url": "https://docs.nestjs.com/graphql/subscriptions",
  "title": "",
  "content": "In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called subscription. GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a channel is opened and a result is sent to the client every time a particular event happens on the server.\n\nA common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on (read more here).\n\nTo enable subscriptions, set the installSubscriptionHandlers property to true.\n\nTo switch to use the graphql-ws package instead, use the following configuration:\n\nTo create a subscription using the code first approach, we use the @Subscription() decorator (exported from the @nestjs/graphql package) and the PubSub class from the graphql-subscriptions package, which provides a simple publish/subscribe API.\n\nThe following subscription handler takes care of subscribing to an event by calling PubSub#asyncIterableIterator. This method takes a single argument, the triggerName, which corresponds to an event topic name.\n\nThis will result in generating the following part of the GraphQL schema in SDL:\n\nNote that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., commentAdded above), or is provided explicitly by passing an option with the key name as the second argument to the @Subscription() decorator, as shown below.\n\nThis construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription.\n\nNow, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:\n\nThe PubSub#publish method takes a triggerName (again, think of this as an event topic name) as the first parameter, and an event payload as the second parameter. As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our commentAdded subscription:\n\nThis tells us that the subscription must return an object with a top-level property name of commentAdded that has a value which is a Comment object. The important point to note is that the shape of the event payload emitted by the PubSub#publish method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the pubSub.publish('commentAdded', { commentAdded: newComment }) statement publishes a commentAdded event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase.\n\nTo filter out specific events, set the filter property to a filter function. This function acts similar to the function passed to an array filter. It takes two arguments: payload containing the event payload (as sent by the event publisher), and variables taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners.\n\nTo mutate the published event payload, set the resolve property to a function. The function receives the event payload (as sent by the event publisher) and returns the appropriate value.\n\nIf you need to access injected providers (e.g., use an external service to validate the data), use the following construction.\n\nThe same construction works with filters:\n\nTo create an equivalent subscription in Nest, we'll make use of the @Subscription() decorator.\n\nTo filter out specific events based on context and arguments, set the filter property.\n\nTo mutate the published payload, we can use a resolve function.\n\nIf you need to access injected providers (e.g., use an external service to validate the data), use the following construction:\n\nThe same construction works with filters:\n\nThe last step is to update the type definitions file.\n\nWith this, we've created a single commentAdded(title: String!): Comment subscription. You can find a full sample implementation here.\n\nWe instantiated a local PubSub instance above. The preferred approach is to define PubSub as a provider and inject it through the constructor (using the @Inject() decorator). This allows us to re-use the instance across the whole application. For example, define a provider as follows, then inject 'PUB_SUB' where needed.\n\nTo customize the subscriptions server (e.g., change the path), use the subscriptions options property.\n\nIf you're using the graphql-ws package for subscriptions, replace the subscriptions-transport-ws key with graphql-ws, as follows:\n\nChecking whether the user is authenticated can be done inside the onConnect callback function that you can specify in the subscriptions options.\n\nThe onConnect will receive as a first argument the connectionParams passed to the SubscriptionClient (read more).\n\nThe authToken in this example is only sent once by the client, when the connection is first established. All subscriptions made with this connection will have the same authToken, and thus the same user info.\n\nIf you're using the graphql-ws package, the signature of the onConnect callback will be slightly different:\n\nTo enable subscriptions, set the subscription property to true.\n\nTo create a subscription using the code first approach, we use the @Subscription() decorator (exported from the @nestjs/graphql package) and the PubSub class from the mercurius package, which provides a simple publish/subscribe API.\n\nThe following subscription handler takes care of subscribing to an event by calling PubSub#asyncIterableIterator. This method takes a single argument, the triggerName, which corresponds to an event topic name.\n\nThis will result in generating the following part of the GraphQL schema in SDL:\n\nNote that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., commentAdded above), or is provided explicitly by passing an option with the key name as the second argument to the @Subscription() decorator, as shown below.\n\nThis construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription.\n\nNow, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:\n\nAs mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our commentAdded subscription:\n\nThis tells us that the subscription must return an object with a top-level property name of commentAdded that has a value which is a Comment object. The important point to note is that the shape of the event payload emitted by the PubSub#publish method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the pubSub.publish({ topic: 'commentAdded', payload: { commentAdded: newComment } }) statement publishes a commentAdded event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase.\n\nTo filter out specific events, set the filter property to a filter function. This function acts similar to the function passed to an array filter. It takes two arguments: payload containing the event payload (as sent by the event publisher), and variables taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners.\n\nIf you need to access injected providers (e.g., use an external service to validate the data), use the following construction.\n\nTo create an equivalent subscription in Nest, we'll make use of the @Subscription() decorator.\n\nTo filter out specific events based on context and arguments, set the filter property.\n\nIf you need to access injected providers (e.g., use an external service to validate the data), use the following construction:\n\nThe last step is to update the type definitions file.\n\nWith this, we've created a single commentAdded(title: String!): Comment subscription.\n\nIn the examples above, we used the default PubSub emitter (mqemitter) The preferred approach (for production) is to use mqemitter-redis. Alternatively, a custom PubSub implementation can be provided (read more here)\n\nChecking whether the user is authenticated can be done inside the verifyClient callback function that you can specify in the subscription options.\n\nThe verifyClient will receive the info object as a first argument which you can use to retrieve the request's headers.",
  "headings": [
    {
      "level": "h3",
      "text": "Subscriptions",
      "id": "subscriptions"
    },
    {
      "level": "h4",
      "text": "Enable subscriptions with Apollo driver#",
      "id": "enable-subscriptions-with-apollo-driver"
    },
    {
      "level": "h4",
      "text": "Code first#",
      "id": "code-first"
    },
    {
      "level": "h4",
      "text": "Publishing#",
      "id": "publishing"
    },
    {
      "level": "h4",
      "text": "Filtering subscriptions#",
      "id": "filtering-subscriptions"
    },
    {
      "level": "h4",
      "text": "Mutating subscription payloads#",
      "id": "mutating-subscription-payloads"
    },
    {
      "level": "h4",
      "text": "Schema first#",
      "id": "schema-first"
    },
    {
      "level": "h4",
      "text": "PubSub#",
      "id": "pubsub"
    },
    {
      "level": "h4",
      "text": "Customize subscriptions server#",
      "id": "customize-subscriptions-server"
    },
    {
      "level": "h4",
      "text": "Authentication over WebSockets#",
      "id": "authentication-over-websockets"
    },
    {
      "level": "h4",
      "text": "Enable subscriptions with Mercurius driver#",
      "id": "enable-subscriptions-with-mercurius-driver"
    },
    {
      "level": "h4",
      "text": "Code first#",
      "id": "code-first-1"
    },
    {
      "level": "h4",
      "text": "Publishing#",
      "id": "publishing-1"
    },
    {
      "level": "h4",
      "text": "Filtering subscriptions#",
      "id": "filtering-subscriptions-1"
    },
    {
      "level": "h4",
      "text": "Schema first#",
      "id": "schema-first-1"
    },
    {
      "level": "h4",
      "text": "PubSub#",
      "id": "pubsub-1"
    },
    {
      "level": "h4",
      "text": "Authentication over WebSockets#",
      "id": "authentication-over-websockets-1"
    }
  ],
  "code_samples": [
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  installSubscriptionHandlers: true,\n}),",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': true\n  },\n}),",
      "language": "typescript"
    },
    {
      "code": "const pubSub = new PubSub();\n\n@Resolver(() => Author)\nexport class AuthorResolver {\n  // ...\n  @Subscription(() => Comment)\n  commentAdded() {\n    return pubSub.asyncIterableIterator('commentAdded');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "type Subscription {\n  commentAdded(): Comment!\n}",
      "language": "unknown"
    },
    {
      "code": "@Subscription(() => Comment, {\n  name: 'commentAdded',\n})\nsubscribeToCommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Mutation(() => Comment)\nasync addComment(\n  @Args('postId', { type: () => Int }) postId: number,\n  @Args('comment', { type: () => Comment }) comment: CommentInput,\n) {\n  const newComment = this.commentsService.addComment({ id: postId, comment });\n  pubSub.publish('commentAdded', { commentAdded: newComment });\n  return newComment;\n}",
      "language": "typescript"
    },
    {
      "code": "type Subscription {\n  commentAdded(): Comment!\n}",
      "language": "unknown"
    },
    {
      "code": "@Subscription(() => Comment, {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Args('title') title: string) {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription(() => Comment, {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription(() => Comment, {\n  resolve(this: AuthorResolver, value) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription(() => Comment, {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "const pubSub = new PubSub();\n\n@Resolver('Author')\nexport class AuthorResolver {\n  // ...\n  @Subscription()\n  commentAdded() {\n    return pubSub.asyncIterableIterator('commentAdded');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  resolve(this: AuthorResolver, value) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterableIterator('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "type Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Comment {\n  id: String\n  content: String\n}\n\ntype Subscription {\n  commentAdded(title: String!): Comment\n}",
      "language": "css"
    },
    {
      "code": "{\n  provide: 'PUB_SUB',\n  useValue: new PubSub(),\n}",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'subscriptions-transport-ws': {\n      path: '/graphql'\n    },\n  }\n}),",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': {\n      path: '/graphql'\n    },\n  }\n}),",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'subscriptions-transport-ws': {\n      onConnect: (connectionParams) => {\n        const authToken = connectionParams.authToken;\n        if (!isValid(authToken)) {\n          throw new Error('Token is not valid');\n        }\n        // extract user information from token\n        const user = parseToken(authToken);\n        // return user info to add them to the context later\n        return { user };\n      },\n    }\n  },\n  context: ({ connection }) => {\n    // connection.context will be equal to what was returned by the \"onConnect\" callback\n  },\n}),",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': {\n      onConnect: (context: Context<any>) => {\n        const { connectionParams, extra } = context;\n        // user validation will remain the same as in the example above\n        // when using with graphql-ws, additional context value should be stored in the extra field\n        extra.user = { user: {} };\n      },\n    },\n  },\n  context: ({ extra }) => {\n    // you can now access your additional context value through the extra field\n  },\n});",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: true,\n}),",
      "language": "typescript"
    },
    {
      "code": "@Resolver(() => Author)\nexport class AuthorResolver {\n  // ...\n  @Subscription(() => Comment)\n  commentAdded(@Context('pubsub') pubSub: PubSub) {\n    return pubSub.subscribe('commentAdded');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "type Subscription {\n  commentAdded(): Comment!\n}",
      "language": "unknown"
    },
    {
      "code": "@Subscription(() => Comment, {\n  name: 'commentAdded',\n})\nsubscribeToCommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Mutation(() => Comment)\nasync addComment(\n  @Args('postId', { type: () => Int }) postId: number,\n  @Args('comment', { type: () => Comment }) comment: CommentInput,\n  @Context('pubsub') pubSub: PubSub,\n) {\n  const newComment = this.commentsService.addComment({ id: postId, comment });\n  await pubSub.publish({\n    topic: 'commentAdded',\n    payload: {\n      commentAdded: newComment\n    }\n  });\n  return newComment;\n}",
      "language": "typescript"
    },
    {
      "code": "type Subscription {\n  commentAdded(): Comment!\n}",
      "language": "unknown"
    },
    {
      "code": "@Subscription(() => Comment, {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription(() => Comment, {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "const pubSub = new PubSub();\n\n@Resolver('Author')\nexport class AuthorResolver {\n  // ...\n  @Subscription()\n  commentAdded(@Context('pubsub') pubSub: PubSub) {\n    return pubSub.subscribe('commentAdded');\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "@Subscription('commentAdded', {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}",
      "language": "typescript"
    },
    {
      "code": "type Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Comment {\n  id: String\n  content: String\n}\n\ntype Subscription {\n  commentAdded(title: String!): Comment\n}",
      "language": "css"
    },
    {
      "code": "GraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: {\n    emitter: require('mqemitter-redis')({\n      port: 6579,\n      host: '127.0.0.1',\n    }),\n  },\n});",
      "language": "typescript"
    },
    {
      "code": "GraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: {\n    verifyClient: (info, next) => {\n      const authorization = info.req.headers?.authorization as string;\n      if (!authorization?.startsWith('Bearer ')) {\n        return next(false);\n      }\n      next(true);\n    },\n  }\n}),",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "Now, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:",
      "code": "PubSub#publish"
    },
    {
      "description": "Now, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:",
      "code": "PubSub#publish"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors"
  ]
}