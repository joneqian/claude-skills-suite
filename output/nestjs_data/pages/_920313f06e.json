{
  "url": "https://docs.nestjs.com/techniques/configuration",
  "title": "",
  "content": "Applications often run in different environments. Depending on the environment, different configuration settings should be used. For example, usually the local environment relies on specific database credentials, valid only for the local DB instance. The production environment would use a separate set of DB credentials. Since configuration variables change, best practice is to store configuration variables in the environment.\n\nExternally defined environment variables are visible inside Node.js through the process.env global. We could try to solve the problem of multiple environments by setting the environment variables separately in each environment. This can quickly get unwieldy, especially in the development and testing environments where these values need to be easily mocked and/or changed.\n\nIn Node.js applications, it's common to use .env files, holding key-value pairs where each key represents a particular value, to represent each environment. Running an app in different environments is then just a matter of swapping in the correct .env file.\n\nA good approach for using this technique in Nest is to create a ConfigModule that exposes a ConfigService which loads the appropriate .env file. While you may choose to write such a module yourself, for convenience Nest provides the @nestjs/config package out-of-the box. We'll cover this package in the current chapter.\n\nTo begin using it, we first install the required dependency.\n\nOnce the installation process is complete, we can import the ConfigModule. Typically, we'll import it into the root AppModule and control its behavior using the .forRoot() static method. During this step, environment variable key/value pairs are parsed and resolved. Later, we'll see several options for accessing the ConfigService class of the ConfigModule in our other feature modules.\n\nThe above code will load and parse a .env file from the default location (the project root directory), merge key/value pairs from the .env file with environment variables assigned to process.env, and store the result in a private structure that you can access through the ConfigService. The forRoot() method registers the ConfigService provider, which provides a get() method for reading these parsed/merged configuration variables. Since @nestjs/config relies on dotenv, it uses that package's rules for resolving conflicts in environment variable names. When a key exists both in the runtime environment as an environment variable (e.g., via OS shell exports like export DATABASE_USER=test) and in a .env file, the runtime environment variable takes precedence.\n\nA sample .env file looks something like this:\n\nIf you need some env variables to be available even before the ConfigModule is loaded and Nest application is bootstrapped (for example, to pass the microservice configuration to the NestFactory#createMicroservice method), you can use the --env-file option of the Nest CLI. This option allows you to specify the path to the .env file that should be loaded before the application starts. --env-file flag support was introduced in Node v20, see the documentation for more details.\n\nBy default, the package looks for a .env file in the root directory of the application. To specify another path for the .env file, set the envFilePath property of an (optional) options object you pass to forRoot(), as follows:\n\nYou can also specify multiple paths for .env files like this:\n\nIf a variable is found in multiple files, the first one takes precedence.\n\nIf you don't want to load the .env file, but instead would like to simply access environment variables from the runtime environment (as with OS shell exports like export DATABASE_USER=test), set the options object's ignoreEnvFile property to true, as follows:\n\nWhen you want to use ConfigModule in other modules, you'll need to import it (as is standard with any Nest module). Alternatively, declare it as a global module by setting the options object's isGlobal property to true, as shown below. In that case, you will not need to import ConfigModule in other modules once it's been loaded in the root module (e.g., AppModule).\n\nFor more complex projects, you may utilize custom configuration files to return nested configuration objects. This allows you to group related configuration settings by function (e.g., database-related settings), and to store related settings in individual files to help manage them independently.\n\nA custom configuration file exports a factory function that returns a configuration object. The configuration object can be any arbitrarily nested plain JavaScript object. The process.env object will contain the fully resolved environment variable key/value pairs (with .env file and externally defined variables resolved and merged as described above). Since you control the returned configuration object, you can add any required logic to cast values to an appropriate type, set default values, etc. For example:\n\nWe load this file using the load property of the options object we pass to the ConfigModule.forRoot() method:\n\nWith custom configuration files, we can also manage custom files such as YAML files. Here is an example of a configuration using YAML format:\n\nTo read and parse YAML files, we can leverage the js-yaml package.\n\nOnce the package is installed, we use the yaml#load function to load the YAML file we just created above.\n\nJust a quick note - configuration files aren't automatically validated, even if you're using the validationSchema option in NestJS's ConfigModule. If you need validation or want to apply any transformations, you'll have to handle that within the factory function where you have complete control over the configuration object. This allows you to implement any custom validation logic as needed.\n\nFor example, if you want to ensure that port is within a certain range, you can add a validation step to the factory function:\n\nNow, if the port is outside the specified range, the application will throw an error during startup.\n\nExplore your graph with NestJS Devtools Graph visualizer Routes navigator Interactive playground CI/CD integration Sign up\n\nTo access configuration values from our ConfigService, we first need to inject ConfigService. As with any provider, we need to import its containing module - the ConfigModule - into the module that will use it (unless you set the isGlobal property in the options object passed to the ConfigModule.forRoot() method to true). Import it into a feature module as shown below.\n\nThen we can inject it using standard constructor injection:\n\nAnd use it in our class:\n\nAs shown above, use the configService.get() method to get a simple environment variable by passing the variable name. You can do TypeScript type hinting by passing the type, as shown above (e.g., get<string>(...)). The get() method can also traverse a nested custom configuration object (created via a Custom configuration file), as shown in the second example above.\n\nYou can also get the whole nested custom configuration object using an interface as the type hint:\n\nThe get() method also takes an optional second argument defining a default value, which will be returned when the key doesn't exist, as shown below:\n\nConfigService has two optional generics (type arguments). The first one is to help prevent accessing a config property that does not exist. Use it as shown below:\n\nWith the infer property set to true, the ConfigService#get method will automatically infer the property type based on the interface, so for example, typeof port === \"number\" (if you're not using strictNullChecks flag from TypeScript) since PORT has a number type in the EnvironmentVariables interface.\n\nAlso, with the infer feature, you can infer the type of a nested custom configuration object's property, even when using dot notation, as follows:\n\nThe second generic relies on the first one, acting as a type assertion to get rid of all undefined types that ConfigService's methods can return when strictNullChecks is on. For instance:\n\nThe ConfigModule allows you to define and load multiple custom configuration files, as shown in Custom configuration files above. You can manage complex configuration object hierarchies with nested configuration objects as shown in that section. Alternatively, you can return a \"namespaced\" configuration object with the registerAs() function as follows:\n\nAs with custom configuration files, inside your registerAs() factory function, the process.env object will contain the fully resolved environment variable key/value pairs (with .env file and externally defined variables resolved and merged as described above).\n\nLoad a namespaced configuration with the load property of the forRoot() method's options object, in the same way you load a custom configuration file:\n\nNow, to get the host value from the database namespace, use dot notation. Use 'database' as the prefix to the property name, corresponding to the name of the namespace (passed as the first argument to the registerAs() function):\n\nA reasonable alternative is to inject the database namespace directly. This allows us to benefit from strong typing:\n\nTo use a namespaced configuration as a configuration object for another module in your application, you can utilize the .asProvider() method of the configuration object. This method converts your namespaced configuration into a provider, which can then be passed to the forRootAsync() (or any equivalent method) of the module you want to use.\n\nTo understand how the .asProvider() method functions, let's examine the return value:\n\nThis structure allows you to seamlessly integrate namespaced configurations into your modules, ensuring that your application remains organized and modular, without writing boilerplate, repetitive code.\n\nAs accessing process.env can be slow, you can set the cache property of the options object passed to ConfigModule.forRoot() to increase the performance of ConfigService#get method when it comes to variables stored in process.env.\n\nThus far, we've processed configuration files in our root module (e.g., AppModule), with the forRoot() method. Perhaps you have a more complex project structure, with feature-specific configuration files located in multiple different directories. Rather than load all these files in the root module, the @nestjs/config package provides a feature called partial registration, which references only the configuration files associated with each feature module. Use the forFeature() static method within a feature module to perform this partial registration, as follows:\n\nIt is standard practice to throw an exception during application startup if required environment variables haven't been provided or if they don't meet certain validation rules. The @nestjs/config package enables two different ways to do this:\n\nTo use Joi, we must install Joi package:\n\nNow we can define a Joi validation schema and pass it via the validationSchema property of the forRoot() method's options object, as shown below:\n\nBy default, all schema keys are considered optional. Here, we set default values for NODE_ENV and PORT which will be used if we don't provide these variables in the environment (.env file or process environment). Alternatively, we can use the required() validation method to require that a value must be defined in the environment (.env file or process environment). In this case, the validation step will throw an exception if we don't provide the variable in the environment. See Joi validation methods for more on how to construct validation schemas.\n\nBy default, unknown environment variables (environment variables whose keys are not present in the schema) are allowed and do not trigger a validation exception. By default, all validation errors are reported. You can alter these behaviors by passing an options object via the validationOptions key of the forRoot() options object. This options object can contain any of the standard validation options properties provided by Joi validation options. For example, to reverse the two settings above, pass options like this:\n\nThe @nestjs/config package uses default settings of:\n\nNote that once you decide to pass a validationOptions object, any settings you do not explicitly pass will default to Joi standard defaults (not the @nestjs/config defaults). For example, if you leave allowUnknowns unspecified in your custom validationOptions object, it will have the Joi default value of false. Hence, it is probably safest to specify both of these settings in your custom object.\n\nAlternatively, you can specify a synchronousvalidate function that takes an object containing the environment variables (from env file and process) and returns an object containing validated environment variables so that you can convert/mutate them if needed. If the function throws an error, it will prevent the application from bootstrapping.\n\nIn this example, we'll proceed with the class-transformer and class-validator packages. First, we have to define:\n\nWith this in place, use the validate function as a configuration option of the ConfigModule, as follows:\n\nConfigService defines a generic get() method to retrieve a configuration value by key. We may also add getter functions to enable a little more natural coding style:\n\nNow we can use the getter function as follows:\n\nIf a module configuration depends on the environment variables, and these variables are loaded from the .env file, you can use the ConfigModule.envVariablesLoaded hook to ensure that the file was loaded before interacting with the process.env object, see the following example:\n\nThis construction guarantees that after the ConfigModule.envVariablesLoaded Promise resolves, all configuration variables are loaded up.\n\nThere may be times where you want to conditionally load in a module and specify the condition in an env variable. Fortunately, @nestjs/config provides a ConditionalModule that allows you to do just that.\n\nThe above module would only load in the FooModule if in the .env file there is not a false value for the env variable USE_FOO. You can also pass a custom condition yourself, a function receiving the process.env reference that should return a boolean for the ConditionalModule to handle:\n\nIt is important to be sure that when using the ConditionalModule you also have the ConfigModule loaded in the application, so that the ConfigModule.envVariablesLoaded hook can be properly referenced and utilized. If the hook is not flipped to true within 5 seconds, or a timeout in milliseconds, set by the user in the third options parameter of the registerWhen method, then the ConditionalModule will throw an error and Nest will abort starting the application.\n\nThe @nestjs/config package supports environment variable expansion. With this technique, you can create nested environment variables, where one variable is referred to within the definition of another. For example:\n\nWith this construction, the variable SUPPORT_EMAIL resolves to 'support@mywebsite.com'. Note the use of the ${...} syntax to trigger resolving the value of the variable APP_URL inside the definition of SUPPORT_EMAIL.\n\nEnable environment variable expansion using the expandVariables property in the options object passed to the forRoot() method of the ConfigModule, as shown below:\n\nWhile our config is stored in a service, it can still be used in the main.ts file. This way, you can use it to store variables such as the application port or the CORS host.\n\nTo access it, you must use the app.get() method, followed by the service reference:\n\nYou can then use it as usual, by calling the get method with the configuration key:",
  "headings": [
    {
      "level": "h3",
      "text": "Configuration",
      "id": "configuration"
    },
    {
      "level": "h4",
      "text": "Installation#",
      "id": "installation"
    },
    {
      "level": "h4",
      "text": "Getting started#",
      "id": "getting-started"
    },
    {
      "level": "h4",
      "text": "Custom env file path#",
      "id": "custom-env-file-path"
    },
    {
      "level": "h4",
      "text": "Disable env variables loading#",
      "id": "disable-env-variables-loading"
    },
    {
      "level": "h4",
      "text": "Use module globally#",
      "id": "use-module-globally"
    },
    {
      "level": "h4",
      "text": "Custom configuration files#",
      "id": "custom-configuration-files"
    },
    {
      "level": "h2",
      "text": "Explore your graph with NestJS Devtools",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Using the ConfigService#",
      "id": "using-the-configservice"
    },
    {
      "level": "h4",
      "text": "Configuration namespaces#",
      "id": "configuration-namespaces"
    },
    {
      "level": "h4",
      "text": "Namespaced configurations in modules#",
      "id": "namespaced-configurations-in-modules"
    },
    {
      "level": "h4",
      "text": "Cache environment variables#",
      "id": "cache-environment-variables"
    },
    {
      "level": "h4",
      "text": "Partial registration#",
      "id": "partial-registration"
    },
    {
      "level": "h4",
      "text": "Schema validation#",
      "id": "schema-validation"
    },
    {
      "level": "h4",
      "text": "Custom validate function#",
      "id": "custom-validate-function"
    },
    {
      "level": "h4",
      "text": "Custom getter functions#",
      "id": "custom-getter-functions"
    },
    {
      "level": "h4",
      "text": "Environment variables loaded hook#",
      "id": "environment-variables-loaded-hook"
    },
    {
      "level": "h4",
      "text": "Conditional module configuration#",
      "id": "conditional-module-configuration"
    },
    {
      "level": "h4",
      "text": "Expandable variables#",
      "id": "expandable-variables"
    },
    {
      "level": "h4",
      "text": "Using in the main.ts#",
      "id": "using-in-the-maints"
    }
  ],
  "code_samples": [
    {
      "code": "$ npm i --save @nestjs/config",
      "language": "bash"
    },
    {
      "code": "import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\n@Module({\n  imports: [ConfigModule.forRoot()],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "DATABASE_USER=test\nDATABASE_PASSWORD=test",
      "language": "json"
    },
    {
      "code": "$ nest start --env-file .env",
      "language": "bash"
    },
    {
      "code": "ConfigModule.forRoot({\n  envFilePath: '.development.env',\n});",
      "language": "typescript"
    },
    {
      "code": "ConfigModule.forRoot({\n  envFilePath: ['.env.development.local', '.env.development'],\n});",
      "language": "typescript"
    },
    {
      "code": "ConfigModule.forRoot({\n  ignoreEnvFile: true,\n});",
      "language": "typescript"
    },
    {
      "code": "ConfigModule.forRoot({\n  isGlobal: true,\n});",
      "language": "typescript"
    },
    {
      "code": "export default () => ({\n  port: parseInt(process.env.PORT, 10) || 3000,\n  database: {\n    host: process.env.DATABASE_HOST,\n    port: parseInt(process.env.DATABASE_PORT, 10) || 5432\n  }\n});",
      "language": "typescript"
    },
    {
      "code": "import configuration from './config/configuration';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      load: [configuration],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "http:\n  host: 'localhost'\n  port: 8080\n\ndb:\n  postgres:\n    url: 'localhost'\n    port: 5432\n    database: 'yaml-db'\n\n  sqlite:\n    database: 'sqlite.db'",
      "language": "yaml"
    },
    {
      "code": "$ npm i js-yaml\n$ npm i -D @types/js-yaml",
      "language": "bash"
    },
    {
      "code": "import { readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport * as yaml from 'js-yaml';\n\nconst YAML_CONFIG_FILENAME = 'config.yaml';\n\nexport default () => {\n  return yaml.load(\n    readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),\n  ) as Record<string, any>;\n};",
      "language": "typescript"
    },
    {
      "code": "export default () => {\n  const config = yaml.load(\n    readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),\n  ) as Record<string, any>;\n\n  if (config.http.port < 1024 || config.http.port > 49151) {\n    throw new Error('HTTP port must be between 1024 and 49151');\n  }\n\n  return config;\n};",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [ConfigModule],\n  // ...\n})",
      "language": "typescript"
    },
    {
      "code": "constructor(private configService: ConfigService) {}",
      "language": "typescript"
    },
    {
      "code": "// get an environment variable\nconst dbUser = this.configService.get<string>('DATABASE_USER');\n\n// get a custom configuration value\nconst dbHost = this.configService.get<string>('database.host');",
      "language": "typescript"
    },
    {
      "code": "interface DatabaseConfig {\n  host: string;\n  port: number;\n}\n\nconst dbConfig = this.configService.get<DatabaseConfig>('database');\n\n// you can now use `dbConfig.port` and `dbConfig.host`\nconst port = dbConfig.port;",
      "language": "typescript"
    },
    {
      "code": "// use \"localhost\" when \"database.host\" is not defined\nconst dbHost = this.configService.get<string>('database.host', 'localhost');",
      "language": "typescript"
    },
    {
      "code": "interface EnvironmentVariables {\n  PORT: number;\n  TIMEOUT: string;\n}\n\n// somewhere in the code\nconstructor(private configService: ConfigService<EnvironmentVariables>) {\n  const port = this.configService.get('PORT', { infer: true });\n\n  // TypeScript Error: this is invalid as the URL property is not defined in EnvironmentVariables\n  const url = this.configService.get('URL', { infer: true });\n}",
      "language": "typescript"
    },
    {
      "code": "constructor(private configService: ConfigService<{ database: { host: string } }>) {\n  const dbHost = this.configService.get('database.host', { infer: true })!;\n  // typeof dbHost === \"string\"                                          |\n  //                                                                     +--> non-null assertion operator\n}",
      "language": "typescript"
    },
    {
      "code": "// ...\nconstructor(private configService: ConfigService<{ PORT: number }, true>) {\n  //                                                               ^^^^\n  const port = this.configService.get('PORT', { infer: true });\n  //    ^^^ The type of port will be 'number' thus you don't need TS type assertions anymore\n}",
      "language": "typescript"
    },
    {
      "code": "export default registerAs('database', () => ({\n  host: process.env.DATABASE_HOST,\n  port: process.env.DATABASE_PORT || 5432\n}));",
      "language": "typescript"
    },
    {
      "code": "import databaseConfig from './config/database.config';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      load: [databaseConfig],\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "const dbHost = this.configService.get<string>('database.host');",
      "language": "typescript"
    },
    {
      "code": "constructor(\n  @Inject(databaseConfig.KEY)\n  private dbConfig: ConfigType<typeof databaseConfig>,\n) {}",
      "language": "typescript"
    },
    {
      "code": "import databaseConfig from './config/database.config';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRootAsync(databaseConfig.asProvider()),\n  ],\n})",
      "language": "typescript"
    },
    {
      "code": "// Return value of the .asProvider() method\n{\n  imports: [ConfigModule.forFeature(databaseConfig)],\n  useFactory: (configuration: ConfigType<typeof databaseConfig>) => configuration,\n  inject: [databaseConfig.KEY]\n}",
      "language": "typescript"
    },
    {
      "code": "ConfigModule.forRoot({\n  cache: true,\n});",
      "language": "typescript"
    },
    {
      "code": "import databaseConfig from './config/database.config';\n\n@Module({\n  imports: [ConfigModule.forFeature(databaseConfig)],\n})\nexport class DatabaseModule {}",
      "language": "typescript"
    },
    {
      "code": "$ npm install --save joi",
      "language": "bash"
    },
    {
      "code": "import * as Joi from 'joi';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      validationSchema: Joi.object({\n        NODE_ENV: Joi.string()\n          .valid('development', 'production', 'test', 'provision')\n          .default('development'),\n        PORT: Joi.number().port().default(3000),\n      }),\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import * as Joi from 'joi';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      validationSchema: Joi.object({\n        NODE_ENV: Joi.string()\n          .valid('development', 'production', 'test', 'provision')\n          .default('development'),\n        PORT: Joi.number().port().default(3000),\n      }),\n      validationOptions: {\n        allowUnknown: false,\n        abortEarly: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "import { plainToInstance } from 'class-transformer';\nimport { IsEnum, IsNumber, Max, Min, validateSync } from 'class-validator';\n\nenum Environment {\n  Development = \"development\",\n  Production = \"production\",\n  Test = \"test\",\n  Provision = \"provision\",\n}\n\nclass EnvironmentVariables {\n  @IsEnum(Environment)\n  NODE_ENV: Environment;\n\n  @IsNumber()\n  @Min(0)\n  @Max(65535)\n  PORT: number;\n}\n\nexport function validate(config: Record<string, unknown>) {\n  const validatedConfig = plainToInstance(\n    EnvironmentVariables,\n    config,\n    { enableImplicitConversion: true },\n  );\n  const errors = validateSync(validatedConfig, { skipMissingProperties: false });\n\n  if (errors.length > 0) {\n    throw new Error(errors.toString());\n  }\n  return validatedConfig;\n}",
      "language": "typescript"
    },
    {
      "code": "import { validate } from './env.validation';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      validate,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class ApiConfigService {\n  constructor(private configService: ConfigService) {}\n\n  get isAuthEnabled(): boolean {\n    return this.configService.get('AUTH_ENABLED') === 'true';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Dependencies(ConfigService)\n@Injectable()\nexport class ApiConfigService {\n  constructor(configService) {\n    this.configService = configService;\n  }\n\n  get isAuthEnabled() {\n    return this.configService.get('AUTH_ENABLED') === 'true';\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Injectable()\nexport class AppService {\n  constructor(apiConfigService: ApiConfigService) {\n    if (apiConfigService.isAuthEnabled) {\n      // Authentication is enabled\n    }\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "@Dependencies(ApiConfigService)\n@Injectable()\nexport class AppService {\n  constructor(apiConfigService) {\n    if (apiConfigService.isAuthEnabled) {\n      // Authentication is enabled\n    }\n  }\n}",
      "language": "typescript"
    },
    {
      "code": "export async function getStorageModule() {\n  await ConfigModule.envVariablesLoaded;\n  return process.env.STORAGE === 'S3' ? S3StorageModule : DefaultStorageModule;\n}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.forRoot(),\n    ConditionalModule.registerWhen(FooModule, 'USE_FOO'),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.forRoot(),\n    ConditionalModule.registerWhen(\n      FooBarModule,\n      (env: NodeJS.ProcessEnv) => !!env['foo'] && !!env['bar'],\n    ),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "APP_URL=mywebsite.com\nSUPPORT_EMAIL=support@${APP_URL}",
      "language": "json"
    },
    {
      "code": "@Module({\n  imports: [\n    ConfigModule.forRoot({\n      // ...\n      expandVariables: true,\n    }),\n  ],\n})\nexport class AppModule {}",
      "language": "typescript"
    },
    {
      "code": "const configService = app.get(ConfigService);",
      "language": "typescript"
    },
    {
      "code": "const port = configService.get('PORT');",
      "language": "typescript"
    }
  ],
  "patterns": [
    {
      "description": "A custom configuration file exports a factory function that returns a configuration object. The configuration object can be any arbitrarily nested plain JavaScript object. The process.env object will contain the fully resolved environment variable key/value pairs (with .env file and externally defined variables resolved and merged as described above). Since you control the returned configuration object, you can add any required logic to cast values to an appropriate type, set default values, etc. For example:",
      "code": "process.env"
    },
    {
      "description": "Here's an example:",
      "code": "import databaseConfig from './config/database.config';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRootAsync(databaseConfig.asProvider()),\n  ],\n})"
    },
    {
      "description": "If a module configuration depends on the environment variables, and these variables are loaded from the .env file, you can use the ConfigModule.envVariablesLoaded hook to ensure that the file was loaded before interacting with the process.env object, see the following example:",
      "code": ".env"
    },
    {
      "description": "The @nestjs/config package supports environment variable expansion. With this technique, you can create nested environment variables, where one variable is referred to within the definition of another. For example:",
      "code": "@nestjs/config"
    }
  ],
  "links": [
    "https://docs.nestjs.com/first-steps",
    "https://docs.nestjs.com/controllers",
    "https://docs.nestjs.com/providers",
    "https://docs.nestjs.com/modules",
    "https://docs.nestjs.com/middleware",
    "https://docs.nestjs.com/exception-filters",
    "https://docs.nestjs.com/pipes",
    "https://docs.nestjs.com/guards",
    "https://docs.nestjs.com/interceptors",
    "https://docs.nestjs.com/custom-decorators",
    "https://docs.nestjs.com/fundamentals/custom-providers",
    "https://docs.nestjs.com/fundamentals/async-providers",
    "https://docs.nestjs.com/fundamentals/dynamic-modules",
    "https://docs.nestjs.com/fundamentals/injection-scopes",
    "https://docs.nestjs.com/fundamentals/circular-dependency",
    "https://docs.nestjs.com/fundamentals/module-ref",
    "https://docs.nestjs.com/fundamentals/lazy-loading-modules",
    "https://docs.nestjs.com/fundamentals/execution-context",
    "https://docs.nestjs.com/fundamentals/lifecycle-events",
    "https://docs.nestjs.com/fundamentals/discovery-service",
    "https://docs.nestjs.com/fundamentals/platform-agnosticism",
    "https://docs.nestjs.com/fundamentals/testing",
    "https://docs.nestjs.com/techniques/configuration",
    "https://docs.nestjs.com/techniques/database",
    "https://docs.nestjs.com/techniques/mongodb",
    "https://docs.nestjs.com/techniques/validation",
    "https://docs.nestjs.com/techniques/caching",
    "https://docs.nestjs.com/techniques/serialization",
    "https://docs.nestjs.com/techniques/versioning",
    "https://docs.nestjs.com/techniques/task-scheduling",
    "https://docs.nestjs.com/techniques/queues",
    "https://docs.nestjs.com/techniques/logger",
    "https://docs.nestjs.com/techniques/cookies",
    "https://docs.nestjs.com/techniques/events",
    "https://docs.nestjs.com/techniques/compression",
    "https://docs.nestjs.com/techniques/file-upload",
    "https://docs.nestjs.com/techniques/streaming-files",
    "https://docs.nestjs.com/techniques/http-module",
    "https://docs.nestjs.com/techniques/session",
    "https://docs.nestjs.com/techniques/mvc",
    "https://docs.nestjs.com/techniques/performance",
    "https://docs.nestjs.com/techniques/server-sent-events",
    "https://docs.nestjs.com/security/authentication",
    "https://docs.nestjs.com/security/authorization",
    "https://docs.nestjs.com/security/encryption-and-hashing",
    "https://docs.nestjs.com/security/helmet",
    "https://docs.nestjs.com/security/cors",
    "https://docs.nestjs.com/security/csrf",
    "https://docs.nestjs.com/security/rate-limiting",
    "https://docs.nestjs.com/graphql/quick-start",
    "https://docs.nestjs.com/graphql/resolvers",
    "https://docs.nestjs.com/graphql/mutations",
    "https://docs.nestjs.com/graphql/subscriptions",
    "https://docs.nestjs.com/graphql/scalars",
    "https://docs.nestjs.com/graphql/directives",
    "https://docs.nestjs.com/graphql/interfaces",
    "https://docs.nestjs.com/graphql/unions-and-enums",
    "https://docs.nestjs.com/graphql/field-middleware",
    "https://docs.nestjs.com/graphql/mapped-types",
    "https://docs.nestjs.com/graphql/plugins",
    "https://docs.nestjs.com/graphql/complexity",
    "https://docs.nestjs.com/graphql/extensions",
    "https://docs.nestjs.com/graphql/cli-plugin",
    "https://docs.nestjs.com/graphql/generating-sdl",
    "https://docs.nestjs.com/graphql/sharing-models",
    "https://docs.nestjs.com/graphql/other-features",
    "https://docs.nestjs.com/graphql/federation",
    "https://docs.nestjs.com/websockets/gateways",
    "https://docs.nestjs.com/websockets/exception-filters",
    "https://docs.nestjs.com/websockets/pipes",
    "https://docs.nestjs.com/websockets/guards",
    "https://docs.nestjs.com/websockets/interceptors",
    "https://docs.nestjs.com/websockets/adapter",
    "https://docs.nestjs.com/microservices/basics",
    "https://docs.nestjs.com/microservices/redis",
    "https://docs.nestjs.com/microservices/mqtt",
    "https://docs.nestjs.com/microservices/nats",
    "https://docs.nestjs.com/microservices/rabbitmq",
    "https://docs.nestjs.com/microservices/kafka",
    "https://docs.nestjs.com/microservices/grpc",
    "https://docs.nestjs.com/microservices/custom-transport",
    "https://docs.nestjs.com/microservices/exception-filters",
    "https://docs.nestjs.com/microservices/pipes",
    "https://docs.nestjs.com/microservices/guards",
    "https://docs.nestjs.com/microservices/interceptors",
    "https://docs.nestjs.com/standalone-applications",
    "https://docs.nestjs.com/cli/overview",
    "https://docs.nestjs.com/cli/monorepo",
    "https://docs.nestjs.com/cli/libraries",
    "https://docs.nestjs.com/cli/usages",
    "https://docs.nestjs.com/cli/scripts",
    "https://docs.nestjs.com/openapi/introduction",
    "https://docs.nestjs.com/openapi/types-and-parameters",
    "https://docs.nestjs.com/openapi/operations",
    "https://docs.nestjs.com/openapi/security",
    "https://docs.nestjs.com/openapi/mapped-types",
    "https://docs.nestjs.com/openapi/decorators",
    "https://docs.nestjs.com/openapi/cli-plugin",
    "https://docs.nestjs.com/openapi/other-features",
    "https://docs.nestjs.com/recipes/repl",
    "https://docs.nestjs.com/recipes/crud-generator",
    "https://docs.nestjs.com/recipes/swc",
    "https://docs.nestjs.com/recipes/passport",
    "https://docs.nestjs.com/recipes/hot-reload",
    "https://docs.nestjs.com/recipes/mikroorm",
    "https://docs.nestjs.com/recipes/sql-typeorm",
    "https://docs.nestjs.com/recipes/mongodb",
    "https://docs.nestjs.com/recipes/sql-sequelize",
    "https://docs.nestjs.com/recipes/router-module",
    "https://docs.nestjs.com/recipes/swagger",
    "https://docs.nestjs.com/recipes/terminus",
    "https://docs.nestjs.com/recipes/cqrs",
    "https://docs.nestjs.com/recipes/documentation",
    "https://docs.nestjs.com/recipes/prisma",
    "https://docs.nestjs.com/recipes/sentry",
    "https://docs.nestjs.com/recipes/serve-static",
    "https://docs.nestjs.com/recipes/nest-commander",
    "https://docs.nestjs.com/recipes/async-local-storage",
    "https://docs.nestjs.com/recipes/necord",
    "https://docs.nestjs.com/recipes/suites",
    "https://docs.nestjs.com/faq/serverless",
    "https://docs.nestjs.com/faq/http-adapter",
    "https://docs.nestjs.com/faq/keep-alive-connections",
    "https://docs.nestjs.com/faq/global-prefix",
    "https://docs.nestjs.com/faq/raw-body",
    "https://docs.nestjs.com/faq/hybrid-application",
    "https://docs.nestjs.com/faq/multiple-servers",
    "https://docs.nestjs.com/faq/request-lifecycle",
    "https://docs.nestjs.com/faq/common-errors",
    "https://docs.nestjs.com/techniques/techniques/configuration"
  ]
}